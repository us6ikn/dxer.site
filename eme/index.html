<!DOCTYPE html>
<html>
  <head>
    <title>Moon Sublunar Point</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #map {
        height: 100dvh;
        width: 100%;
      }

        #controls {
          position: absolute;
          top: 10px;
          left: 10px;
          z-index: 10;
          background-color: rgba(255, 255, 255, 0.95);
          padding: 12px;
          border-radius: 8px;
          max-width: 90vw;
          box-sizing: border-box;
          overflow: auto;
          max-height: 90vh; /* allow scrolling if needed */
        }

      label {
        font-weight: bold;
        font-size: 14px;
      }

      #hour-value {
        margin-left: 10px;
        font-weight: normal;
      }

      #hour {
        width: 100%;
        margin-top: 5px;
      }

      input[type="date"] {
        width: 100%;
        margin-bottom: 10px;
      }

        #chartWrapper {
          width: 100%;
          height: 100px; /* reasonable height across devices */
          margin-top: 12px;
          background-color: rgba(255, 255, 255, 0.85);
          border-radius: 6px;
          box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
        }

        #declinationChart {
          width: 100%;
          height: 100%; /* fill wrapper */
        }



        /* Optional: better mobile spacing */
        @media (max-width: 480px) {
          #controls {
            font-size: 13px;
            padding: 10px;
          }

          #declinationChart {
            height: 80px;
          }
        }

    </style>

    <!-- Chart.js and Annotation Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>
  </head>

  <body>
    <div id="map"></div>
    <div id="controls">
      <label for="date">Select Date (UTC):</label><br />
      <input type="date" id="date" /><br />

      <label for="hour">Select Hour (UTC):</label><br />
      <input type="range" id="hour" min="0" max="23" value="0" step="1" />
      <span id="hour-value">00:00</span>

      <!-- Declination graph inside controls -->
      <div id="chartWrapper">
        <canvas id="declinationChart"></canvas>
      </div>


    </div>


    <script>
      let map;
      let moonMarker;
      let footprintCircle;
      let declinationChart;

      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 2,
          center: { lat: 0, lng: 0 },
          mapTypeId: 'terrain',
          gestureHandling: 'greedy',
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false
        });

        fetch('moon_data_cleaned.txt')
          .then(response => response.json())
          .then(data => {
            window.moonData = data;
            initDeclinationChart(data);
            setDefaultTimeAndUpdateMap();
            restrictDatePicker();
          })
          .catch(error => console.error('Error loading moon data:', error));
      }

      function setDefaultTimeAndUpdateMap() {
        const now = new Date();
        const currentDate = now.toISOString().split('T')[0];
        const currentHour = now.getUTCHours().toString().padStart(2, '0');

        document.getElementById('date').value = currentDate;
        document.getElementById('hour').value = parseInt(currentHour);
        document.getElementById('hour-value').textContent = `${currentHour}:00`;

        updateMap();
      }

      function restrictDatePicker() {
        const now = new Date();
        const minDate = new Date(now);
        const maxDate = new Date(now);
        minDate.setDate(minDate.getDate() - 15);
        maxDate.setDate(maxDate.getDate() + 15);

        const minDateString = minDate.toISOString().split('T')[0];
        const maxDateString = maxDate.toISOString().split('T')[0];

        const dateInput = document.getElementById('date');
        dateInput.setAttribute('min', minDateString);
        dateInput.setAttribute('max', maxDateString);
      }

      document.getElementById('hour').addEventListener('input', function () {
        const hourStr = this.value.toString().padStart(2, '0');
        document.getElementById('hour-value').textContent = `${hourStr}:00`;
        updateMap();
      });

      document.getElementById('date').addEventListener('change', updateMap);

      function updateMap() {
        const selectedDate = document.getElementById('date').value;
        const selectedHour = document.getElementById('hour').value.toString().padStart(2, '0');

        if (!selectedDate) {
          alert("Please select a date.");
          return;
        }

        const utcTimeString = new Date(`${selectedDate}T${selectedHour}:00:00Z`)
          .toISOString()
          .slice(0, 19)
          .replace('T', ' ');

        const moonData = window.moonData.find(entry => entry.time === utcTimeString);

        if (!moonData) {
          alert("No moon data available for the selected UTC time.");
          return;
        }

        const lat = parseFloat(moonData.sublunar_lat);
        const lon = -parseFloat(moonData.sublunar_lon); // Negate if needed for direction
        const radius = parseFloat(moonData.footprint_radius_km) * 1000 * 1.02;

        map.setCenter({ lat: 0, lng: 0 });

        if (moonMarker) moonMarker.setMap(null);
        if (footprintCircle) footprintCircle.setMap(null);

        moonMarker = new google.maps.Marker({
          position: { lat, lng: lon },
          map: map,
          icon: {
            url: 'https://dxer.site/eme/moon-icon.png',
            scaledSize: new google.maps.Size(48, 48)
          },
          title: 'Moon Sublunar Point'
        });

        footprintCircle = new google.maps.Circle({
          map: map,
          center: { lat, lng: lon },
          radius: radius,
          fillColor: '#0088FF',
          fillOpacity: 0.3,
          strokeColor: '#0000FF',
          strokeOpacity: 0.6,
          strokeWeight: 2
        });

        updateDeclinationHighlight(selectedDate);
      }

      function initDeclinationChart(data) {
        const now = new Date();
        const from = new Date(now);
        const to = new Date(now);
        from.setDate(from.getDate() - 15);
        to.setDate(to.getDate() + 15);

        const filtered = data.filter(entry => {
          const time = new Date(entry.time.replace(' ', 'T') + 'Z');
          return time >= from && time <= to;
        });

        const dateMap = new Map();
        filtered.forEach(entry => {
          const dateStr = entry.time.split(' ')[0];
          if (!dateMap.has(dateStr)) dateMap.set(dateStr, []);
          dateMap.get(dateStr).push(entry); // Store full entry instead of just dec
        });


        const labels = Array.from(dateMap.keys());

        const declinations = labels.map(date => {
          const entries = dateMap.get(date);
          const avgDec = entries.reduce((sum, entry) => sum + parseFloat(entry.dec), 0) / entries.length;
          return parseFloat(avgDec.toFixed(2));
        });

        const distances = labels.map(date => {
          const entries = dateMap.get(date);
          const avgDist = entries.reduce((sum, entry) => sum + parseFloat(entry.distance_km), 0) / entries.length;
          return Math.round(avgDist); // Rounded for clarity
        });



        const ctx = document.getElementById('declinationChart').getContext('2d');

        declinationChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Declination (째)',
                data: declinations,
                borderColor: 'blue',
                yAxisID: 'y',
                fill: false,
                pointRadius: 0,
                tension: 0.2
              },
              {
                label: 'Distance (km)',
                data: distances,
                borderColor: 'green',
                yAxisID: 'y1',
                fill: false,
                pointRadius: 0,
                tension: 0.2
              }
            ]


          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              annotation: {
                annotations: {
                  todayLine: {
                    type: 'line',
                    xMin: '',
                    xMax: '',
                    borderColor: 'red',
                    borderWidth: 2,
                    label: {
                      display: true,
                      enabled: true,
                      position: 'start',
                      content: function(ctx) {
                        const index = ctx.chart.data.labels.indexOf(ctx.chart.options.plugins.annotation.annotations.todayLine.xMin);
                        if (index === -1) return '';
                        const dec = ctx.chart.data.datasets[0].data[index];
                        const dist = ctx.chart.data.datasets[1].data[index];
                        return `Dec: ${dec}째\nDist: ${Math.round(dist / 1000)}k`;
                      },
                      backgroundColor: 'rgba(255,255,255,0.9)',
                      font: {
                        size: 10,
                        weight: 'normal'
                      },
                      color: 'black',
                      padding: 4
                    }
                  }
                }
              }

              }

            },
            scales: {
              x: { display: true },
              y: {
                title: {
                  display: true,
                  text: 'Declination (째)'
                },
                min: -30,
                max: 30,
                position: 'left'
              },
              y11: {
                  position: 'right',
                  title: {
                    display: true,
                    text: 'Distance (km)'
                  },
                min: 356400,
                max: 406700,
                position: 'right',
                grid: { drawOnChartArea: false }, // prevent overlapping grids
                ticks: {
                  callback: function(value) {
                    return value.toLocaleString(); // e.g., 384,000
                  }
                }
              }
            }


          },
          plugins: [Chart.registry.getPlugin('annotation')]
        });
      }

        function updateDeclinationHighlight(dateStr) {
          if (!declinationChart) return;

          const labels = declinationChart.data.labels;
          const data = declinationChart.data.datasets[0].data;
          const index = labels.indexOf(dateStr);

          if (index === -1) return;

          const value = data[index];

          const annotation = declinationChart.options.plugins.annotation.annotations.todayLine;
          annotation.xMin = dateStr;
          annotation.xMax = dateStr;
          annotation.label.content = `${value}째`; // show the actual value

          declinationChart.update();
        }

    </script>

    <!-- Google Maps API -->
    <script async
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAPRWRoTRhE5TddxBITIhBcKjdQpz2CXRs&callback=initMap">
    </script>
  </body>
</html>
