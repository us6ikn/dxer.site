<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7YST3WTEH3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7YST3WTEH3');
    </script>
    <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>SA5IKN QRB Calculator - Azimuth and Terrain Elevation Finder</title>
  <meta name="description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.">
  <meta name="keywords" content="QRB calculator, azimuth finder, Maidenhead locator, grid square calculator, azimuth, ham radio, amateur radio, DX, terrain profile, elevation map, SA5IKN, line of sight, VHF, UHF, SHF, microwaves">
      <meta name="author" content="SA5IKN">
      <meta name="robots" content="index, follow">
          <link rel="canonical" href="https://dxer.site/sa5ikn-qrb-calculator/" />
          <!-- Favicon and App Icons -->
          <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
          <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
          <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
          <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
          <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
              <!-- Open Graph Meta (Facebook, LinkedIn, etc.) -->
                <meta property="og:title" content="SA5IKN QRB Calculator">
                <meta property="og:type" content="website">
                <meta property="og:description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.">
                <meta property="og:image" content="https://dxer.site/social/sa5ikn-qrb-calculator.jpg">
                <meta property="og:url" content="https://dxer.site/sa5ikn-qrb-calculator/">
                    
                    <!-- Twitter Meta -->
                      <meta name="twitter:card" content="summary_large_image">
                      <meta name="twitter:title" content="SA5IKN QRB Calculator" />
                      <meta name="twitter:description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph." />
                      <meta name="twitter:image" content="https://dxer.site/social/sa5ikn-qrb-calculator.jpg" />
              <script type="application/ld+json">
              {
                "@context": "https://schema.org",
                "@type": "WebApplication",
                "name": "SA5IKN QRB Calculator",
                "url": "https://dxer.site/sa5ikn-qrb-calculator/",
                "author": {
                  "@type": "Person",
                  "name": "SA5IKN"
                },
                "description": "SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.",
                "applicationCategory": "Science",
                "operatingSystem": "All",
                "browserRequirements": "Requires JavaScript",
                "inLanguage": "en",
                "applicationSubCategory": "Amateur Radio Application",
                "offers": {
                  "@type": "Offer",
                  "price": "0.00",
                  "priceCurrency": "USD"
                }

              }
            </script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    .widget-container {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1;
      display: flex;
      justify-content: center;
    }

    .widget {
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      width: 100%;
      max-width: 600px;
    }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }

    .input-row input[type="text"] {
      flex: 1;
      min-width: 60px;
      max-width: 160px;
      padding: 0.4em;
    }

    .input-row button {
      padding: 0.4em 1em;
      font-weight: bold;
    }

    #locator1 {
      border: 2px solid #1e88e5;
      background-color: #e3f2fd;
    }

    #locator2 {
      border: 2px solid #43a047;
      background-color: #e8f5e9;
    }

    #azimuthResult, #obstructionWarning {
      margin-top: 0.5rem;
      font-weight: bold;
    }

      #obstructionWarning {
        color: #333; /* dark neutral gray */
        font-size: 0.7em; /* smaller font */
      }

      #elevation_chart {
        height: 0;
        transition: height 0.3s ease;
        overflow: hidden;
      }
  </style>
</head>
<body>
<div id="map"></div>
<div class="widget-container">
  <div class="widget">
      <div class="input-row">
        <a href="https://dxer.site" title="Back to Home" style="text-decoration: none; font-size: 1.4em; padding: 0.3em 0.5em;">üè†</a>
        <input type="text" id="locator1" maxlength="10" placeholder="e.g. JN58td12AB" />
        <input type="text" id="locator2" maxlength="10" placeholder="e.g. IO91wm34CD" />
        <button onclick="calculateAzimuth()">Calculate</button>
      </div>

    <div id="initialInstructions" style="margin-top: 1em; color: #444; font-size: 0.95em; line-height: 1.5;">
        <h3 style="margin-top: 0; font-size: 1.2em;">How to use SA5IKN QRB Calculator</h3>
        <p>Enter two Maidenhead locators in the fields above. Valid locator lengths are from <strong>4 to 10 characters</strong>.</p>

        <ul style="padding-left: 1.2em; margin-top: 0.5em;">
          <li><span style="color:#1e88e5; font-weight:bold;">Blue marker</span>: Your QTH locator</li>
          <li><span style="color:#43a047; font-weight:bold;">Green marker</span>: DX station locator</li>
        </ul>

        <p>Once both locators are entered, the map will show the azimuth, distance, and a line connecting the two markers. A terrain elevation profile between the points will appear below.</p>

        <p>You can also <strong>drag either marker</strong> directly on the map. The corresponding locator input will update dynamically.</p>
    </div>
    <div id="azimuthResult"></div>
    <div id="obstructionWarning"></div>
    <div id="elevation_chart"></div>
  </div>
</div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

<script>
  function setMapHeight() {
    const vh = window.innerHeight;
    document.getElementById('map').style.height = vh + 'px';
  }
  window.addEventListener('load', setMapHeight);
  window.addEventListener('resize', setMapHeight);
</script>

<script>
  let map;
  let markers = [];
  let line;
  let elevator;

  google.charts.load('current', { packages: ['corechart'] });

  function locatorToLatLng(locator) {
    locator = locator.toUpperCase();
    const A = 'A'.charCodeAt(0);

    let lon = -180;
    let lat = -90;

    if (locator.length >= 2) {
      lon += (locator.charCodeAt(0) - A) * 20;
      lat += (locator.charCodeAt(1) - A) * 10;
    }
    if (locator.length >= 4) {
      lon += parseInt(locator[2]) * 2;
      lat += parseInt(locator[3]) * 1;
    }
    if (locator.length >= 6) {
      lon += (locator.charCodeAt(4) - A) * 5 / 60;
      lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
    }
    if (locator.length >= 8) {
      lon += parseInt(locator[6]) * (5 / 600);
      lat += parseInt(locator[7]) * (2.5 / 600);
    }
    if (locator.length >= 10) {
      lon += (locator.charCodeAt(8) - A) * (5 / 14400);
      lat += (locator.charCodeAt(9) - A) * (2.5 / 14400);
    }

    // ‚úÖ Add center offset based on precision level
    const precision = locator.length;
    if (precision === 2) {
      lon += 10; lat += 5;
    } else if (precision === 4) {
      lon += 1; lat += 0.5;
    } else if (precision === 6) {
      lon += 2.5 / 60; lat += 1.25 / 60;
    } else if (precision === 8) {
      lon += 5 / 1200; lat += 2.5 / 1200; // midpoint of 5"/600
    } else if (precision === 10) {
      lon += 5 / 28800; lat += 2.5 / 28800; // midpoint of 5"/14400
    }

    return { lat, lng: lon };
  }

    function latLngToLocator(lat, lon, precision = 6) {
      const A = 'A'.charCodeAt(0);
      lat += 90;
      lon += 180;

      let locator = '';

      locator += String.fromCharCode(Math.floor(lon / 20) + A);
      locator += String.fromCharCode(Math.floor(lat / 10) + A);

      lon = (lon % 20);
      lat = (lat % 10);
      locator += Math.floor(lon / 2);
      locator += Math.floor(lat / 1);

      if (precision >= 6) {
        lon = (lon % 2);
        lat = (lat % 1);
        locator += String.fromCharCode(Math.floor(lon * 60 / 5) + A);
        locator += String.fromCharCode(Math.floor(lat * 60 / 2.5) + A);
      }

      if (precision >= 8) {
        lon = (lon * 60 % 5);
        lat = (lat * 60 % 2.5);
        locator += Math.floor(lon / (5 / 10));
        locator += Math.floor(lat / (2.5 / 10));
      }

      if (precision >= 10) {
        lon = (lon % (5 / 10));
        lat = (lat % (2.5 / 10));
        locator += String.fromCharCode(Math.floor(lon / (5 / 240)) + A);
        locator += String.fromCharCode(Math.floor(lat / (2.5 / 240)) + A);
      }

      return locator.slice(0, precision);
    }

  function computeAzimuth(from, to) {
    const lat1 = toRadians(from.lat);
    const lat2 = toRadians(to.lat);
    const dLon = toRadians(to.lng - from.lng);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) -
              Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    brng = (toDegrees(brng) + 360) % 360;
    return brng.toFixed(2);
  }

  function toRadians(deg) {
    return deg * Math.PI / 180;
  }

  function toDegrees(rad) {
    return rad * 180 / Math.PI;
  }

  function initMap() {
    map = new google.maps.Map(document.getElementById('map'), {
      center: { lat: 0, lng: 0 },
      zoom: 2,
    });
    elevator = new google.maps.ElevationService();
  }

  function calculateAzimuth() {
    const loc1 = document.getElementById('locator1').value.trim();
    const loc2 = document.getElementById('locator2').value.trim();
    if (loc1.length < 4 || loc2.length < 4) {
      alert("Please enter valid QTH locators (at least 4 characters).");
      return;
    }

    document.getElementById('initialInstructions').style.display = 'none';
    
    const pos1 = locatorToLatLng(loc1);
    const pos2 = locatorToLatLng(loc2);
    const azimuth = computeAzimuth(pos1, pos2);

    const distance = google.maps.geometry.spherical.computeDistanceBetween(
      new google.maps.LatLng(pos1.lat, pos1.lng),
      new google.maps.LatLng(pos2.lat, pos2.lng)
    ) / 1000;

    document.getElementById('azimuthResult').innerText =
      `Azimuth: ${azimuth}¬∞ | Distance: ${distance.toFixed(2)} km`;

    updateMap(pos1, pos2);
  }

  function updateMap(pos1, pos2) {
    markers.forEach(marker => marker.setMap(null));
    markers = [];

    if (line) line.setMap(null);

    const marker1 = new google.maps.Marker({
      position: pos1,
      map: map,
      draggable: true,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 8,
        fillColor: '#1e88e5', // Modern blue
        fillOpacity: 1,
        strokeWeight: 1,
        strokeColor: '#ffffff',
      },
    });

    const marker2 = new google.maps.Marker({
      position: pos2,
      map: map,
      draggable: true,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 8,
        fillColor: '#43a047', // Muted green
        fillOpacity: 1,
        strokeWeight: 1,
        strokeColor: '#ffffff',
      },
    });


    marker1.addListener('drag', () => onMarkerMoved(marker1, marker2));
    marker2.addListener('drag', () => onMarkerMoved(marker1, marker2));

    markers.push(marker1, marker2);

    line = new google.maps.Polyline({
      path: [pos1, pos2],
      geodesic: true,
      strokeColor: "#FF0000",
      strokeOpacity: 1.0,
      strokeWeight: 2,
    });
    line.setMap(map);

    const bounds = new google.maps.LatLngBounds();
    bounds.extend(pos1);
    bounds.extend(pos2);
    map.fitBounds(bounds);

    elevator.getElevationAlongPath({
      path: [pos1, pos2],
      samples: 256
    }, function(results, status) {
      if (status === 'OK') {
        plotElevation(results);
        checkObstruction(results, pos1, pos2);
      } else {
        document.getElementById('elevation_chart').innerText = 'Elevation service failed.';
      }
    });
  }

    function onMarkerMoved(marker1, marker2) {
      const pos1 = marker1.getPosition();
      const pos2 = marker2.getPosition();

      const loc1 = latLngToLocator(pos1.lat(), pos1.lng(), 10);
      const loc2 = latLngToLocator(pos2.lat(), pos2.lng(), 10);

      document.getElementById('locator1').value = loc1;
      document.getElementById('locator2').value = loc2;

      const azimuth = computeAzimuth(
        { lat: pos1.lat(), lng: pos1.lng() },
        { lat: pos2.lat(), lng: pos2.lng() }
      );

      const distance = google.maps.geometry.spherical.computeDistanceBetween(
        pos1,
        pos2
      ) / 1000;

      document.getElementById('azimuthResult').innerText =
        `Azimuth: ${azimuth}¬∞ | Distance: ${distance.toFixed(2)} km`;

      // Update line path
      line.setPath([pos1, pos2]);

      // Recalculate elevation
      elevator.getElevationAlongPath({
        path: [pos1, pos2],
        samples: 256
      }, function(results, status) {
        if (status === 'OK') {
          plotElevation(results);
          checkObstruction(results, { lat: pos1.lat(), lng: pos1.lng() }, { lat: pos2.lat(), lng: pos2.lng() });
        } else {
          document.getElementById('elevation_chart').innerText = 'Elevation service failed.';
        }
      });
    }

    function plotElevation(results) {
      const data = new google.visualization.DataTable();
      data.addColumn('number', 'Distance (km)');
      data.addColumn('number', 'Elevation (m)');

      let totalDistance = 0;
      for (let i = 0; i < results.length; i++) {
        if (i > 0) {
          totalDistance += google.maps.geometry.spherical.computeDistanceBetween(
            results[i - 1].location,
            results[i].location
          );
        }
        data.addRow([totalDistance / 1000, results[i].elevation]);
      }

      const container = document.getElementById('elevation_chart');
      const chart = new google.visualization.AreaChart(container);
      document.getElementById('elevation_chart').style.height = '200px';
      chart.draw(data, {
        width: container.offsetWidth,
        height: 200,
        legend: 'none',
        chartArea: {
          left: 60,
          right: 10,
          top: 20,
          bottom: 40,
          width: '100%',
          height: '100%'
        },
        hAxis: { title: 'Distance (km)', format: '#.##', gridlines: { count: 5 } },
        vAxis: {
          title: 'Elevation (m)',
          gridlines: { count: 5 },
          viewWindow: {
            min: 0
          }
        },
        areaOpacity: 0.3,
        colors: ['#1a73e8'],
      });
    }

  function checkObstruction(results, pos1, pos2) {
    const startElev = results[0].elevation;
    const endElev = results[results.length - 1].elevation;

    const totalDistance = google.maps.geometry.spherical.computeDistanceBetween(
      new google.maps.LatLng(pos1.lat, pos1.lng),
      new google.maps.LatLng(pos2.lat, pos2.lng)
    );

    let obstructed = false;
    for (let i = 1; i < results.length - 1; i++) {
      const fraction = i / (results.length - 1);
      const expectedLineElev = startElev + fraction * (endElev - startElev);
      if (results[i].elevation > expectedLineElev + 1) {
        obstructed = true;
        break;
      }
    }

    const warning = document.getElementById('obstructionWarning');
    warning.innerText = obstructed
      ? "‚ö†Ô∏è Line of sight is obstructed by terrain"
      : "‚úÖ Line of sight is clear";
  }

  window.onload = initMap;
</script>

<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAPRWRoTRhE5TddxBITIhBcKjdQpz2CXRs&libraries=geometry&callback=initMap"></script>
<!-- Ko-Fi -->
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script src="/kofi.js"></script>
</body>
</html>
