<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>WSJT-X Precision Moon Tracker (JS)</title>
<style>
body { font-family: sans-serif; padding: 24px; background: #f0f4f8; }
label, input, button { display: block; margin: 8px 0; }
.result { margin-top: 12px; font-family: monospace; white-space: pre; background:#e8f0ff;padding:12px;border-radius:6px;}
</style>
</head>
<body>

<h1>WSJT-X Precision Moon Tracker</h1>
<label>Maidenhead QTH locator (6 chars)</label>
<input id="locator" type="text" value="JO32LR" maxlength="6">
<label>UTC Date & Time</label>
<input id="datetime" type="datetime-local" value="2025-11-20T07:50">
<button id="compute">Compute</button>
<div class="result" id="out"></div>

<script type="module">
// ------------------------ Utilities ------------------------
const DEG = 180/Math.PI;
const RAD = Math.PI/180;
const CLIGHT = 299792.458; // km/s

function deg2rad(d){ return d*RAD; }
function rad2deg(r){ return r*DEG; }
function normalizeDeg(d){ let x=d%360; return x<0? x+360:x; }
function pad2(n){return n.toString().padStart(2,'0');}

// Convert 6-char Maidenhead to lat/lon
function maidenheadToLatLon(locator){
  let s=(locator||'').trim().toUpperCase();
  if(s.length<6) s=s.padEnd(6,'A'); s=s.slice(0,6);
  const A='A'.charCodeAt(0);
  let lon=(s.charCodeAt(0)-A)*20 -180;
  let lat=(s.charCodeAt(1)-A)*10 -90;
  lon += parseInt(s[2])*2 + (s.charCodeAt(4)-A+0.5)*(2/24);
  lat += parseInt(s[3]) + (s.charCodeAt(5)-A+0.5)*(1/24);
  return {lat, lon};
}

// Julian Date (UTC)
function toJulianDate(date){
  const Y=date.getUTCFullYear(), M=date.getUTCMonth()+1, D=date.getUTCDate();
  const h=date.getUTCHours(), m=date.getUTCMinutes(), s=date.getUTCSeconds();
  let y=Y, mon=M;
  if(mon<=2){y-=1; mon+=12;}
  const A=Math.floor(y/100);
  const B=2-A+Math.floor(A/4);
  const JD0=Math.floor(365.25*(y+4716)) + Math.floor(30.6001*(mon+1)) + D + B -1524.5;
  return JD0 + (h+m/60+s/3600)/24;
}

// Greenwich Sidereal Time in degrees
function gstFromJD(JD){
  const T=(JD-2451545.0)/36525.0;
  let GST=280.46061837 + 360.98564736629*(JD-2451545.0) +
          T*T*(0.000387933 - T/38710000);
  return normalizeDeg(GST);
}

// Local Sidereal Time in degrees
function lstFromJD(JD, lon){
  return normalizeDeg(gstFromJD(JD)+lon);
}

// ------------------------ Moon position ------------------------
// Simplified ELP2000-like series for JS (geocentric)
// Returns RA (deg), Dec (deg), distance (km)
function moonGeocentric(JD){
  const T=(JD-2451545)/36525;
  // Mean elements (from Meeus, truncated)
  let L0=218.3164477 + 481267.88123421*T -0.0015786*T*T;
  let M=134.9633964 + 477198.8675055*T +0.0087414*T*T;
  let F=93.2720950 + 483202.0175233*T -0.0036539*T*T;
  L0=normalizeDeg(L0); M=normalizeDeg(M); F=normalizeDeg(F);
  // Longitude perturbation (truncated series)
  let L=L0 + 6.289*sin(deg2rad(M));
  let B=5.128*sin(deg2rad(F));
  let R=385001 - 20905*cos(deg2rad(M));
  // Equatorial coordinates
  let eps=23.439291 - 0.0130042*T; // mean obliquity
  let lambda=deg2rad(L), beta=deg2rad(B), epsRad=deg2rad(eps);
  let x=R*Math.cos(beta)*Math.cos(lambda);
  let y=R*(Math.cos(beta)*Math.sin(lambda)*Math.cos(epsRad)-Math.sin(beta)*Math.sin(epsRad));
  let z=R*(Math.cos(beta)*Math.sin(lambda)*Math.sin(epsRad)+Math.sin(beta)*Math.cos(epsRad));
  let RA=rad2deg(Math.atan2(y,x)); if(RA<0) RA+=360;
  let Dec=rad2deg(Math.atan2(z,Math.sqrt(x*x+y*y)));
  return {RA, Dec, distance:R};
}

// Topocentric correction for observer
function topocentric(RAdeg,Decdeg,Rkm,lat,lon){
  // Convert to radians
  let RA=deg2rad(RAdeg), Dec=deg2rad(Decdeg);
  let latRad=deg2rad(lat), lonRad=deg2rad(lon);
  // Observer geocentric radius
  let Re=6378.137; // km
  let x=Rkm*Math.cos(Dec)*Math.cos(RA)-Re*Math.cos(latRad)*Math.cos(lonRad);
  let y=Rkm*Math.cos(Dec)*Math.sin(RA)-Re*Math.cos(latRad)*Math.sin(lonRad);
  let z=Rkm*Math.sin(Dec)-Re*Math.sin(latRad);
  let raTopo=Math.atan2(y,x), decTopo=Math.atan2(z,Math.sqrt(x*x+y*y));
  return {RAdeg:rad2deg(raTopo), Decdeg:rad2deg(decTopo)};
}

// Convert RA/Dec to Az/El
function raDecToAzEl(RAdeg,Decdeg,lat,lon,JD){
  const LSTdeg=lstFromJD(JD,lon);
  let HAdeg=LSTdeg-RAdeg; if(HAdeg<0) HAdeg+=360;
  let HA=deg2rad(HAdeg), Dec=deg2rad(Decdeg), latRad=deg2rad(lat);
  let el=Math.asin(Math.sin(latRad)*Math.sin(Dec)+Math.cos(latRad)*Math.cos(Dec)*Math.cos(HA));
  let az=Math.atan2(-Math.cos(Dec)*Math.sin(HA),
                    Math.sin(Dec)-Math.sin(latRad)*Math.sin(el));
  if(az<0) az+=2*Math.PI;
  return {az:rad2deg(az), el:rad2deg(el)};
}

// ------------------------ Compute Moon ------------------------
function computeMoon(locator,date){
  const {lat,lon}=maidenheadToLatLon(locator);
  const JD=toJulianDate(date);
  let moon=moonGeocentric(JD);
  let topo=topocentric(moon.RA,moon.Dec,moon.distance,lat,lon);
  let azel=raDecToAzEl(topo.RAdeg,topo.Decdeg,lat,lon,JD);
  return {
    az:azel.az, el:azel.el, ra_hours:topo.RAdeg/15,
    dec_deg:topo.Decdeg, distance_km:moon.distance,
    lat, lon, JD
  };
}

// ------------------------ UI ------------------------
document.getElementById('compute').addEventListener('click', ()=>{
  const loc=document.getElementById('locator').value;
  const dt=document.getElementById('datetime').value;
  if(!loc||!dt){ alert('Enter locator and date'); return; }
  const date=new Date(dt+'Z'); // UTC
  const res=computeMoon(loc,date);
  document.getElementById('out').textContent=
    `Az: ${res.az.toFixed(4)}°\nEl: ${res.el.toFixed(4)}°\nRA: ${res.ra_hours.toFixed(5)} h\nDec: ${res.dec_deg.toFixed(4)}°\nDistance: ${res.distance_km.toFixed(3)} km\nLat: ${res.lat.toFixed(6)}° Lon: ${res.lon.toFixed(6)}°\nJD: ${res.JD.toFixed(6)}`;
});
</script>
</body>
</html>
