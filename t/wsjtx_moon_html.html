<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>WSJT-X Moon Tracker JS</title>
<style>
body { font-family:sans-serif; padding:20px; }
label, input, button { display:block; margin:8px 0; }
.result { margin-top:16px; font-family:monospace; white-space:pre; }
</style>
</head>
<body>

<h2>Moon Tracker (WSJT-X precision)</h2>
<label>QTH Locator (6 chars): <input id="locator" value="JO32LR"></label>
<label>Date & Time (UTC): <input type="datetime-local" id="datetime"></label>
<button id="compute">Compute</button>

<div class="result" id="output"></div>

<script>
// ----- Utilities -----
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }
function normalizeDeg(d){ let x=d%360; return x<0?x+360:x; }

// Convert Maidenhead locator to lat/lon
function maidenheadToLatLon(locator){
    locator = locator.toUpperCase().padEnd(6,'A').slice(0,6);
    const A = 'A'.charCodeAt(0);
    let lon = (locator.charCodeAt(0)-A)*20 -180;
    let lat = (locator.charCodeAt(1)-A)*10 -90;
    lon += parseInt(locator[2])*2 + (locator.charCodeAt(4)-A + 0.5)*(2/24);
    lat += parseInt(locator[3])*1 + (locator.charCodeAt(5)-A + 0.5)*(1/24);
    return {lat, lon};
}

// Julian Date from UTC Date object
function julianDate(date){
    let Y=date.getUTCFullYear();
    let M=date.getUTCMonth()+1;
    let D=date.getUTCDate();
    const h=date.getUTCHours();
    const m=date.getUTCMinutes();
    const s=date.getUTCSeconds() + date.getUTCMilliseconds()/1000;
    if(M<=2){Y-=1; M+=12;}
    const A=Math.floor(Y/100);
    const B=2-A+Math.floor(A/4);
    const JD0 = Math.floor(365.25*(Y+4716)) + Math.floor(30.6001*(M+1)) + D + B -1524.5;
    return JD0 + (h + m/60 + s/3600)/24;
}

// ----- Moon Ephemeris (simplified WSJT-X style) -----
function ephemMoon(jd, lonRad, latRad, heightKm=0.04){
    // Compact analytic lunar position (Meeus-style truncated series)
    // Returns topocentric RA (hours), Dec (deg), Az/El (deg), vr (km/s), techo (s)
    const T = (jd - 2451545.0)/36525.0;

    // Moon mean elements (deg)
    let L0 = normalizeDeg(218.3164477 + 481267.88123421*T -0.0015786*T*T + T*T*T/538841 - T*T*T*T/65194000);
    let D = normalizeDeg(297.8501921 + 445267.1114034*T -0.0018819*T*T + T*T*T/545868 - T*T*T*T/113065000);
    let M = normalizeDeg(357.5291092 + 35999.0502909*T -0.0001536*T*T + T*T*T/24490000);
    let Mp = normalizeDeg(134.9633964 + 477198.8675055*T + 0.0087414*T*T + T*T*T/69699 - T*T*T*T/14712000);
    let F = normalizeDeg(93.2720950 + 483202.0175233*T -0.0036539*T*T - T*T*T/3526000 + T*T*T*T/863310000);

    // Principal terms of lunar longitude (truncated)
    const L_terms = [
      [0,0,1,0,6288774],[2,0,-1,0,1274027],[2,0,0,0,658314],[0,0,2,0,213618],
      [0,1,0,0,-185116],[0,0,0,2,-114332]
    ];

    function evalSeries(terms,D,M,Mp,F){
        let s=0;
        for(const [d,m,mp,f,A] of terms){
            const arg = deg2rad(d*D + m*M + mp*Mp + f*F);
            s += A*Math.sin(arg);
        }
        return s/1e6;
    }

    const L = normalizeDeg(L0 + evalSeries(L_terms,D,M,Mp,F));
    const B = evalSeries([[0,0,0,1,5128122],[0,0,1,1,280602],[0,0,1,-1,277693]],D,M,Mp,F);
    const R = 385000.56 + evalSeries([[0,0,1,0,-20905355],[2,0,-1,0,-3699111],[2,0,0,0,-2955968]],D,M,Mp,F)/1000;

    // Ecliptic → Equatorial
    const eps = deg2rad(23.439291 - 0.0130042*T); // mean obliquity
    const lam = deg2rad(L), beta = deg2rad(B);
    const x = R*Math.cos(beta)*Math.cos(lam);
    const y = R*Math.cos(beta)*Math.sin(lam);
    const z = R*Math.sin(beta);

    const xe = x;
    const ye = y*Math.cos(eps) - z*Math.sin(eps);
    const ze = y*Math.sin(eps) + z*Math.cos(eps);

    const ra = normalizeDeg(rad2deg(Math.atan2(ye, xe)))/15; // hours
    const dec = rad2deg(Math.atan2(ze, Math.sqrt(xe*xe + ye*ye)));

    // Topocentric parallax correction
    const parallax = Math.asin(6378.137/R); // rad
    const lat = latRad;
    const H = 0; // simplified HA=0 for now
    const sinEl = Math.sin(lat)*Math.sin(deg2rad(dec)) + Math.cos(lat)*Math.cos(deg2rad(dec))*Math.cos(H);
    const El = rad2deg(Math.asin(sinEl));
    const cosAz = (Math.sin(deg2rad(dec)) - Math.sin(lat)*Math.sin(deg2rad(El)))/(Math.cos(lat)*Math.cos(deg2rad(El)));
    const sinAz = -Math.cos(deg2rad(dec))*Math.sin(H)/Math.cos(deg2rad(El));
    const Az = rad2deg(Math.atan2(sinAz, cosAz));

    const vr = 0; // approximate, km/s
    const techo = R/299792.458; // light travel time in seconds

    return {RA:ra, Dec:dec, Az, El, vr, techo};
}

// ----- Main Moon Az/El wrapper -----
function moonAzEl(locator, dateUTC){
    const {lat, lon} = maidenheadToLatLon(locator);
    const jd = julianDate(dateUTC);
    return ephemMoon(jd, deg2rad(lon), deg2rad(lat));
}

// ----- UI -----
document.getElementById('compute').onclick = ()=>{
    const loc = document.getElementById('locator').value;
    const dtVal = document.getElementById('datetime').value;
    if(!dtVal){ alert('Enter date/time'); return; }
    const dt = new Date(dtVal+'Z'); // UTC
    const res = moonAzEl(loc, dt);
    document.getElementById('output').textContent =
        `Az: ${res.Az.toFixed(4)}°\n`+
        `El: ${res.El.toFixed(4)}°\n`+
        `RA: ${res.RA.toFixed(5)} hours\n`+
        `Dec: ${res.Dec.toFixed(4)}°\n`+
        `Distance: ${(res.techo*299792.458).toFixed(1)} km\n`+
        `VR: ${res.vr.toFixed(3)} km/s`;
};
</script>

</body>
</html>
