<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Continuum — dB vs Time (RMS)</title>
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px;background:#0f172a;color:#e6eef8}
    h1{font-size:18px;margin:0 0 8px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
    select,input,button{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:#071029;color:#e6eef8}
    label{font-size:13px}
    .small{font-size:12px;color:#9fb0d0}
    #canvasWrap{background:#021028;padding:8px;border-radius:8px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    canvas{display:block;border-radius:4px;background:linear-gradient(180deg,#041226 0%, #00101a 100%)}
    .footer{margin-top:10px;font-size:13px;color:#9fb0d0}
  </style>
</head>
<body>
  <h1>Continuum — Real-time dB vs Time (RMS)</h1>
  <div class="controls">
    <div>
      <label for="deviceSelect">Input device</label><br>
      <select id="deviceSelect"></select>
      <button id="refreshDevices">Refresh</button>
    </div>
    <div>
      <label for="integration">Integration (ms)</label><br>
      <input id="integration" type="number" value="500" min="1" step="50" style="width:110px" />
    </div>
    <div>
      <label for="timeWindow">Time window (s)</label><br>
      <input id="timeWindow" type="number" value="30" min="1" step="1" style="width:110px" />
    </div>
    <div>
      <label>&nbsp;</label><br>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>
    <div style="margin-left:12px">
      <div class="small">Current level: <span id="currentDb">—</span> dB</div>
      <div class="small">Sample rate: <span id="sampleRate">—</span> Hz</div>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="plot" width="900" height="240"></canvas>
  </div>

  <div class="footer">
    Notes: This single-file page uses the Web Audio API + AudioWorklet to compute RMS from the selected input device and plots dB vs time. Run on a secure origin (https) or localhost. If device labels are empty, press Refresh after granting microphone permission.
  </div>

<script>
// Single-file RMS AudioWorklet + plotting demo
let audioCtx = null;
let stream = null;
let sourceNode = null;
let workletNode = null;
let deviceId = null;
let sampleRate = null;
let running = false;

const deviceSelect = document.getElementById('deviceSelect');
const refreshBtn = document.getElementById('refreshDevices');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const integrationInput = document.getElementById('integration');
const timeWindowInput = document.getElementById('timeWindow');
const currentDbSpan = document.getElementById('currentDb');
const sampleRateSpan = document.getElementById('sampleRate');

const canvas = document.getElementById('plot');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const dBMin = -100, dBMax = 0;

// buffer of {t, valueDb}
let samples = [];

async function listDevices(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const inputs = devices.filter(d=>d.kind==='audioinput');
    deviceSelect.innerHTML = '';
    inputs.forEach(d=>{
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || ('Input — ' + d.deviceId);
      deviceSelect.appendChild(opt);
    });
    if(inputs.length===0){
      const opt = document.createElement('option'); opt.value=''; opt.textContent='(no audio input found)'; deviceSelect.appendChild(opt);
    }
  }catch(err){
    console.error('listDevices error',err);
  }
}

refreshBtn.addEventListener('click', async ()=>{
  await listDevices();
});

async function start(){
  if(running) return;
  deviceId = deviceSelect.value || undefined;
  const constraints = { audio: deviceId ? { deviceId: { exact: deviceId } } : true };
  try{
    stream = await navigator.mediaDevices.getUserMedia(constraints);
  }catch(err){
    alert('getUserMedia failed: '+err.message);
    return;
  }

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  sampleRate = audioCtx.sampleRate;
  sampleRateSpan.textContent = sampleRate;

  // create AudioWorklet from a Blob
  const workletCode = `
  class RMSProcessor extends AudioWorkletProcessor {
    constructor(){
      super();
      this._lastPost = currentTime;
    }
    process(inputs, outputs, parameters){
      const in0 = inputs[0];
      if(!in0 || in0.length===0) return true;
      // merge channels
      const chCount = in0.length;
      const len = in0[0].length;
      let sumSq = 0;
      for(let c=0;c<chCount;c++){
        const ch = in0[c];
        for(let i=0;i<len;i++){ const v = ch[i]; sumSq += v*v; }
      }
      const samples = len * chCount;
      const rms = Math.sqrt(sumSq / Math.max(1,samples));
      // Post rms and a timestamp (in milliseconds)
      this.port.postMessage({ rms: rms, t: (currentTime*1000) });
      return true;
    }
  }
  registerProcessor('rms-processor', RMSProcessor);
  `;

  const blob = new Blob([workletCode], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  try{
    await audioCtx.audioWorklet.addModule(url);
  }catch(err){
    console.error('addModule failed', err);
    alert('AudioWorklet addModule failed: '+err.message);
    return;
  } finally{
    URL.revokeObjectURL(url);
  }

  sourceNode = audioCtx.createMediaStreamSource(stream);
  workletNode = new AudioWorkletNode(audioCtx, 'rms-processor');

  sourceNode.connect(workletNode);
  // do NOT connect worklet to destination (no playback)

  workletNode.port.onmessage = (ev)=>{
    const {rms, t} = ev.data;
    const now = t || (performance.now());
    // convert to dBFS (20*log10(rms)), clamp
    let db = (rms>0) ? 20 * Math.log10(rms) : dBMin;
    if(!isFinite(db)) db = dBMin;
    // push sample
    samples.push({t: now, v: db});
    // keep only last (timeWindow) ms
    const timeWindow = Math.max(1000, Number(timeWindowInput.value)*1000);
    const cutoff = now - timeWindow;
    while(samples.length && samples[0].t < cutoff) samples.shift();
    // compute integration average if requested
    const integrationMs = Math.max(1, Number(integrationInput.value));
    const integCut = now - integrationMs;
    // average values with t >= integCut
    let sum=0, cnt=0;
    for(let i=samples.length-1;i>=0;i--){ if(samples[i].t < integCut) break; sum += Math.pow(10, samples[i].v/20); cnt++; }
    let avgDb = null;
    if(cnt>0){ const avgLin = sum/cnt; avgDb = 20*Math.log10(avgLin); }
    else avgDb = db;

    // show instantaneous averaged dB (UI)
    currentDbSpan.textContent = avgDb.toFixed(1);
  };

  running = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  // redraw loop
  requestAnimationFrame(drawLoop);
}

function stop(){
  if(!running) return;
  try{ if(workletNode) workletNode.disconnect(); }catch(e){}
  try{ if(sourceNode) sourceNode.disconnect(); }catch(e){}
  try{ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }catch(e){}
  try{ if(audioCtx){ audioCtx.close(); audioCtx=null; } }catch(e){}
  samples = [];
  running = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

startBtn.addEventListener('click', ()=>start());
stopBtn.addEventListener('click', ()=>stop());

// initial device list: note: to get labels, user must grant permission first
listDevices();

// draw function
function drawLoop(){
  // clear
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.fillStyle = 'rgba(2,8,20,0.7)'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
  // horizontal grid every 10 dB
  for(let db = -100; db<=0; db+=10){ const y = mapDbToY(db); ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.fillText(db+' dB', 4, y-2); }

  // draw time axis markers
  const timeWindow = Math.max(1000, Number(timeWindowInput.value)*1000);
  const now = performance.now();
  ctx.fillStyle = '#9fb0d0'; ctx.font = '11px sans-serif';
  for(let s=0;s<=Math.floor(timeWindow/1000);s+=Math.max(1,Math.ceil(timeWindow/5000))){ const t = now - (s*1000); const x = mapTimeToX(t, now, timeWindow); ctx.fillText('-'+s+'s', x+2, H-6); }

  // draw line
  if(samples.length>=1){
    ctx.beginPath();
    for(let i=0;i<samples.length;i++){
      const s = samples[i];
      const x = mapTimeToX(s.t, now, timeWindow);
      const y = mapDbToY(s.v);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(40,200,160,0.95)';
    ctx.stroke();
  }

  if(running) requestAnimationFrame(drawLoop);
}

function mapDbToY(db){
  const norm = (db - dBMin) / (dBMax - dBMin);
  return H - (norm * H);
}

function mapTimeToX(t, now, timeWindow){
  const frac = 1 - ((now - t) / timeWindow);
  return Math.max(0, Math.min(W, frac * W));
}

// If device labels are empty until permission is granted, call listDevices again after permission
navigator.mediaDevices && navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener('devicechange', ()=>{ listDevices(); });

</script>
</body>
</html>

