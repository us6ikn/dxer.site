<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7YST3WTEH3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7YST3WTEH3');
    </script>
    <link rel="stylesheet" href="/leaflet/leaflet.css" />
    <script src="/leaflet/leaflet.js"></script>
    <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>SA5IKN QRB Calculator - Azimuth and Terrain Elevation Finder</title>
  <meta name="description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.">
  <meta name="keywords" content="QRB calculator, azimuth finder, Maidenhead locator, grid square calculator, azimuth, ham radio, amateur radio, DX, terrain profile, elevation map, SA5IKN, line of sight, VHF, UHF, SHF, microwaves">
      <meta name="author" content="SA5IKN">
      <meta name="robots" content="index, follow">
          <link rel="canonical" href="https://dxer.site/sa5ikn-qrb-calculator/" />
          <!-- Favicon and App Icons -->
          <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
          <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
          <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
          <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
          <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
              <!-- Open Graph Meta (Facebook, LinkedIn, etc.) -->
                <meta property="og:title" content="SA5IKN QRB Calculator">
                <meta property="og:type" content="website">
                <meta property="og:description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.">
                <meta property="og:image" content="https://dxer.site/social/sa5ikn-qrb-calculator.jpg">
                <meta property="og:url" content="https://dxer.site/sa5ikn-qrb-calculator/">
                    
                    <!-- Twitter Meta -->
                      <meta name="twitter:card" content="summary_large_image">
                      <meta name="twitter:title" content="SA5IKN QRB Calculator" />
                      <meta name="twitter:description" content="SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph." />
                      <meta name="twitter:image" content="https://dxer.site/social/sa5ikn-qrb-calculator.jpg" />
              <script type="application/ld+json">
              {
                "@context": "https://schema.org",
                "@type": "WebApplication",
                "name": "SA5IKN QRB Calculator",
                "url": "https://dxer.site/sa5ikn-qrb-calculator/",
                "author": {
                  "@type": "Person",
                  "name": "SA5IKN"
                },
                "description": "SA5IKN QRB Calculator helps radio amateurs calculate azimuth, distance, and line-of-sight terrain profile between Maidenhead grid locators. Interactive map with draggable markers and elevation graph.",
                "applicationCategory": "Science",
                "operatingSystem": "All",
                "browserRequirements": "Requires JavaScript",
                "inLanguage": "en",
                "applicationSubCategory": "Amateur Radio Application",
                "offers": {
                  "@type": "Offer",
                  "price": "0.00",
                  "priceCurrency": "USD"
                }

              }
            </script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    .widget-container {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1;
      display: flex;
      justify-content: center;
    }

    .widget {
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      width: 100%;
      max-width: 600px;
    }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }

    .input-row input[type="text"] {
      flex: 1;
      min-width: 60px;
      max-width: 160px;
      padding: 0.4em;
    }

    .input-row button {
      padding: 0.4em 1em;
      font-weight: bold;
    }

    #locator1 {
      border: 2px solid #1e88e5;
      background-color: #e3f2fd;
    }

    #locator2 {
      border: 2px solid #43a047;
      background-color: #e8f5e9;
    }

    #azimuthResult, #obstructionWarning {
      margin-top: 0.5rem;
      font-weight: bold;
    }

      #obstructionWarning {
        color: #333; /* dark neutral gray */
        font-size: 0.7em; /* smaller font */
      }

      #elevation_chart {
        height: 0;
        transition: height 0.3s ease;
        overflow: hidden;
      }
  </style>
</head>
<body>
<div id="map"></div>
<div class="widget-container">
  <div class="widget">
      <div class="input-row">
        <a href="https://dxer.site" title="Back to Home" style="text-decoration: none; font-size: 1.4em; padding: 0.3em 0.5em;">üè†</a>
        <input type="text" id="locator1" maxlength="10" placeholder="e.g. JN58td12AB" />
        <input type="text" id="locator2" maxlength="10" placeholder="e.g. IO91wm34CD" />
        <button onclick="calculateAzimuth()">Calculate</button>
      </div>

    <div id="initialInstructions" style="margin-top: 1em; color: #444; font-size: 0.95em; line-height: 1.5;">
        <h3 style="margin-top: 0; font-size: 1.2em;">How to use SA5IKN QRB Calculator</h3>
        <p>Enter two Maidenhead locators in the fields above. Valid locator lengths are from <strong>4 to 10 characters</strong>.</p>

        <ul style="padding-left: 1.2em; margin-top: 0.5em;">
          <li><span style="color:#1e88e5; font-weight:bold;">Blue marker</span>: Your QTH locator</li>
          <li><span style="color:#43a047; font-weight:bold;">Green marker</span>: DX station locator</li>
        </ul>

        <p>Once both locators are entered, the map will show the azimuth, distance, and a line connecting the two markers. A terrain elevation profile between the points will appear below.</p>

        <p>You can also <strong>drag either marker</strong> directly on the map. The corresponding locator input will update dynamically.</p>
    </div>
    <div id="azimuthResult"></div>
    <div id="obstructionWarning"></div>
    <div id="elevation_chart"></div>
  </div>
</div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

<script>
  function setMapHeight() {
    const vh = window.innerHeight;
    document.getElementById('map').style.height = vh + 'px';
  }
  window.addEventListener('load', setMapHeight);
  window.addEventListener('resize', setMapHeight);
</script>

<script>
  let markers = [];
  let line;
  let elevator;

  google.charts.load('current', { packages: ['corechart'] });

  function locatorToLatLng(locator) {
    locator = locator.toUpperCase();
    const A = 'A'.charCodeAt(0);

    let lon = -180;
    let lat = -90;

    if (locator.length >= 2) {
      lon += (locator.charCodeAt(0) - A) * 20;
      lat += (locator.charCodeAt(1) - A) * 10;
    }
    if (locator.length >= 4) {
      lon += parseInt(locator[2]) * 2;
      lat += parseInt(locator[3]) * 1;
    }
    if (locator.length >= 6) {
      lon += (locator.charCodeAt(4) - A) * 5 / 60;
      lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
    }
    if (locator.length >= 8) {
      lon += parseInt(locator[6]) * (5 / 600);
      lat += parseInt(locator[7]) * (2.5 / 600);
    }
    if (locator.length >= 10) {
      lon += (locator.charCodeAt(8) - A) * (5 / 14400);
      lat += (locator.charCodeAt(9) - A) * (2.5 / 14400);
    }

    // ‚úÖ Add center offset based on precision level
    const precision = locator.length;
    if (precision === 2) {
      lon += 10; lat += 5;
    } else if (precision === 4) {
      lon += 1; lat += 0.5;
    } else if (precision === 6) {
      lon += 2.5 / 60; lat += 1.25 / 60;
    } else if (precision === 8) {
      lon += 5 / 1200; lat += 2.5 / 1200; // midpoint of 5"/600
    } else if (precision === 10) {
      lon += 5 / 28800; lat += 2.5 / 28800; // midpoint of 5"/14400
    }

    return { lat, lng: lon };
  }

    function latLngToLocator(lat, lon, precision = 6) {
      const A = 'A'.charCodeAt(0);
      lat += 90;
      lon += 180;

      let locator = '';

      locator += String.fromCharCode(Math.floor(lon / 20) + A);
      locator += String.fromCharCode(Math.floor(lat / 10) + A);

      lon = (lon % 20);
      lat = (lat % 10);
      locator += Math.floor(lon / 2);
      locator += Math.floor(lat / 1);

      if (precision >= 6) {
        lon = (lon % 2);
        lat = (lat % 1);
        locator += String.fromCharCode(Math.floor(lon * 60 / 5) + A);
        locator += String.fromCharCode(Math.floor(lat * 60 / 2.5) + A);
      }

      if (precision >= 8) {
        lon = (lon * 60 % 5);
        lat = (lat * 60 % 2.5);
        locator += Math.floor(lon / (5 / 10));
        locator += Math.floor(lat / (2.5 / 10));
      }

      if (precision >= 10) {
        lon = (lon % (5 / 10));
        lat = (lat % (2.5 / 10));
        locator += String.fromCharCode(Math.floor(lon / (5 / 240)) + A);
        locator += String.fromCharCode(Math.floor(lat / (2.5 / 240)) + A);
      }

      return locator.slice(0, precision);
    }

  function toDegrees(rad) {
    return rad * 180 / Math.PI;
  }

    let map, markers = [], line;

    function initMap() {
      map = L.map('map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Sample static load if needed
      // updateMap({ lat: 59.3293, lng: 18.0686 }, { lat: 52.2297, lng: 21.0122 });
    }

    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    function computeDistance(pos1, pos2) {
      const R = 6371;
      const dLat = toRadians(pos2.lat - pos1.lat);
      const dLng = toRadians(pos2.lng - pos1.lng);
      const a = Math.sin(dLat/2) ** 2 + Math.cos(toRadians(pos1.lat)) * Math.cos(toRadians(pos2.lat)) * Math.sin(dLng/2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function computeAzimuth(pos1, pos2) {
      const lat1 = toRadians(pos1.lat);
      const lat2 = toRadians(pos2.lat);
      const dLng = toRadians(pos2.lng - pos1.lng);
      const y = Math.sin(dLng) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
      let brng = Math.atan2(y, x);
      brng = (brng * 180 / Math.PI + 360) % 360;
      return brng;
    }

    function addDraggableMarker(latlng, color, index) {
      const marker = L.marker(latlng, {
        draggable: true,
        icon: L.divIcon({
          className: 'custom-marker',
          html: `<div style="width:14px;height:14px;background:${color};border-radius:50%;border:1px solid white;"></div>`
        })
      }).addTo(map);

      marker.on('dragend', () => {
        updateFromMarkers();
      });

      markers[index] = marker;
    }

    function updateMap(pos1, pos2) {
      markers.forEach(m => map.removeLayer(m));
      markers = [];
      if (line) map.removeLayer(line);

      addDraggableMarker(pos1, '#1e88e5', 0);
      addDraggableMarker(pos2, '#43a047', 1);

      line = L.polyline([pos1, pos2], { color: 'red' }).addTo(map);
      map.fitBounds(L.latLngBounds([pos1, pos2]));

      const distance = computeDistance(pos1, pos2).toFixed(1);
      const azimuth = computeAzimuth(pos1, pos2).toFixed(1);

      document.getElementById('distance').textContent = `${distance} km`;
      document.getElementById('azimuth').textContent = `${azimuth}¬∞`;

      getElevationProfile(pos1, pos2);
    }

    function updateFromMarkers() {
      const pos1 = markers[0].getLatLng();
      const pos2 = markers[1].getLatLng();
      updateMap(pos1, pos2);
    }

    function getElevationProfile(start, end) {
      const samples = 256;
      const latlngs = [];

      for (let i = 0; i <= samples; i++) {
        const lat = start.lat + (end.lat - start.lat) * (i / samples);
        const lng = start.lng + (end.lng - start.lng) * (i / samples);
        latlngs.push({ latitude: lat, longitude: lng });
      }

      fetch('https://api.open-elevation.com/api/v1/lookup', {
        method: 'POST',
        body: JSON.stringify({ locations: latlngs }),
        headers: { 'Content-Type': 'application/json' }
      })
      .then(response => response.json())
      .then(data => plotElevation(data.results))
      .catch(() => {
        document.getElementById('elevation_chart').innerText = 'Elevation service failed.';
      });
    }

    function plotElevation(results) {
      const data = new google.visualization.DataTable();
      data.addColumn('number', 'Distance');
      data.addColumn('number', 'Elevation');

      const step = computeDistance(results[0], results[results.length - 1]) / results.length;
      results.forEach((r, i) => {
        data.addRow([i * step, r.elevation]);
      });

      const options = {
        height: 200,
        legend: 'none',
        titleY: 'Elevation (m)',
        vAxis: {
          minValue: 0,
          format: 'short',
          textStyle: { fontSize: 10 }
        },
        hAxis: {
          title: 'Distance (km)',
          textStyle: { fontSize: 10 }
        },
        chartArea: { left: 40, right: 10, top: 20, bottom: 40 },
        colors: ['#1e88e5']
      };

      const chart = new google.visualization.AreaChart(document.getElementById('elevation_chart'));
      chart.draw(data, options);
    }

    window.onload = initMap;

</script>

<!-- Ko-Fi -->
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script src="/kofi.js"></script>
</body>
</html>
