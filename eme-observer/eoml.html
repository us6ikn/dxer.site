<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
            <title id="pageTitle">EME Observer - EME Station Map & EME QSO Planner</title>
                <meta name="description" id="metaDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner for all EME bands, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked." />
                <meta name="keywords" content="EME, Moonbounce, Ham Radio, Amateur Radio, DX Map, Moon Tracking, Doppler Spread, Polarization Offset, Sublunar Point, Moon Azimuth, Moon Declination, Signal Loss, Libration, Moon Footprint, Moon Elevation" />
                <meta name="author" content="SA5IKN">
                    <meta name="robots" content="index, follow">
                        <meta property="og:title" id="ogTitle" content="EME Observer - EME Station Map & EME QSO Planner">
                            <meta property="og:type" content="website">
                                <meta property="og:description" id="ogDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner for all EME bands, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked.">
                                    <meta property="og:image" content="https://dxer.site/social/eme-observer.jpg">
                                        <meta property="og:url" content="https://dxer.site/eme-observer/">
                                            <meta name="twitter:card" content="summary_large_image">
                                                <meta name="twitter:title" id="twitterTitle" content="EME Observer - EME Station Map & EME QSO Planner" />
                                                <meta name="twitter:description" id="twitterDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked." />
                                                <meta name="twitter:image" content="https://dxer.site/social/eme-observer.jpg" />
                                                <link rel="canonical" href="https://dxer.site/eme-observer/" />
                                                <!-- Favicon and App Icons -->
                                                <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
                                                    <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
                                                        <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
                                                            <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
                                                                <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
                                                                    <script type="application/ld+json">
                                                                        {
                                                                            "@context": "https://schema.org",
                                                                            "@type": "WebApplication",
                                                                            "name": "EME Observer",
                                                                            "url": "https://dxer.site/eme-observer/",
                                                                            "author": {
                                                                                "@type": "Person",
                                                                                "name": "SA5IKN"
                                                                            },
                                                                            "description": "EEME Observer is an Earth-Moon-Earth station map and QSO planner for all EME bands, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked.",
                                                                            "applicationCategory": "Science",
                                                                            "operatingSystem": "All",
                                                                            "browserRequirements": "Requires JavaScript",
                                                                            "inLanguage": "en",
                                                                            "applicationSubCategory": "Amateur Radio Application",
                                                                            "offers": {
                                                                                "@type": "Offer",
                                                                                "price": "0.00",
                                                                                "priceCurrency": "USD"
                                                                            }
                                                                        }
                                                                    </script>
                                                                    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
                                                                         integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
                                                                         crossorigin=""/>
                                                                        <!-- Move leaflet.js before dependent scripts -->
                                                                        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
                                                                             integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
                                                                             crossorigin=""></script>
                                                                        <script src="https://unpkg.com/leaflet.vectorgrid@latest/dist/Leaflet.VectorGrid.js"></script>
                                                                        <script src="https://cdn.jsdelivr.net/npm/text-image/dist/text-image.js"></script>
                                                                        <script src="https://ha8tks.github.io/Leaflet.CQzones/src/L.CQzones.js"></script>
                                                                        <script src="https://ha8tks.github.io/Leaflet.Maidenhead/src/L.Maidenhead.js"></script>
                                                                        <script src="a.ob.js"></script>
                                                                        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
                                                                    <style>
                                                                        html, body {
                                                                            margin: 0;
                                                                            padding: 0;
                                                                            height: 100%;
                                                                            overflow: hidden;
                                                                            font-family: 'Inter', Arial, sans-serif;
                                                                        }

                                                                    #chartWrapper, #dxChartWrapper, #relativeChartWrapper, #moonChartWrapper {
                                                                        width: 100%;
                                                                        max-width: 600px;
                                                                        height: 180px;
                                                                        margin-top: 6px;
                                                                        background-color: rgba(255, 255, 255, 0.85);
                                                                        border-radius: 6px;
                                                                        box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
                                                                        overflow: hidden;
                                                                        position: relative;
                                                                        box-sizing: border-box;
                                                                        display: none;
                                                                    }

                                                                    #moonChartWrapper {
                                                                        display: block;
                                                                    }

                                                                    #moonDistanceChart {
                                                                        height: calc(100% - 40px);
                                                                        padding-bottom: 20px;
                                                                    }

                                                                    /* Annual Button for Moon Chart */
                                                                    .annual-button {
                                                                        position: absolute;
                                                                        top: 145px;
                                                                        right: 2px;
                                                                        background-color: #0078d4;
                                                                        color: white;
                                                                        border: none;
                                                                        border-radius: 4px;
                                                                        padding: 4px 8px;
                                                                        font-size: 12px;
                                                                        font-weight: 600;
                                                                        cursor: pointer;
                                                                        transition: background 0.2s ease;
                                                                        text-decoration: none;
                                                                        display: inline-flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                        min-height: 24px;
                                                                        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                                                                        z-index: 10;
                                                                    }

                                                                    .annual-button:hover {
                                                                        background-color: #005fa3;
                                                                        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
                                                                    }
                                                                        
                                                                        .dome-button {
                                                                            right: 60px;
                                                                            position: absolute;
                                                                            top: 145px;
                                                                            z-index: 10;

                                                                            /* match Annual button's internal height */
                                                                            height: 24px;
                                                                            padding: 4px 8px;

                                                                            display: inline-flex;
                                                                            align-items: center;
                                                                            justify-content: center;

                                                                            /* inherits all Annual button styles (background, radius, shadow) */
                                                                        }

                                                                        .dome-button svg {
                                                                            height: 20px;   /* fits perfectly inside the 24px button */
                                                                            width: auto;
                                                                            display: block;
                                                                        }



                                                                    /* Reverted to original chart label styles */
                                                                    #chartLabel, #dxchartLabel, #relativeChartLabel, #moonChartLabel {
                                                                        text-align: center;
                                                                        margin-bottom: 0px;
                                                                        font-weight: normal;
                                                                        font-size: 11px;
                                                                        font-family: 'Arial, sans-serif';
                                                                        white-space: nowrap;
                                                                        overflow: hidden;
                                                                        text-overflow: ellipsis;
                                                                        max-width: 100%;
                                                                        padding: 2px 0;
                                                                    }

                                                                    #map {
                                                                        height: 100dvh;
                                                                        width: 100%;
                                                                        z-index: 0;
                                                                    }

                                                                    /* Core Panel Styling - Professional Floating Design */
                                                                    #controls {
                                                                        position: absolute;
                                                                        top: 15px;
                                                                        left: 20px;
                                                                        z-index: 5;
                                                                        background-color: rgba(255, 255, 255, 0.9);
                                                                        padding: 14px 18px;
                                                                        border-radius: 10px;
                                                                        box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.35);
                                                                        max-width: 95vw;
                                                                        max-height: 90vh;
                                                                        display: flex;
                                                                        flex-direction: column;
                                                                        box-sizing: border-box;
                                                                        transition: transform 0.3s ease;
                                                                        min-width: 280px; /* Ensures readability */
                                                                    }

                                                                    #fixed-controls {
                                                                        position: sticky;
                                                                        top: 0;
                                                                        z-index: 10;
                                                                        background-color: inherit;
                                                                        padding-bottom: 12px;
                                                                        display: flex;
                                                                        flex-direction: column;
                                                                        gap: 6px; /* Reduced for less vertical space */
                                                                        border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Subtle section divider */
                                                                    }

                                                                    #scrollable-controls {
                                                                        flex: 1;
                                                                        overflow-y: auto;
                                                                        max-height: calc(90vh - 180px); /* Adjusted for header + inline elements */
                                                                        padding-right: 5px;
                                                                    }

                                                                    #scrollable-controls::-webkit-scrollbar {
                                                                        width: 6px;
                                                                    }

                                                                    #scrollable-controls::-webkit-scrollbar-thumb {
                                                                        background-color: rgba(0, 120, 212, 0.5);
                                                                        border-radius: 3px;
                                                                    }

                                                                    #scrollable-controls::-webkit-scrollbar-track {
                                                                        background: transparent;
                                                                    }

                                                                    /* Header - Mimic Example's Title Block */
                                                                    .app-name-wrapper {
                                                                        display: flex;
                                                                        flex-direction: column;
                                                                        align-items: flex-start; /* Align left for better flow */
                                                                        position: relative;
                                                                        margin-bottom: 0px; /* Reduced */
                                                                        padding-bottom: 0px; /* Reduced */
                                                                        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
                                                                        width: fit-content;
                                                                    }

                                                                    .creator-label {
                                                                        font-size: 11px;
                                                                        color: #666;
                                                                        font-weight: 500;
                                                                        margin-bottom: 2px;
                                                                        text-align: right;
                                                                        width: 100%;
                                                                    }

                                                                    .app-name {
                                                                        font-size: 16px;
                                                                        font-weight: 700;
                                                                        color: #2c3e50;
                                                                        letter-spacing: 0.5px;
                                                                    }

                                                                    /* Date/Time Controls */
                                                                    #date-container {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: space-between;
                                                                        flex-wrap: wrap;
                                                                        gap: 8px;
                                                                        margin-top: 4px;
                                                                    }

                                                                    input[type="date"] {
                                                                        width: auto;
                                                                        max-width: 160px;
                                                                        padding: 5px 6px;
                                                                        font-size: 13px;
                                                                        border: 1px solid #ccc;
                                                                        border-radius: 5px;
                                                                        background: white;
                                                                    }

                                                                    #prevDay, #nextDay {
                                                                        background-color: #0078d4;
                                                                        color: white;
                                                                        border: none;
                                                                        border-radius: 5px;
                                                                        padding: 4px 8px; /* Reduced vertical padding */
                                                                        cursor: pointer;
                                                                        font-size: 12px;
                                                                        font-weight: 600;
                                                                        transition: background 0.2s ease;
                                                                        min-width: 24px;
                                                                        min-height: 24px; /* Reduced min-height */
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                    }

                                                                    #prevDay:hover, #nextDay:hover {
                                                                        background-color: #005fa3;
                                                                    }

                                                                    #hour-value {
                                                                        font-size: 13px;
                                                                        font-weight: 500;
                                                                        color: #333;
                                                                        white-space: nowrap;
                                                                        width: 70px; /* Fixed width to prevent movement */
                                                                    }

                                                                    /* Time Slider */
                                                                    #hour {
                                                                        width: 100%;
                                                                        margin-top: 5px;
                                                                        -webkit-appearance: none;
                                                                        appearance: none;
                                                                        height: 6px; /* Thinner for modern look */
                                                                        background: #e9ecef;
                                                                        border-radius: 3px;
                                                                        outline: none;
                                                                        transition: background 0.3s ease;
                                                                    }

                                                                    #hour::-webkit-slider-thumb {
                                                                        -webkit-appearance: none;
                                                                        appearance: none;
                                                                        width: 16px;
                                                                        height: 16px;
                                                                        background: #0078d4;
                                                                        border-radius: 50%;
                                                                        cursor: pointer;
                                                                        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                                                                    }

                                                                    #hour::-moz-range-thumb {
                                                                        width: 16px;
                                                                        height: 16px;
                                                                        background: #0078d4;
                                                                        border-radius: 50%;
                                                                        cursor: pointer;
                                                                        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                                                                    }

                                                                    #hour:hover {
                                                                        background: #dee2e6;
                                                                    }

                                                                    /* Locator Inputs */
                                                                    .locator-group {
                                                                        display: flex;
                                                                        gap: 12px;
                                                                        flex-wrap: wrap;
                                                                        align-items: center;
                                                                    }

                                                                    .locator-input {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        gap: 6px;
                                                                        flex: 1;
                                                                        min-width: 80px;
                                                                    }

                                                                    .locator-input label {
                                                                        font-size: 12 px;
                                                                        font-weight: 600;
                                                                        color: #333;
                                                                        white-space: nowrap;
                                                                        line-height: 1;
                                                                    }

                                                                    .locator-input input {
                                                                        flex: 1;
                                                                        font-size: 12px;
                                                                        padding: 4px 5px;
                                                                        border: 1px solid #ccc;
                                                                        border-radius: 5px;
                                                                        background: white;
                                                                        max-width: 80px; /* Reduced */
                                                                    }

                                                                    /* Buttons - Unified Professional Style */
                                                                    .button-group, .button-group-infowindow {
                                                                        display: flex;
                                                                        gap: 6px;
                                                                        margin-top: 8px;
                                                                        flex-wrap: wrap;
                                                                        justify-content: center;
                                                                    }
                                                                    
                                                                    /* Ensure popup content is wide enough for images */
                                                                    .leaflet-popup-content {
                                                                        min-width: 275px !important; /* Slightly less than 300px to account for padding */
                                                                        max-width: 300px !important; /* Reinforce Leaflet's default max-width */
                                                                        box-sizing: border-box; /* Ensure padding is included in width calculations */
                                                                    }

                                                                    /* Style the image container to prevent overflow */
                                                                    #image-container {
                                                                        width: 100%; /* Ensure container spans full popup width */
                                                                        overflow: hidden; /* Prevent image from overflowing container */
                                                                        margin-top: 5px; /* Spacing above container */
                                                                    }

                                                                    /* Constrain images within the container */
                                                                    #image-container img {
                                                                        max-width: 100%; /* Fit within container */
                                                                        height: auto; /* Maintain aspect ratio */
                                                                        display: block; /* Prevent inline spacing issues */
                                                                        margin: 0 auto; /* Center the image */
                                                                    }

                                                                    .nav-button, .sked-button, .email-button, .qrz-button, .auto-track-button {
                                                                        background-color: #0078d4;
                                                                        color: white !important;
                                                                        border: none;
                                                                        border-radius: 6px;
                                                                        padding: 4px 8px; /* Reduced vertical padding for less height */
                                                                        cursor: pointer;
                                                                        font-size: 12px;
                                                                        font-weight: 600;
                                                                        transition: background 0.2s ease, box-shadow 0.2s ease;
                                                                        text-decoration: none;
                                                                        display: inline-flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                        min-height: 24px; /* Reduced from 32px for compact feel */
                                                                        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                                                                    }
                                                                    
                                                                    .auto-track-button {
                                                                        min-height: 32px;
                                                                        max-width: 50px; /* Reduced from 32px for compact feel */
                                                                    }

                                                                    .nav-button:hover, .sked-button:hover, .email-button:hover, .qrz-button:hover, .auto-track-button:hover {
                                                                        background-color: #005fa3;
                                                                        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
                                                                    }

                                                                    .nav-button:focus, .sked-button:focus, .email-button:focus, .qrz-button:focus, .auto-track-button:focus {
                                                                        outline: none;
                                                                        box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
                                                                    }

                                                                    /* Specific Button Overrides */
                                                                    .sked-button {
                                                                        background-color: #28a745;
                                                                    }

                                                                    .sked-button:hover {
                                                                        background-color: #218838;
                                                                    }

                                                                    .email-button {
                                                                        background-color: #17a2b8;
                                                                    }

                                                                    .email-button:hover {
                                                                        background-color: #138496;
                                                                    }

                                                                    .qrz-button {
                                                                        background-color: #fd7e14;
                                                                    }

                                                                    .qrz-button:hover {
                                                                        background-color: #e86c12;
                                                                    }

                                                                    .auto-track-button {
                                                                        background-color: #0078d4;
                                                                        padding: 4px 8px; /* Consistent reduced padding */
                                                                        font-size: 11px;
                                                                    }

                                                                    .auto-track-button.active {
                                                                        background-color: #0078d4;
                                                                        font-weight: 700;
                                                                    }

                                                                    .nav-button.icon-button {
                                                                        padding: 2px; /* Reduced for icons */
                                                                        width: auto;
                                                                        min-width: 24px; /* Reduced */
                                                                        height: 24px; /* Reduced */
                                                                        font-size: 12px; /* Reduced for icons */
                                                                    }

                                                                    .nav-button.icon-button svg {
                                                                        width: 14px; /* Reduced */
                                                                        height: 14px;
                                                                        fill: currentColor;
                                                                    }

                                                                    .icon-button.active {
                                                                        background-color: #005fa3;
                                                                    }

                                                                    /* Band Select */
                                                                    .band-select {
                                                                        font-size: 13px;
                                                                        font-weight: 600;
                                                                        color: #333;
                                                                        padding: 5px 8px;
                                                                        border: 1px solid #ccc;
                                                                        border-radius: 5px;
                                                                        background-color: white;
                                                                        cursor: pointer;
                                                                    }

                                                                    .band-select:focus {
                                                                        outline: none;
                                                                        border-color: #0078d4;
                                                                        box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
                                                                    }

                                                                    .button-band-group {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        gap: 8px;
                                                                        margin-top: 0px; /* Reduced */
                                                                    }

                                                                    /* Labels and Metrics - Preserve Original Colors, Refine Typography */
                                                                    label {
                                                                        font-weight: 600;
                                                                        font-size: 13px;
                                                                        color: #333;
                                                                        margin-bottom: 6px;
                                                                        display: block;
                                                                    }

                                                                    .metric-label {
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-distance {
                                                                        color: #24a148;
                                                                    }

                                                                    .metric-declination {
                                                                        color: #ff832b;
                                                                    }

                                                                    .metric-pathloss {
                                                                        color: #24a148;
                                                                    }

                                                                    .metric-separator {
                                                                        color: #666;
                                                                        margin: 0 4px;
                                                                    }

                                                                    .metric-elevation {
                                                                        color: rgba(0, 0, 255, 0.6);
                                                                    }

                                                                    .metric-azimuth {
                                                                        color: #444;
                                                                    }

                                                                    .metric-libration {
                                                                        color: #ff0000;
                                                                    }

                                                                    .metric-doppler {
                                                                        color: green;
                                                                    }

                                                                    .metric-locator {
                                                                        color: #000;
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-rel-libration {
                                                                        color: red;
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-rel-doppler {
                                                                        color: green;
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-poloffset {
                                                                        color: blue;
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-sun-sep {
                                                                        color: #ff832b; /* Yellow for Sun separation */
                                                                        font-weight: bold;
                                                                    }

                                                                    .metric-sgra-sep {
                                                                        color: #800080; /* Purple for Sgr A separation */
                                                                        font-weight: bold;
                                                                    }

                                                                    /* Popup and Other Existing Rules (Unchanged for Functionality) */
                                                                    #image-container, .leaflet-popup-content {
                                                                        /* Your existing rules here - unchanged */
                                                                    }

                                                                    .leaflet-control-layers {
                                                                        /* Your existing rules here - unchanged */
                                                                    }

                                                                    /* Folded Panel and Show Button */
                                                                    #controls.folded {
                                                                        transform: translateX(calc(-100% + 30px));
                                                                        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
                                                                    }

                                                                    #showControlsPanel {
                                                                        position: fixed;
                                                                        top: 50%;
                                                                        left: 20px;
                                                                        transform: translateY(-50%);
                                                                        width: 24px;
                                                                        height: 24px;
                                                                        padding: 0;
                                                                        background-color: #0078d4;
                                                                        color: white;
                                                                        border: none;
                                                                        border-radius: 6px;
                                                                        font-size: 14px;
                                                                        font-weight: 600;
                                                                        cursor: pointer;
                                                                        transition: background 0.2s ease, transform 0.2s ease;
                                                                        display: none;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                        z-index: 1000;
                                                                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                                                    }

                                                                    #showControlsPanel.visible {
                                                                        display: flex;
                                                                    }

                                                                    #showControlsPanel:hover {
                                                                        background-color: #005fa3;
                                                                        transform: translateY(-50%) scale(1.05);
                                                                    }

                                                                    /* Disabled States */
                                                                    #hour:disabled, #date:disabled, #prevDay:disabled, #nextDay:disabled {
                                                                        background: #e9ecef;
                                                                        color: #6c757d;
                                                                        cursor: not-allowed;
                                                                        opacity: 0.6;
                                                                    }

                                                                    /* --- CLEAN INLINE HEADER LAYOUT --- */
                                                                    .app-header-row {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: space-between;
                                                                        flex-wrap: wrap;
                                                                        gap: 4px;
                                                                        padding-bottom: 0px; /* Reduced */
                                                                        margin-bottom: 0px; /* Reduced */
                                                                    }

                                                                    .app-name-wrapper {
                                                                        display: flex;
                                                                        flex-direction: column;
                                                                        align-items: flex-start;
                                                                        line-height: 1.1;
                                                                    }

                                                                    /* --- INLINE DATE/TIME --- */
                                                                    #date-container-inline {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        gap: 6px;
                                                                    }

                                                                    #date-container-inline input[type="date"] {
                                                                        width: auto;
                                                                        padding: 4px 6px;
                                                                        font-size: 13px;
                                                                        border: 1px solid #ccc;
                                                                        border-radius: 5px;
                                                                        height: 28px;
                                                                        min-height: 28px;
                                                                        box-sizing: border-box;
                                                                    }

                                                                    #date-container-inline .icon-only {
                                                                        background-color: #0078d4;
                                                                        color: white;
                                                                        border: none;
                                                                        border-radius: 5px;
                                                                        padding: 4px;
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                        width: 24px;
                                                                        cursor: pointer;
                                                                        transition: background 0.2s ease;
                                                                    }

                                                                    #date-container-inline .icon-only:hover {
                                                                        background-color: #005fa3;
                                                                    }

                                                                    /* --- UNIFIED BUTTON ROW --- */
                                                                    .combined-nav {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        flex-wrap: wrap;
                                                                        gap: 6px;
                                                                        justify-content: flex-start;
                                                                        margin-top: 0px; /* Reduced */
                                                                    }
                                                                    
                                                                    /* --- UNIFIED BUTTON AND SELECT HEIGHTS --- */
                                                                    .control-button,
                                                                    .icon-button,
                                                                    .control-select,
                                                                    #date-container-inline .icon-only {
                                                                        height: 28px;
                                                                        min-height: 28px;
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                        border-radius: 5px;
                                                                        border: none;
                                                                        background-color: #0078d4;
                                                                        color: white;
                                                                        cursor: pointer;
                                                                        transition: background 0.2s ease;
                                                                        padding: 0 6px;
                                                                        box-sizing: border-box;
                                                                    }

                                                                    .control-button:hover,
                                                                    .icon-button:hover,
                                                                    #date-container-inline .icon-only:hover {
                                                                        background-color: #005fa3;
                                                                    }

                                                                    .icon-button svg {
                                                                        width: 16px;
                                                                        height: 16px;
                                                                    }

                                                                    .control-select {
                                                                        font-size: 13px;
                                                                        color: #333;
                                                                        background-color: #fff;
                                                                        border: 1px solid #ccc;
                                                                        cursor: pointer;
                                                                        padding: 0 4px;
                                                                    }

                                                                    /* --- ROW ALIGNMENT --- */
                                                                    .combined-nav {
                                                                        display: flex;
                                                                        align-items: center;
                                                                        flex-wrap: wrap;
                                                                        gap: 4px;
                                                                        justify-content: flex-start;
                                                                        margin-top: 0px; /* Reduced */
                                                                    }

                                                                    .control-button {
                                                                        min-width: 60px; /* Fixed width to prevent layout shift on text change */
                                                                    }

                                                                    /* 1. DESKTOP  make buttons larger & give the panel breathing room */
                                                                    @media (min-width: 601px) {
                                                                        #controls { padding: 18px 22px; }     /* a little more inner space */

                                                                        /* ---- unified button size (nav, sked, email, qrz, track, ) ---- */
                                                                        .nav-button,
                                                                        .auto-track-button,
                                                                        .control-button,
                                                                        .icon-button,
                                                                        .control-select,
                                                                        #date-container-inline .icon-only,
                                                                        #prevDay,
                                                                        #nextDay {
                                                                            min-height: 32px !important;      /* taller, easier to tap */
                                                                            padding: 6px 12px !important;    /* more horizontal space */
                                                                            font-size: 13px !important;      /* readable text */
                                                                        }

                                                                        /* icon-only buttons keep a square shape but grow a bit */
                                                                        .icon-button,
                                                                        .icon-only,
                                                                        #date-container-inline .icon-only,
                                                                        #prevDay,
                                                                        #nextDay {
                                                                            min-width: 32px !important;
                                                                            width: 32px !important;
                                                                            height: 32px !important;
                                                                            padding: 0 !important;
                                                                        }
                                                                        .icon-button svg,
                                                                        .icon-only svg,
                                                                        #date-container-inline .icon-only svg {
                                                                            width: 18px;
                                                                            height: 18px;
                                                                        }

                                                                        /* band selector & date input */
                                                                        #bandSelect,
                                                                        input[type="date"] { height: 32px; font-size: 13px; }

                                                                        /* locator inputs */
                                                                        .locator-input input { max-width: 60px; padding: 6px 8px; }

                                                                        /* reduce the vertical gap between rows */
                                                                        .combined-nav { gap: 8px; }
                                                                        .button-band-group { gap: 10px; }
                                                                    }

                                                                    /* 2. MOBILE  shrink buttons *only* on very narrow screens */
                                                                    @media (max-width: 600px) {
                                                                        #controls { padding: 12px 14px; left: 10px; top: 10px; min-width: 260px; }

                                                                        .nav-button,
                                                                        .sked-button,
                                                                        .email-button,
                                                                        .qrz-button,
                                                                        .auto-track-button,
                                                                        .control-button,
                                                                        .icon-button,
                                                                        .control-select,
                                                                        #date-container-inline .icon-only,
                                                                        #prevDay,
                                                                        #nextDay {
                                                                            min-height: 24px !important;
                                                                            padding: 2px 4px !important;
                                                                            font-size: 10px !important;
                                                                        }
                                                                        
                                                                        .auto-track-button {
                                                                            height: 26px !important;
                                                                            padding: 2px 4px !important;
                                                                            font-size: 10px !important;
                                                                        }

                                                                        .icon-button,
                                                                        .icon-only,
                                                                        #date-container-inline .icon-only,
                                                                        #prevDay,
                                                                        #nextDay {
                                                                            min-width: 26px !important;
                                                                            width: 26px !important;
                                                                            height: 26px !important;
                                                                            padding: 0 !important;
                                                                        }
                                                                        .icon-button svg,
                                                                        .icon-only svg,
                                                                        #date-container-inline .icon-only svg {
                                                                            width: 14px;
                                                                            height: 14px;
                                                                        }

                                                                        #bandSelect,
                                                                        input[type="date"] { height: 20px; font-size: 11px; }

                                                                        .locator-input input { max-width: 60px; }

                                                                        .app-name { font-size: 14px; }
                                                                        .creator-label { font-size: 10px; }
                                                                        .combined-nav { gap: 4px; }
                                                                        #date-container-inline { gap: 4px; }
                                                                        #date-container-inline .icon-only { width: 24px; height: 24px; padding: 2px; }
                                                                        input[type="date"] { font-size: 12px; padding: 2px 4px; height: 24px; }
                                                                        #hour-value { font-size: 12px; }
                                                                        .app-header-row { flex-wrap: nowrap; gap: 2px; }
                                                                    }

                                                                    /* 3. Keep the folded panel behaviour untouched */
                                                                    #controls.folded { transform: translateX(calc(-100% + 34px)); }
                                                                    #showControlsPanel { width: 30px; height: 30px; font-size: 16px; }

                                                                    /* 4. ICON-ONLY BUTTONS (prev/next day, nav icons, panel toggle) */
                                                                    .icon-only,
                                                                    .combined-nav .icon-button,
                                                                    #toggleControlsPanel {
                                                                        /* same base size on every screen */
                                                                        width: 28px !important;   /* mobile default */
                                                                        height: 28px !important;
                                                                        padding: 0 !important;
                                                                        display: flex;
                                                                        align-items: center;
                                                                        justify-content: center;
                                                                    }

                                                                    /* 5. SVG SIZE  responsive but never tiny on larger screens */
                                                                    .icon-only svg,
                                                                    .combined-nav .icon-button svg,
                                                                    #toggleControlsPanel svg {
                                                                        width: 16px;   /* desktop / tablet */
                                                                        height: 16px;
                                                                        fill: currentColor;
                                                                    }

                                                                    /* 6. MOBILE  keep the original tiny icons (they already looked good) */
                                                                    @media (max-width: 600px) {
                                                                        .icon-only svg,
                                                                        .combined-nav .icon-button svg,
                                                                        #toggleControlsPanel svg {
                                                                            width: 14px;
                                                                            height: 14px;
                                                                        }
                                                                    }

                                                                    /* 7. DESKTOP  make the *buttons* a little bigger (optional) */
                                                                    @media (min-width: 601px) {
                                                                        .icon-only,
                                                                        .combined-nav .icon-button,
                                                                        #toggleControlsPanel {
                                                                            width: 32px !important;
                                                                            height: 32px !important;
                                                                        }
                                                                        .icon-only svg,
                                                                        .combined-nav .icon-button svg,
                                                                        #toggleControlsPanel svg {
                                                                            width: 18px;   /* slightly larger on big screens */
                                                                            height: 18px;
                                                                        }
                                                                    }
                                                                        /* 144 MHz notice  bottom-right corner */
                                                                        .vhf-notice {
                                                                            position: fixed;
                                                                            bottom: 40px;
                                                                            right: 40px;
                                                                            background-color: rgba(255, 255, 255, 0.95);
                                                                            color: #333;
                                                                            padding: 12px 44px 12px 16px;      /* extra right padding for  button */
                                                                            border-radius: 8px;
                                                                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
                                                                            font-size: 13px;
                                                                            font-weight: 500;
                                                                            max-width: 360px;
                                                                            line-height: 1.4;
                                                                            z-index: 1000;                      /* above map and controls */
                                                                            border-left: 4px solid #ff832b;     /* orange accent */
                                                                            
                                                                            opacity: 0;
                                                                            visibility: hidden;
                                                                            transition: opacity 0.4s ease, visibility 0.4s ease;
                                                                            
                                                                            pointer-events: none;               /* prevent blocking map by default */
                                                                            user-select: none;                  /* avoid accidental text selection */
                                                                        }

                                                                        /* When visible */
                                                                        .vhf-notice.visible {
                                                                            opacity: 1;
                                                                            visibility: visible;
                                                                        }

                                                                        /* Make link, text and close button interactive */
                                                                        .vhf-notice a,
                                                                        .vhf-notice p,
                                                                        .vhf-notice strong,
                                                                        .close-notice {
                                                                            pointer-events: auto;
                                                                        }

                                                                        /* Close button */
                                                                        .close-notice {
                                                                            position: absolute;
                                                                            top: 8px;
                                                                            right: 12px;
                                                                            background: none;
                                                                            border: none;
                                                                            font-size: 22px;
                                                                            font-weight: bold;
                                                                            color: #666;
                                                                            cursor: pointer;
                                                                            padding: 0 6px;
                                                                            line-height: 1;
                                                                            z-index: 2;
                                                                        }

                                                                        .close-notice:hover {
                                                                            color: #000;
                                                                        }

                                                                        .close-notice:active {
                                                                            transform: scale(0.95);
                                                                        }

                                                                        /* 
                                                                           Mobile adjustments
                                                                         */
                                                                        @media (max-width: 600px) {
                                                                            .vhf-notice {
                                                                                bottom: 16px;
                                                                                right: 12px;
                                                                                left: 12px;
                                                                                max-width: none;
                                                                                font-size: 12px;
                                                                                padding: 12px 44px 12px 14px;     /* still room for  */
                                                                                border-radius: 6px;
                                                                            }

                                                                            .close-notice {
                                                                                right: 10px;
                                                                                font-size: 20px;
                                                                            }
                                                                        }
                                                                </style>
                                                                
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div id="fixed-controls">
            <!-- Header + Inline Date/Time -->
            <div class="app-header-row">
                <div class="app-name-wrapper">
                    <div class="app-name">EME Observer</div>
                    <div class="creator-label">by SA5IKN</div>
                </div>
                <div id="date-container-inline">
                    <button id="prevDay" title="Previous Day" class="icon-only">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                        </svg>
                    </button>
                    <input type="date" id="date" />
                    <button id="nextDay" title="Next Day" class="icon-only">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/>
                        </svg>
                    </button>
                    <span id="hour-value">UTC: 00:00</span>
                </div>
            </div>

            <!-- Band + Track + Nav Buttons -->
            <div class="button-band-group combined-nav">
                <button id="realTimeButton" class="auto-track-button">Track</button>
                <select id="bandSelect" class="control-select">
                    <option value="144MHz">144MHz</option>
                    <option value="222MHz">222MHz</option>
                    <option value="432MHz">432MHz</option>
                    <option value="902MHz">902MHz</option>
                    <option value="1296MHz">1296MHz</option>
                    <option value="2320MHz">2320MHz</option>
                    <option value="3400MHz">3400MHz</option>
                    <option value="5760MHz">5760MHz</option>
                    <option value="10GHz" selected>10GHz</option>
                    <option value="24GHz">24GHz</option>
                    <option value="47GHz">47GHz</option>
                    <option value="76GHz">76GHz</option>
                </select>

                <!-- Nav Buttons Inline -->
                <button id="activeStationsButton" class="icon-button" title="Toggle All/Active Stations">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/>
                    </svg>
                </button>
                <a href="statistics.html" class="icon-button" title="Statistics">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M5 9h2v10H5zM11 4h2v15h-2zM17 12h2v7h-2z"/>
                    </svg>
                </a>
                <a href="table.html" class="icon-button" title="Table">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 3v18h18V3H3zm16 4H5V5h14v2zm0 4H5V9h14v2zm0 4H5v-2h14v2zm0 4H5v-2h14v2z"/>
                    </svg>
                </a>
                <a href="datasubmission.html" class="icon-button" title="Add Station">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                </a>
                <a href="/" class="icon-button" title="Home">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 3l9 9h-3v9h-12v-9h-3l9-9z"/>
                    </svg>
                </a>
                <a href="user-guide.html" class="icon-button" title="Help">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4zm-1 16h2v-2h-2v2z"/>
                    </svg>
                </a>
                <button id="toggleControlsPanel" class="icon-button" title="Toggle Controls">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                    </svg>
                </button>
            </div>

            <!-- Time Slider -->
            <input type="range" id="hour" min="0" max="287" value="0" step="1" />

            <!-- Locators -->
            <div class="locator-group">
                <div class="locator-input">
                    <label for="qth">My Locator:</label>
                    <input type="text" id="qth" maxlength="6" placeholder="eg JO89tt" />
                </div>
                <div class="locator-input">
                    <label for="dx">DX Locator:</label>
                    <input type="text" id="dx" maxlength="6" placeholder="eg IO91vm" />
                </div>
            </div>
        </div>

        <!-- Scrollable Controls (Charts unchanged) -->
        <div id="scrollable-controls">
            <div id="chartWrapper" style="display: none;">
                <div id="chartLabel"></div>
                <canvas id="declinationChart"></canvas>
            </div>
            <div id="dxChartWrapper" style="display: none;">
                <div id="dxchartLabel"></div>
                <canvas id="dxDeclinationChart"></canvas>
            </div>
            <div id="relativeChartWrapper" style="display: none;">
                <div id="relativeChartLabel"></div>
                <canvas id="relativeDataChart"></canvas>
            </div>
            <div id="moonChartWrapper" style="display: block;">
                <a href="https://dxer.site/eme-noise-mapper/"
                   class="annual-button dome-button"
                   target="_blank"
                   title="EME Noise Mapper">
                    
                    <!-- dome icon -->
                    <svg xmlns="http://www.w3.org/2000/svg"
                         width="18" height="18"
                         viewBox="0 0 24 24"
                         fill="none"
                         aria-hidden="true">
                      <path d="M2 15a10 10 0 0 1 20 0v3H2v-3z" fill="white"/>
                      <g stroke="rgba(0,0,0,0.25)" stroke-width="0.9" fill="none" stroke-linecap="round">
                        <path d="M3.5 15c2.2-3.2 6.4-4.8 9.5-4.8s7.3 1.6 9.5 4.8"/>
                        <path d="M4.7 17c2-1.7 5.1-2.6 7.8-2.6s5.8.9 7.8 2.6"/>
                        <path d="M12 8.5c2.2.0 4.0 1.8 4 1.8s-1.8 1.8-4 1.8-4-1.8-4-1.8 1.8-1.8 4-1.8z"
                              stroke="rgba(0,0,0,0.14)"/>
                      </g>
                    </svg>

                </a>

                <a href="https://eme.radio/moon-ephemeris"
                   class="annual-button"
                   target="_blank">
                   Annual
                </a>

                <div id="moonChartLabel"></div>
                <canvas id="moonDistanceChart"></canvas>
            </div>
        </div>
    </div>
    <button id="showControlsPanel" style="display: none;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
            <path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/>
        </svg>
    </button><script src="chart.js"></script>
<script src="chartjs-plugin-annotation@1.4.0"></script>
<script src="l.ob.js"></script>
<script src="/leaflet/Leaflet.greatCircle.js"></script>
<script>
        let chart;
        let dxChart;
        let relativeChart;
        let moonChart;
        let rawData = [];
        let dxRawData = [];
        let moonDataForMonth = [];
        let hourIndex = 0;
        let lat = 0;
        let lon = 0;
        let dxLat = 0;
        let dxLon = 0;
        let moonMarker;
        let footprintCircle;
        let currentInfoWindow = null;
        let map;
        let realTimeInterval = null; // Store the interval ID for real-time updates
        let isRealTimeMode = false; // Track real-time mode state
        let moonDayData = { date: null, data: [], labels: [] };
        let qthMarker = null;
        let dxMarker = null;

        // NEW: Caches for day data to avoid recompute
        let qthDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
        let dxDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
        let relDayData = { date: null, libration: [], dopplers: [], polOffsets: [] };

        const MOON_RADIUS = 1.7374e6;
        const SPEED_OF_LIGHT = 299792458;
        
        // Define band frequencies and display names
        const bandConfig = {
            '144MHz': { frequency: 0.144e9, display: '144 MHz', jsonFile: 'stn_144MHz.json' },
            '222MHz': { frequency: 0.222e9, display: '222 MHz', jsonFile: 'stn_222MHz.json' },
            '432MHz': { frequency: 0.432e9, display: '432 MHz', jsonFile: 'stn_432MHz.json' },
            '902MHz': { frequency: 0.902e9, display: '902 MHz', jsonFile: 'stn_902MHz.json' },
            '1296MHz': { frequency: 1.296e9, display: '1296 MHz', jsonFile: 'stn_1296MHz.json' },
            '2320MHz': { frequency: 2.320e9, display: '2320 MHz', jsonFile: 'stn_2320MHz.json' },
            '3400MHz': { frequency: 3.400e9, display: '3400 MHz', jsonFile: 'stn_3400MHz.json' },
            '5760MHz': { frequency: 5.760e9, display: '5760 MHz', jsonFile: 'stn_5760MHz.json' },
            '10GHz': { frequency: 10.368e9, display: '10 GHz', jsonFile: 'stn_10GHz.json' },
            '24GHz': { frequency: 24.000e9, display: '24 GHz', jsonFile: 'stn_24GHz.json' },
            '47GHz': { frequency: 47.000e9, display: '47 GHz', jsonFile: 'stn_47GHz.json' },
            '76GHz': { frequency: 76.000e9, display: '76 GHz', jsonFile: 'stn_76GHz.json' }
        };

        // Default to 10GHz
        let FREQUENCY_HZ = bandConfig['10GHz'].frequency;

        // Helper function to update hour-value display
        function updateHourDisplay() {
            const hour = Math.floor(hourIndex / 12);
            const minutes = (hourIndex % 12) * 5;
            document.getElementById('hour-value').textContent = `UTC: ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function updateBand(band) {
            // Stop real-time updates and disable real-time mode
            stopRealTimeUpdates();
            isRealTimeMode = false;
            console.log('updateBand: Real-time mode disabled, realTimeInterval cleared'); // Debug log

            // Update UI to reflect real-time mode is off
            const autoTrackButton = document.getElementById('realTimeButton');
            autoTrackButton.classList.remove('active');
            autoTrackButton.textContent = 'Track';
            document.getElementById('hour').disabled = false;
            document.getElementById('date').disabled = false;
            document.getElementById('prevDay').disabled = false;
            document.getElementById('nextDay').disabled = false;

            // Update hour-value to match slider position
            updateHourDisplay();

            // Update frequency
            FREQUENCY_HZ = bandConfig[band].frequency;

            // Invalidate caches
            qthDayData.date = null;
            dxDayData.date = null;
            relDayData.date = null;

            // Update JSON file and markers
            const jsonFile = bandConfig[band].jsonFile;
            const showActiveOnly = isActiveStationsOnly;
            markers.forEach(marker => marker.remove());
            markers = [];
            fetch(jsonFile)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    updateMarkers(data, showActiveOnly);
                    // Recompute data for current locators
                    const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                    const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                    const dateStr = document.getElementById("date").value;
                    if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                        computeLibrationForDay(qthInput, dateStr, 'qth');
                        computeFullDayData(qthDayData, qthInput, dateStr, true);
                    }
                    if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                        computeLibrationForDay(dxInput, dateStr, 'dx');
                        computeFullDayData(dxDayData, dxInput, dateStr, false);
                    }
                    // Update charts with new data, ensuring real-time mode is off
                    if (!isRealTimeMode) {
                        console.log(`updateBand: Updating chart with hourIndex=${hourIndex}, isRealTimeMode=${isRealTimeMode}`); // Debug log
                        updateChart(hourIndex, false);
                    } else {
                        console.warn('updateBand: Skipped chart update due to unexpected real-time mode'); // Debug log
                    }
                })
                .catch(error => {
                    console.error(`Error fetching ${jsonFile}:`, error);
                });
        }

        function computeLibrationForDay(locator, dateStr, type) {
            if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                console.warn(`Invalid locator: ${locator}`);
                return [];
            }

            let lat, lon;
            try {
                ({ lat, lon } = qthToLatLon(locator));
            } catch (e) {
                console.error(`Error converting locator ${locator} to lat/lon: ${e.message}`);
                return [];
            }

            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
                console.error(`Invalid date string: ${dateStr}`);
                return [];
            }
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();

            const results = [];
            for (let i = 0; i < 288; i++) {
                const hour = Math.floor(i / 12);
                const minute = (i % 12) * 5;
                const dt = new Date(Date.UTC(year, month - 1, day, hour, minute));
                const isoDate = dt.toISOString().replace('.000Z', '');

                try {
                    const [libLat, libLon] = EMEastroLib.topocentricLibration(year, month, day, hour, minute, lat, lon);
                    if (isNaN(libLat) || isNaN(libLon) || libLat === null || libLon === null) {
                        throw new Error(`Invalid libration values: lat=${libLat}, lon=${libLon}`);
                    }
                    results.push({
                        date: isoDate,
                        lat: libLat,
                        lon: libLon
                    });
                } catch (e) {
                    console.warn(`Error computing libration for ${isoDate} at ${locator}: ${e.message}`);
                    results.push({
                        date: isoDate,
                        lat: null,
                        lon: null
                    });
                }
            }

            const librationRates = results.map((curr, i, arr) => {
                if (
                    i <= 0 ||
                    i >= arr.length - 1 ||
                    arr[i-1].lat === null ||
                    arr[i-1].lon === null ||
                    arr[i+1].lat === null ||
                    arr[i+1].lon === null ||
                    curr.lat === null ||
                    curr.lon === null
                ) {
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }

                try {
                    const dlat = (arr[i+1].lat - arr[i-1].lat) / 10;
                    const dlon = (arr[i+1].lon - arr[i-1].lon) / 10;
                    if (isNaN(dlat) || isNaN(dlon) || !isFinite(dlat) || !isFinite(dlon)) {
                        console.warn(`Invalid dlat/dlon for ${curr.date} at ${locator}: dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    const rate = Math.sqrt(dlat * dlat + dlon * dlon);
                    if (isNaN(rate) || !isFinite(rate)) {
                        console.warn(`Invalid rate for ${curr.date} at ${locator}: rate=${rate}, dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    return { date: curr.date, rate, dldt: dlat, dbdt: dlon };
                } catch (e) {
                    console.warn(`Error computing rate for ${curr.date} at ${locator}: ${e.message}`);
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }
            });

            // Update cache
            const cache = type === 'qth' ? qthDayData : dxDayData;
            cache.date = dateStr;
            cache.libration = librationRates;

            if (type === 'qth') {
                rawData = librationRates.slice();
                document.getElementById("chartWrapper").style.display = rawData.some(r => r.rate != null) ? "block" : "none";
            } else {
                dxRawData = librationRates.slice();
                document.getElementById("dxChartWrapper").style.display = dxRawData.some(r => r.rate != null) ? "block" : "none";
            }
            return librationRates;
        }

        function computeFullDayData(cache, locator, dateStr, isQth) {
            const { lat: obsLat, lon: obsLon } = qthToLatLon(locator);
            const libData = cache.libration;
            const elevations = [];
            const azimuths = [];
            const dopplers = [];
            const rates = [];

            for (let i = 0; i < 288; i++) {
                const hour = Math.floor(i / 12);
                const minutes = (i % 12) * 5;
                const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00Z`);
                const observer = new Astronomy.Observer(obsLat, obsLon, 0);
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                const elevationDeg = hor.altitude;
                const azimuthDeg = hor.azimuth;

                const isAboveHorizon = elevationDeg >= -1;   // or >= -0.5 if you want to include refraction
                elevations.push(isAboveHorizon ? elevationDeg : null);
                azimuths.push(isAboveHorizon ? azimuthDeg : null);

                let rate = libData[i]?.rate ?? null;
                let doppler = null;
                if (isAboveHorizon && rate != null) {
                    rates.push(rate * 1000);
                    const omegaRadSec = rate * (Math.PI / 180) / 60;
                    doppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                } else {
                    rates.push(null);
                }
                dopplers.push(doppler);
            }

            cache.elevations = elevations;
            cache.azimuths = azimuths;
            cache.dopplers = dopplers;
            cache.rates = rates;
        }

        function interpolate(a, b, frac) {
            if (a === null || b === null) return null;
            return a + (b - a) * frac;
        }

        function getValueAtIndex(data, index) {
            if (index < 0 || index > 287) return null;
            const floorIdx = Math.floor(index);
            const ceilIdx = Math.ceil(index);
            const frac = index - floorIdx;
            if (floorIdx === ceilIdx) return data[floorIdx];
            return interpolate(data[floorIdx], data[ceilIdx], frac);
        }

        function computeRelativeAtIndex(idx, qthData, dxData) {
            const qthL = qthData.libration[idx];
            const dxL = dxData.libration[idx];
            if (!qthL || !dxL || qthL.dldt == null || dxL.dldt == null) {
                return { libration: null, doppler: null, pol: null };
            }

            const qthElev = qthData.elevations[idx];
            const dxElev = dxData.elevations[idx];
            if (qthElev === null || dxElev === null || qthElev < -1 || dxElev < -1) {
                return { libration: null, doppler: null, pol: null };
            }

            const dldt_sum = qthL.dldt + dxL.dldt;
            const dbdt_sum = qthL.dbdt + dxL.dbdt;
            const relLibration = Math.sqrt(dldt_sum * dldt_sum + dbdt_sum * dbdt_sum) / 2;

            const omegaRadSec = relLibration * (Math.PI / 180) / 60;
            const relDoppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;

            // Pol offset
            const qthAz = qthData.azimuths[idx];
            const dxAz = dxData.azimuths[idx];
            let pol = null;
            if (qthAz != null && dxAz != null) {
                const polQth = calcPoloffset(lat, qthAz, qthElev);
                const polDx = calcPoloffset(dxLat, dxAz, dxElev);
                pol = calcPoloffsetDiff(polQth, polDx);
            }

            return { libration: relLibration, doppler: relDoppler, pol };
        }
                                                
        function angularSeparation(ra1, dec1, ra2, dec2) {
            const d1 = degToRad(dec1);
            const d2 = degToRad(dec2);
            const r1 = degToRad(ra1 * 15); // Convert RA from hours to degrees
            const r2 = degToRad(ra2 * 15);
            const cosSep = Math.sin(d1) * Math.sin(d2) + Math.cos(d1) * Math.cos(d2) * Math.cos(r1 - r2);
            // Handle floating-point errors
            const sep = Math.acos(Math.max(-1, Math.min(1, cosSep)));
            return radToDeg(sep);
        }
                                                
        function vectorToEquatorial(vector, ofdate) {
            try {
                const moonEq = Astronomy.EquatorFromVector(vector);
                if (!moonEq || isNaN(moonEq.ra) || isNaN(moonEq.dec)) {
                    throw new Error('Invalid equatorial coordinates');
                }
                // Use Astronomy.Libration for distance instead of vector.length()
                const astroTime = Astronomy.MakeTime(vector.t);
                const libration = Astronomy.Libration(astroTime);
                if (!libration || isNaN(libration.dist_km)) {
                    throw new Error('Invalid libration data');
                }
                return {
                    ra: moonEq.ra, // Right ascension in hours
                    dec: moonEq.dec, // Declination in degrees
                    dist: libration.dist_km // Distance in kilometers
                };
            } catch (e) {
                console.error(`Error in vectorToEquatorial: ${e.message}`);
                return null;
            }
        }
                                                
        function updateMap(currentTime) {
            if (!map) {
                console.error('Map is not initialized in updateMap');
                return;
            }

            const utcTimeString = currentTime.toISOString();

            if (!currentTime || isNaN(currentTime.getTime())) {
                console.warn(`Invalid currentTime in updateMap: ${utcTimeString}`);
                return;
            }

            // Clear previous footprints and moon marker
            map.eachLayer(layer => {
                if (layer instanceof L.Polygon || layer instanceof L.Polyline || layer instanceof L.Circle || layer === moonMarker) {
                    if (layer.options && layer.options.color === '#0000FF' || layer === moonMarker) {
                        map.removeLayer(layer);
                    }
                }
            });

            try {
                const time = Astronomy.MakeTime(currentTime);
                const observer = new Astronomy.Observer(0, 0, 0); // Reference at Earth's center
                const moon = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
                const libration = Astronomy.Libration(time);

                if (!moon || isNaN(moon.ra) || isNaN(moon.dec) || !libration || isNaN(libration.dist_km)) {
                    throw new Error('Invalid moon or libration data');
                }

                // Calculate sublunar point
                const raDeg = moon.ra * 15; // RA in degrees
                const decDeg = moon.dec; // Declination in degrees
                let gastDeg = Astronomy.SiderealTime(time) * 15; // Greenwich Apparent Sidereal Time in degrees
                gastDeg = ((gastDeg % 360) + 360) % 360; // Normalize to [0, 360]
                let lonDeg = raDeg - gastDeg; // Longitude in degrees
                lonDeg = ((lonDeg + 180) % 360) - 180; // Normalize to [-180, 180]
                const lat = decDeg; // Latitude is equal to declination
                const lon = lonDeg;

                // Calculate footprint radius
                const earthRadiusKm = 6371; // Earth's mean radius
                const safeRatio = Math.min(1, Math.max(-1, earthRadiusKm / (earthRadiusKm + libration.dist_km)));
                const theta_rad = Math.acos(safeRatio);
                const footprintRadius_m = earthRadiusKm * theta_rad * 1000; // Radius in meters

                // Add moon marker
                moonMarker = L.marker([lat, lon], {
                    icon: L.icon({
                        iconUrl: 'images/moon-icon.png', // Ensure this path is correct
                        iconSize: [40, 40],
                        iconAnchor: [10, 10]
                    }),
                    title: `Sublunar Point (${lat.toFixed(2)}, ${lon.toFixed(2)})`
                }).addTo(map);

                // Add moon footprint using L.greatCircle
                try {
                    footprintCircle = L.greatCircle([lat, lon], {
                        radius: footprintRadius_m,
                        color: '#0000FF',
                        fillColor: '#0088FF',
                        fillOpacity: 0.3,
                        weight: 0,
                        wrapElements: true,
                        clipLat: 65,
                        degStep: 0.5,
                        maxCopies: -1
                    }).addTo(map);
                } catch (e) {
                    console.warn(`L.greatCircle failed: ${e.message}. Falling back to L.circle`);
                    footprintCircle = L.circle([lat, lon], {
                        radius: footprintRadius_m,
                        color: '#0000FF',
                        fillColor: '#0088FF',
                        fillOpacity: 0.2,
                        weight: 1
                    }).addTo(map);
                }

                // Removed map.panTo([lat, lon]); to prevent re-centering

            } catch (error) {
                console.error(`Error calculating sublunar point for ${utcTimeString}: ${error.message}`);
                // Defensive cleanup
                if (moonMarker) {
                    map.removeLayer(moonMarker);
                    moonMarker = null;
                }
                if (footprintCircle) {
                    map.removeLayer(footprintCircle);
                    footprintCircle = null;
                }
            }
        }

        function calculateMoonDataForMonth(dateStr) {
            // Check cache
            if (moonDayData.date === dateStr) {
                return moonDayData;
            }

            const startDate = new Date(dateStr);
            startDate.setUTCDate(1);
            startDate.setUTCHours(0, 0, 0, 0);
            const endDate = new Date(startDate);
            endDate.setUTCDate(endDate.getUTCDate() + 31); // Slightly over a month to ensure coverage

            const data = [];
            const labels = [];

            // Sgr A coordinates (J2000): RA = 17h45m40.0409s = 17.76112247h, Dec = -2900'28.118" = -29.00781056
            const sgrA = { ra: 17.76112247, dec: -29.00781056 };

            // Generate daily labels for the chart (DD-MM)
            for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
                const day = String(dt.getUTCDate()).padStart(2, '0');
                const month = String(dt.getUTCMonth() + 1).padStart(2, '0');
                labels.push(`${day}-${month}`);
            }

            // Compute hourly data
            for (let dt = new Date(startDate); dt <= endDate; dt.setUTCHours(dt.getUTCHours() + 1)) {
                try {
                    const dateString = dt.toISOString().slice(0, 10);
                    const time = dt.toISOString();
                    const astroTime = Astronomy.MakeTime(new Date(time));
                    
                    const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                    if (!moonVector) {
                        throw new Error('GeoVector returned null or undefined');
                    }
                    const moon = vectorToEquatorial(moonVector, false);
                    if (!moon) {
                        throw new Error('vectorToEquatorial returned null');
                    }
                    const libration = Astronomy.Libration(astroTime);
                    if (!libration) {
                        throw new Error('Libration returned null or undefined');
                    }
                    const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                    if (!sunVector) {
                        throw new Error('Sun GeoVector returned null or undefined');
                    }
                    const sun = Astronomy.EquatorFromVector(sunVector);
                    if (!sun || isNaN(sun.ra) || isNaN(sun.dec)) {
                        throw new Error('Invalid Sun equatorial coordinates');
                    }

                    const distanceKm = libration.dist_km;
                    const declination = moon.dec;
                    const sunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                    const sgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);

                    if (distanceKm != null && declination != null && !isNaN(declination) && !isNaN(sunSep) && !isNaN(sgrASep)) {
                        data.push({
                            date: dateString,
                            time: time,
                            index: (dt - startDate) / (1000 * 60 * 60), // Hours since start
                            distance: distanceKm,
                            declination: declination,
                            sunSep: sunSep,
                            sgrASep: sgrASep
                        });
                    } else {
                        console.warn(`Missing data for ${time}: distance=${distanceKm}, declination=${declination}, sunSep=${sunSep}, sgrASep=${sgrASep}`);
                    }
                } catch (e) {
                    console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
                }
            }

            // Update cache
            moonDayData.date = dateStr;
            moonDayData.data = data;
            moonDayData.labels = labels;

            return { data, labels };
        }

        function updateMoonChart(currentTime) {
            const dateInput = document.getElementById("date").value;
            const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

            // Aggregate hourly data to daily for plotting (average per day)
            const dailyData = [];
            for (let day = 0; day < labels.length; day++) {
                const dayStart = day * 24;
                const dayEnd = Math.min((day + 1) * 24, moonData.length);
                let distanceSum = 0, declinationSum = 0, count = 0;
                for (let i = dayStart; i < dayEnd; i++) {
                    if (moonData[i]) {
                        distanceSum += moonData[i].distance;
                        declinationSum += moonData[i].declination;
                        count++;
                    }
                }
                dailyData.push({
                    distance: count > 0 ? distanceSum / count : null,
                    declination: count > 0 ? declinationSum / count : null
                });
            }

            const distances = dailyData.map(d => d.distance);
            const declinations = dailyData.map(d => d.declination);

            // Calculate selected day index with hourly precision
            const startDate = new Date(dateInput);
            startDate.setUTCDate(1);
            startDate.setUTCHours(0, 0, 0, 0);
            const selectedIndex = (currentTime - startDate) / (1000 * 60 * 60); // Hours since start

            let currentDistance = null;
            let currentDeclination = null;
            let pathLoss = null;
            let currentSunSep = null;
            let currentSgrASep = null;
            const minDist = 356352.93;
            const sgrA = { ra: 17.76112247, dec: -29.00781056 };

            try {
                const astroTime = Astronomy.MakeTime(currentTime);
                const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                if (!moonVector) {
                    throw new Error('GeoVector returned null or undefined');
                }
                const moon = vectorToEquatorial(moonVector, false);
                const libration = Astronomy.Libration(astroTime);
                const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                if (!sunVector) {
                    throw new Error('Sun GeoVector returned null or undefined');
                }
                const sun = Astronomy.EquatorFromVector(sunVector);

                if (moon && libration && sun && !isNaN(sun.ra) && !isNaN(sun.dec)) {
                    currentDistance = libration.dist_km;
                    currentDeclination = moon.dec;
                    currentSunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                    currentSgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);
                    if (currentDistance != null) {
                        pathLoss = 40 * Math.log10(currentDistance / minDist);
                    }
                } else {
                    throw new Error("Invalid current Moon or Sun data");
                }
            } catch (e) {
                console.warn(`Error calculating current Moon data for ${currentTime.toISOString()}: ${e.message}`);
            }

            // Determine the selected band and whether to show M-SgrA-related data
            const band = document.getElementById('bandSelect').value;
            const showSgrASep = ['432MHz', '222MHz', '902MHz', '144MHz'].includes(band);

            // Find intervals where sunSep < 10 degrees with hourly precision
            const annotations = {
                timeMarker: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: selectedIndex / 24, // Map to daily scale
                    borderColor: 'black',
                    borderWidth: 2,
                    label: { enabled: false }
                }
            };

            let sunSepInterval = null;
            let sgrASepInterval = null;

            for (let i = 0; i < moonData.length; i++) {
                const dayData = moonData[i];
                if (dayData.sunSep < 10) {
                    if (!sunSepInterval) {
                        sunSepInterval = { start: dayData.index, end: dayData.index };
                    } else {
                        sunSepInterval.end = dayData.index;
                    }
                } else if (sunSepInterval) {
                    annotations[`sunSep${sunSepInterval.start}`] = {
                        type: 'box',
                        xScaleID: 'x',
                        yScaleID: 'y2',
                        xMin: sunSepInterval.start / 24, // Map to daily scale
                        xMax: (sunSepInterval.end + 1) / 24,
                        yMin: -30, // Span full declination range
                        yMax: 30,
                        backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                        borderWidth: 0, // No border
                        label: { enabled: false } // No label
                    };
                    sunSepInterval = null;
                }

                // Only process sgrASep annotations if 144MHz or 432MHz is selected
                if (showSgrASep && dayData.sgrASep < 10) {
                    if (!sgrASepInterval) {
                        sgrASepInterval = { start: dayData.index, end: dayData.index };
                    } else {
                        sgrASepInterval.end = dayData.index;
                    }
                } else if (sgrASepInterval) {
                    annotations[`sgrASep${sgrASepInterval.start}`] = {
                        type: 'box',
                        xScaleID: 'x',
                        yScaleID: 'y2',
                        xMin: sgrASepInterval.start / 24, // Map to daily scale
                        xMax: (sgrASepInterval.end + 1) / 24,
                        yMin: -30, // Span full declination range
                        yMax: 30,
                        backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                        borderWidth: 0, // No border
                        label: { enabled: false } // No label
                    };
                    sgrASepInterval = null;
                }
            }

            // Handle intervals that extend to the last data point
            if (sunSepInterval) {
                annotations[`sunSep${sunSepInterval.start}`] = {
                    type: 'box',
                    xScaleID: 'x',
                    yScaleID: 'y2',
                    xMin: sunSepInterval.start / 24,
                    xMax: (sunSepInterval.end + 1) / 24,
                    yMin: -30,
                    yMax: 30,
                    backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                    borderWidth: 0, // No border
                    label: { enabled: false } // No label
                };
            }

            if (showSgrASep && sgrASepInterval) {
                annotations[`sgrASep${sgrASepInterval.start}`] = {
                    type: 'box',
                    xScaleID: 'x',
                    yScaleID: 'y2',
                    xMin: sgrASepInterval.start / 24,
                    xMax: (sgrASepInterval.end + 1) / 24,
                    yMin: -30,
                    yMax: 30,
                    backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                    borderWidth: 0, // No border
                    label: { enabled: false } // No label
                };
            }

            // Construct the moonChartLabel content
            let labelContent =
                `<span class="metric-label metric-distance">Dist:</span> ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-declination">Decl:</span> ${currentDeclination != null ? currentDeclination.toFixed(1) + '' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-pathloss">Extra Loss:</span> ${pathLoss != null ? pathLoss.toFixed(2) + ' dB' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-sun-sep">M-Sun:</span> ${currentSunSep != null ? currentSunSep.toFixed(1) + '' : 'N/A'}`;

            // Conditionally add M-SgrA separation for 144MHz or 432MHz
            if (showSgrASep) {
                labelContent +=
                    `<span class="metric-separator">|</span>` +
                    `<span class="metric-label metric-sgra-sep">M-SgrA:</span> ${currentSgrASep != null ? currentSgrASep.toFixed(1) + '' : 'N/A'}`;
            }

            document.getElementById('moonChartLabel').innerHTML = labelContent;

            if (!moonChart) {
                moonChart = new Chart(document.getElementById("moonDistanceChart"), {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: "Moon Distance (km)",
                                data: distances,
                                borderColor: "#24a148",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y1"
                            },
                            {
                                label: "Moon Declination ()",
                                data: declinations,
                                borderColor: "#ff832b",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y2"
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: "Date (DD-MM)",
                                    font: { size: 10, family: 'Arial, sans-serif' }
                                },
                                ticks: { font: { size: 10 } }
                            },
                            y1: {
                                type: "linear",
                                display: true,
                                position: "left",
                                title: {
                                    display: true,
                                    text: "Distance (\u00D710 km)",
                                    color: "#24a148",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: 356400,
                                max: 406700,
                                ticks: {
                                    stepSize: 10000,
                                    color: "#24a148",
                                    font: { size: 12 },
                                    callback: function(value) {
                                        return (value / 1000).toFixed(0);
                                    }
                                },
                                grid: { drawTicks: true, drawBorder: true }
                            },
                            y2: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: {
                                    display: true,
                                    text: "Declination ()",
                                    color: "#ff832b",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: -30,
                                max: 30,
                                ticks: {
                                    stepSize: 10,
                                    callback: val => val + "",
                                    color: "#ff832b",
                                    font: { size: 12 }
                                },
                                grid: { drawOnChartArea: false }
                            },
                            y3: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: {
                                    display: true,
                                    text: "Extra Path Loss (dB)",
                                    color: "#24a148",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: 0,
                                max: 2.5,
                                ticks: {
                                    stepSize: 0.5,
                                    callback: val => val.toFixed(1),
                                    color: "#24a148",
                                    font: { size: 12 }
                                },
                                grid: { drawOnChartArea: false },
                                offset: true
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            annotation: { annotations }
                        }
                    }
                });
            } else {
                moonChart.data.labels = labels;
                moonChart.data.datasets[0].data = distances;
                moonChart.data.datasets[1].data = declinations;
                moonChart.options.plugins.annotation.annotations = annotations;
                moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedIndex / 24;
                moonChart.options.scales.y1.min = 356400;
                moonChart.options.scales.y1.max = 406700;
                moonChart.options.scales.y2.min = -30;
                moonChart.options.scales.y2.max = 30;
                moonChart.options.scales.y3.min = 0;
                moonChart.options.scales.y3.max = 2.5;
                moonChart.update('none');
            }
        }

        function updateChart(index, isRealtime = false) {
          const qthInput = document.getElementById("qth").value.trim().toUpperCase();
          const dxInput = document.getElementById("dx").value.trim().toUpperCase();
          const dateInput = document.getElementById("date").value;
          let dateStr;
          try {
            dateStr = new Date(dateInput).toISOString().slice(0, 10);
          } catch (e) {
            console.error('Invalid date input, using current date');
            dateStr = new Date().toISOString().slice(0, 10);
          }
          const band = document.getElementById('bandSelect').value;
          const maxDoppler = (FREQUENCY_HZ / bandConfig['10GHz'].frequency) * 300;

          let qthValid = false;
          if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
            if (qthDayData.date !== dateStr) {
              rawData = computeLibrationForDay(qthInput, dateStr, 'qth');
              computeFullDayData(qthDayData, qthInput, dateStr, true);
            }
            qthValid = qthDayData.libration.length === 288;
            try {
              ({ lat, lon } = qthToLatLon(qthInput));
            } catch (e) {
              console.error(`Error converting QTH locator ${qthInput} to lat/lon: ${e.message}`);
              lat = 0;
              lon = 0;
            }
          }

          let dxValid = false;
          if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
            if (dxDayData.date !== dateStr) {
              dxRawData = computeLibrationForDay(dxInput, dateStr, 'dx');
              computeFullDayData(dxDayData, dxInput, dateStr, false);
            }
            dxValid = dxDayData.libration.length === 288;
            try {
              ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
            } catch (e) {
              console.error(`Error converting DX locator ${dxInput} to lat/lon: ${e.message}`);
              dxLat = 0;
              dxLon = 0;
            }
          }

          // Get current values (interpolated if real-time)
          let currentElevQth = null, currentAzQth = null, currentRateQth = null, currentDopplerQth = null;
          if (qthValid) {
            currentElevQth = getValueAtIndex(qthDayData.elevations, index);
            currentAzQth = getValueAtIndex(qthDayData.azimuths, index);
            currentRateQth = getValueAtIndex(qthDayData.rates, index);
            currentDopplerQth = getValueAtIndex(qthDayData.dopplers, index);
          }

          let currentElevDx = null, currentAzDx = null, currentRateDx = null, currentDopplerDx = null;
          if (dxValid) {
            currentElevDx = getValueAtIndex(dxDayData.elevations, index);
            currentAzDx = getValueAtIndex(dxDayData.azimuths, index);
            currentRateDx = getValueAtIndex(dxDayData.rates, index);
            currentDopplerDx = getValueAtIndex(dxDayData.dopplers, index);
          }

          // Relative current
          let currentRelRate = null, currentRelDoppler = null, currentPolOffset = null;
          // Relative current (for label)  uses interpolation on full 288-point data
          if (qthValid && dxValid) {
              const floorIdx = Math.floor(index);
              const ceilIdx = Math.ceil(index);
              const frac = index - floorIdx;
              const relFloor = computeRelativeAtIndex(floorIdx, qthDayData, dxDayData);
              const relCeil = computeRelativeAtIndex(ceilIdx, qthDayData, dxDayData);
              currentRelRate = interpolate(relFloor.libration * 1000, relCeil.libration * 1000, frac);
              currentRelDoppler = interpolate(relFloor.doppler, relCeil.doppler, frac);
              currentPolOffset = interpolate(relFloor.pol, relCeil.pol, frac);
          }

          // Chart data from caches
          const qthRates = qthDayData.rates || Array(288).fill(null);
          const qthElevs = qthDayData.elevations || Array(288).fill(null);
          const qthDopps = qthDayData.dopplers || Array(288).fill(null);

          const dxRates = dxDayData.rates || Array(288).fill(null);
          const dxElevs = dxDayData.elevations || Array(288).fill(null);
          const dxDopps = dxDayData.dopplers || Array(288).fill(null);

          // === RELATIVE CHART DATA  ALWAYS 5-MINUTE RESOLUTION (288 points) ===
          let relLibrations = Array(288).fill(null);
          let relDopplers = Array(288).fill(null);
          let polOffsets = Array(288).fill(null);

          if (qthValid && dxValid) {
              // Always recompute at full 5-minute resolution
              // (removes the old date-check that caused 30-min stepping)
              for (let i = 0; i < 288; i++) {
                  const rel = computeRelativeAtIndex(i, qthDayData, dxDayData);
                  relLibrations[i] = rel.libration ? rel.libration * 1000 : null;
                  relDopplers[i] = rel.doppler;
                  polOffsets[i] = rel.pol;
              }
              // Update cache so we don't recompute unnecessarily on slider move
              relDayData.date = dateStr;
              relDayData.libration = relLibrations;
              relDayData.dopplers = relDopplers;
              relDayData.polOffsets = polOffsets;
          } else if (relDayData.date === dateStr) {
              // Reuse cached full-resolution data
              relLibrations = relDayData.libration;
              relDopplers = relDayData.dopplers;
              polOffsets = relDayData.polOffsets;
          }

          const labels = Array(288).fill('').map((_, i) => {
              const hour = Math.floor(i / 12);
              const minutes = (i % 12) * 5;
              return `${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
          });

          const qthAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (qthValid) {
            try {
              const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
              Object.assign(qthAnnotation, moonAnnotations);
            } catch (e) {
              console.warn(`Error getting moon annotations for QTH: ${e.message}`);
            }
          }

          if (qthValid) {
            document.getElementById("chartWrapper").style.display = "block";

            if (!chart) {
              chart = new Chart(document.getElementById("declinationChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Libration Rate (10 /min)",
                      data: qthRates,
                      borderColor: "#ff0000",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Moon Elevation ()",
                      data: qthElevs,
                      borderColor: "rgba(0, 0, 255, 0.6)",
                      backgroundColor: "rgba(0, 0, 255, 0.15)",
                      fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                      pointRadius: 0,
                      borderWidth: 1,
                      tension: 0.3,
                      yAxisID: "y2"
                    },
                             {
                                                 label: "Moon Azimuth ()",           // only appears in tooltip
                                                 data: qthDayData.azimuths || Array(288).fill(null),
                                                 hidden: true,                        //  important
                                                 yAxisID: "y2"                        // same axis just for scale reference
                                             },
                    {
                      label: "Doppler Spread, Hz",
                      data: qthDopps,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Libration Rate (10 /min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      position: "left",
                      display: true,
                      min: 0,
                      max: 90,
                      title: { display: true, text: "Moon Elevation ()", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 15, callback: val => val + "", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: qthAnnotation },
                    tooltip: {
                                    callbacks: {
                                        title: (tooltipItems) => {
                                            return tooltipItems[0]?.label || '';   // keep time label
                                        },
                                        label: (context) => {
                                            const idx = context.datasetIndex;
                                            const val = context.parsed.y;

                                            if (idx === 1) {   //  elevation dataset
                                                const azData = context.chart.data.datasets[2].data;  // hidden azimuth
                                                const az = azData[context.dataIndex];

                                                const lines = [
                                                    `Elevation: ${val?.toFixed(1) ?? ''}`
                                                ];

                                                if (az != null && !isNaN(az)) {
                                                    lines.push(`Azimuth:  ${az.toFixed(1)}`);
                                                }

                                                return lines;
                                            }

                                            // keep original formatting for other lines
                                            if (idx === 0) {
                                                return `Libration Rate: ${(val / 1000).toFixed(4)} /min`;
                                            }
                                            if (idx === 3) {
                                                return `Doppler Spread: ${Math.round(val)} Hz`;
                                            }

                                            return context.dataset.label + ": " + val;
                                        }
                                    }
                                }
                  }
                }
              });
            } else {
              chart.data.labels = labels;
              chart.data.datasets[0].data = qthRates;
              chart.data.datasets[1].data = qthElevs;
              chart.data.datasets[2].data = qthDopps;
              chart.options.plugins.annotation.annotations = qthAnnotation;
              chart.options.plugins.annotation.annotations.timeMarker.value = index;
              chart.options.scales.y3.max = maxDoppler;
              chart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
              chart.update('none');
            }

            const rateStr = currentRateQth != null ? (currentRateQth / 1000).toFixed(4) : null;
            document.getElementById('chartLabel').innerHTML =
              `<span class="metric-locator">${qthInput}</span>` +
              `<span class="metric-separator"></span>` +
              `<span class="metric-label metric-elevation">El:</span> ${currentElevQth != null ? currentElevQth.toFixed(1) + '' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-azimuth">Az:</span> ${currentAzQth != null ? currentAzQth.toFixed(1) + '' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '/min' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerQth != null ? currentDopplerQth.toFixed(0) + ' Hz' : 'N/A'}`;
          } else {
            document.getElementById("chartWrapper").style.display = "none";
            if (chart) {
              chart.destroy();
              chart = null;
            }
            document.getElementById('chartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
          }

          const dxAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (dxValid) {
            try {
              const moonAnnotations = getMoonAnnotations(dateStr, dxLat, dxLon);
              Object.assign(dxAnnotation, moonAnnotations);
            } catch (e) {
              console.warn(`Error getting moon annotations for DX: ${e.message}`);
            }
          }

          if (dxValid) {
            document.getElementById("dxChartWrapper").style.display = "block";

            if (!dxChart) {
              dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Libration Rate (10 /min)",
                      data: dxRates,
                      borderColor: "#ff0000",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Moon Elevation ()",
                      data: dxElevs,
                      borderColor: "rgba(0, 0, 255, 0.6)",
                      backgroundColor: "rgba(0, 0, 255, 0.15)",
                      fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                      pointRadius: 0,
                      borderWidth: 1,
                      tension: 0.3,
                      yAxisID: "y2"
                    },
                             {
                                                 label: "Moon Azimuth ()",           // only appears in tooltip
                                                 data: qthDayData.azimuths || Array(288).fill(null),
                                                 hidden: true,                        //  important
                                                 yAxisID: "y2"                        // same axis just for scale reference
                                             },
                    {
                      label: "Doppler Spread, Hz",
                      data: dxDopps,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Libration Rate (10 /min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      position: "left",
                      display: true,
                      min: 0,
                      max: 90,
                      title: { display: true, text: "Moon Elevation ()", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 15, callback: val => val + "", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: dxAnnotation },
                    tooltip: {
                                    callbacks: {
                                        title: (tooltipItems) => {
                                            return tooltipItems[0]?.label || '';   // keep time label
                                        },
                                        label: (context) => {
                                            const idx = context.datasetIndex;
                                            const val = context.parsed.y;

                                            if (idx === 1) {   //  elevation dataset
                                                const azData = context.chart.data.datasets[2].data;  // hidden azimuth
                                                const az = azData[context.dataIndex];

                                                const lines = [
                                                    `Elevation: ${val?.toFixed(1) ?? ''}`
                                                ];

                                                if (az != null && !isNaN(az)) {
                                                    lines.push(`Azimuth:  ${az.toFixed(1)}`);
                                                }

                                                return lines;
                                            }

                                            // keep original formatting for other lines
                                            if (idx === 0) {
                                                return `Libration Rate: ${(val / 1000).toFixed(4)} /min`;
                                            }
                                            if (idx === 3) {
                                                return `Doppler Spread: ${Math.round(val)} Hz`;
                                            }

                                            return context.dataset.label + ": " + val;
                                        }
                                    }
                                }
                  }
                }
              });
            } else {
              dxChart.data.labels = labels;
              dxChart.data.datasets[0].data = dxRates;
              dxChart.data.datasets[1].data = dxElevs;
              dxChart.data.datasets[2].data = dxDopps;
              dxChart.options.plugins.annotation.annotations = dxAnnotation;
              dxChart.options.plugins.annotation.annotations.timeMarker.value = index;
              dxChart.options.scales.y3.max = maxDoppler;
              dxChart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
              dxChart.update('none');
            }

            const rateStr = currentRateDx != null ? (currentRateDx / 1000).toFixed(4) : null;
            document.getElementById('dxchartLabel').innerHTML =
              `<span class="metric-locator">${dxInput}</span>` +
              `<span class="metric-separator"></span>` +
              `<span class="metric-label metric-elevation">El:</span> ${currentElevDx != null ? currentElevDx.toFixed(1) + '' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-azimuth">Az:</span> ${currentAzDx != null ? currentAzDx.toFixed(1) + '' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '/min' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerDx != null ? currentDopplerDx.toFixed(0) + ' Hz' : 'N/A'}`;
          } else {
            document.getElementById("dxChartWrapper").style.display = "none";
            if (dxChart) {
              dxChart.destroy();
              dxChart = null;
            }
            document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
          }

          const relativeAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (qthValid && dxValid) {
            try {
              const skedAnnotations = getSkedAnnotations(dateStr, lat, lon, dxLat, dxLon);
              Object.assign(relativeAnnotation, skedAnnotations);
            } catch (e) {
              console.warn(`Error getting sked annotations: ${e.message}`);
            }
          }

          if (qthValid && dxValid && relLibrations.some(r => r != null)) {
            document.getElementById("relativeChartWrapper").style.display = "block";

            if (!relativeChart) {
              relativeChart = new Chart(document.getElementById("relativeDataChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Relative Libration (10 /min)",
                      data: relLibrations,
                      borderColor: "red",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Relative Spread, Hz",
                      data: relDopplers,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y2"
                    },
                    {
                      label: "Polarization Offset ()",
                      data: polOffsets,
                      borderColor: "blue",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Rel. Libration (10 /min)", color: "red", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "red", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Rel. Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "left",
                      title: { display: true, text: "Polarization Offset ()", color: "blue", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: -90,
                      max: 90,
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 30, callback: val => val + "", color: "blue", font: { size: 12 } }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: relativeAnnotation }
                  }
                }
              });
            } else {
              relativeChart.data.labels = labels;
              relativeChart.data.datasets[0].data = relLibrations;
              relativeChart.data.datasets[1].data = relDopplers;
              relativeChart.data.datasets[2].data = polOffsets;
              relativeChart.options.plugins.annotation.annotations = relativeAnnotation;
              relativeChart.options.plugins.annotation.annotations.timeMarker.value = index;
              relativeChart.options.scales.y2.max = maxDoppler;
              relativeChart.options.scales.y2.ticks.stepSize = Math.ceil(maxDoppler / 6);
              relativeChart.update('none');
            }

            const relRateStr = currentRelRate != null ? (currentRelRate / 1000).toFixed(4) : null;
            document.getElementById('relativeChartLabel').innerHTML =
              `<span class="metric-label metric-rel-libration">Rel LR:</span> ${relRateStr != null ? relRateStr + '/min' : 'N/A'}` +
              `<span class="metric-separator"> | </span>` +
              `<span class="metric-label metric-rel-doppler">DX Width:</span> ${currentRelDoppler != null ? currentRelDoppler.toFixed(0) + ' Hz' : 'N/A'}` +
              `<span class="metric-separator"> | </span>` +
              `<span class="metric-label metric-poloffset">Dpol:</span> ${currentPolOffset != null ? currentPolOffset.toFixed(1) + '' : 'N/A'}`;
          } else {
            document.getElementById("relativeChartWrapper").style.display = "none";
            if (relativeChart) {
              relativeChart.destroy();
              relativeChart = null;
            }
            document.getElementById('relativeChartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH and DX</span>';
          }
          // At the very end, just before the final map/moon updates:
                  if (qthValid && dxValid) {
                      setTimeout(updateDxPopup, 0);
                  }

                  // Update map and moon chart with exact time
                  const exactTime = isRealtime ? new Date() : new Date(`${dateStr}T${Math.floor(index / 12).toString().padStart(2, '0')}:${String((index % 12) * 5).padStart(2, '0')}:00Z`);

                  updateMap(exactTime);
                  updateMoonChart(exactTime);

                  // Now update both popups (QTH popup will refresh live if open)
                  updateQthPopup();
                  if (dxMarker) updateDxPopup();
        }

        function startRealTimeUpdates() {
            if (isRealTimeMode) {
                console.log('startRealTimeUpdates: Starting real-time updates'); // Debug log
                stopRealTimeUpdates(); // Clear any existing interval
                updateRealTime(); // Perform immediate update
                const now = new Date();
                const secondsUntilNextMinute = 60 - now.getUTCSeconds();
                const millisecondsUntilNextMinute = secondsUntilNextMinute * 1000 - now.getUTCMilliseconds();
                setTimeout(() => {
                    if (isRealTimeMode) { // Double-check mode
                        updateRealTime();
                        realTimeInterval = setInterval(updateRealTime, 60000);
                    } else {
                        console.log('startRealTimeUpdates: Aborted interval start due to real-time mode off'); // Debug log
                    }
                }, millisecondsUntilNextMinute);
            } else {
                console.log('startRealTimeUpdates: Skipped because real-time mode is off'); // Debug log
            }
        }

        function stopRealTimeUpdates() {
          if (realTimeInterval) {
            clearInterval(realTimeInterval);
            realTimeInterval = null;
          }
        }

        function updateRealTime() {
            if (!isRealTimeMode) {
                console.log('updateRealTime: Skipped because real-time mode is off');
                return;
            }
            console.log('updateRealTime: Running real-time update');
            const now = new Date();
            const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            document.getElementById('date').valueAsDate = utcDate;
            document.getElementById('date').value = utcDate.toISOString().slice(0, 10);

            const hour = now.getUTCHours();
            const minute = now.getUTCMinutes();
            const fractionalIndex = hour * 12 + (minute / 5);
            const displayHour = String(hour).padStart(2, '0');
            const displayMin = String(minute).padStart(2, '0');
            document.getElementById('hour-value').textContent = `UTC: ${displayHour}:${displayMin}`;

            const dateStr = utcDate.toISOString().slice(0, 10);
            const qthInput = document.getElementById('qth').value.trim().toUpperCase();
            const dxInput = document.getElementById('dx').value.trim().toUpperCase();
            if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && qthDayData.date !== dateStr) {
                computeLibrationForDay(qthInput, dateStr, 'qth');
                computeFullDayData(qthDayData, qthInput, dateStr, true);
            }
            if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && dxDayData.date !== dateStr) {
                computeLibrationForDay(dxInput, dateStr, 'dx');
                computeFullDayData(dxDayData, dxInput, dateStr, false);
            }
            if (moonDayData.date !== dateStr) {
                moonDayData.date = null; // Invalidate Moon data cache
                calculateMoonDataForMonth(dateStr);
            }
            updateChart(fractionalIndex, true);
            updateQthPopup();
            updateDxPopup();                 //  added
        }

        function decodeEmail(obfuscated) {
            try {
                const reversed = obfuscated.split('').reverse().join('');
                return atob(reversed);
            } catch (e) {
                return '';
            }
        }
        
        let markers = []; // Store markers globally for filtering

        function updateMarkers(data, showActiveOnly) {
            // Clear existing markers
            markers.forEach(marker => marker.remove());
            markers = [];

            const coordinateMap = new Map();

            // First pass: Count stations per coordinate
            data.forEach(station => {
                const { Coordinates, Note = '' } = station;
                if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                    return; // Skip stations with DXpedition or SK in Note
                }
                const [latStr, lngStr] = Coordinates.split(',');
                const lat = parseFloat(latStr);
                const lng = parseFloat(lngStr);
                if (isNaN(lat) || isNaN(lng)) {
                    console.warn(`Invalid coordinates for station ${station.Call}: ${Coordinates}`);
                    return;
                }
                const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                coordinateMap.set(coordKey, (coordinateMap.get(coordKey) || 0) + 1);
            });

            // Get the current band
            const band = document.getElementById('bandSelect').value;

            // Second pass: Create markers with conditional offsets
            data.forEach(station => {
                const {
                    Call: callsign,
                    Locator: locator,
                    Antenna: antenna,
                    Power: power,
                    Website: website,
                    CK: obfuscatedEmail = '',
                    Coordinates,
                    Note = '',
                    Name = ''
                } = station;

                if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                    return; // Skip stations with DXpedition or SK in Note
                }

                const email = decodeEmail(obfuscatedEmail);
                const [latStr, lngStr] = Coordinates.split(',');
                const lat = parseFloat(latStr);
                const lng = parseFloat(lngStr);
                if (isNaN(lat) || isNaN(lng)) {
                    console.warn(`Skipping station ${callsign} due to invalid coordinates: ${Coordinates}`);
                    return;
                }

                const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                let offsetIndex = coordinateMap.get(coordKey + '_index') || 0;
                coordinateMap.set(coordKey + '_index', offsetIndex + 1);

                let markerPosition = [lat, lng];
                const count = coordinateMap.get(coordKey);
                if (count > 1) {
                    const offset = 0.01;
                    const angle = (offsetIndex * 2 * Math.PI) / count;
                    markerPosition = [
                        lat + offset * Math.cos(angle),
                        lng + offset * Math.sin(angle)
                    ];
                }

                let iconUrl = "images/176096839586434633.png";
                if (/Inactive/i.test(Note)) {
                    iconUrl = "images/EME_inactive.png";
                } else if (/SK/i.test(Note)) {
                    iconUrl = "images/EME_SK.png";
                } else if (/DXpedition|Portable/i.test(Note)) {
                    iconUrl = "images/EME_dxped2.png";
                }

                const marker = L.marker(markerPosition, {
                    icon: L.icon({
                        iconUrl: iconUrl,
                        iconSize: [16, 16]
                    }),
                    title: callsign
                }).addTo(map);

                markers.push(marker);

                const isLocatorValid = /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator);
                const sanitizedCallsign = sanitizeCallsign(callsign);
                const skedButton = isLocatorValid ?
                    `<button id="sked-${sanitizedCallsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>` :
                    '';
                const emailButton = email ?
                    `<a id="email-${sanitizedCallsign}" class="email-button" href="mailto:${email}">Email</a>` :
                    '';
                const qrzButton = `<a id="qrz-${sanitizedCallsign}" class="qrz-button" href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ</a>`;
                const callsignDisplay = callsign +
                    (/SK/i.test(Note) ? ' (SK)' : '') +
                    (/Inactive/i.test(Note) ? ' (not active)' : '');
                const displayWebsite = website.length > 30 ? website.slice(0, 30) + '...' : website;
                const nameLine = Name ? `<div><strong>${Name}</strong></div>` : '';

                const bandSpecificImageUrl = `db/${sanitizedCallsign}-${band}.jpg`;
                const bandSpecificThumbUrl = `db/${sanitizedCallsign}_thumb-${band}.jpg`;
                const genericImageUrl = `db/${sanitizedCallsign}.jpg`;
                const genericThumbUrl = `db/${sanitizedCallsign}_thumb.jpg`;

                // === DYNAMIC POPUP ONLY  windows only shown if this station is currently in DX field ===
                // === DYNAMIC POPUP ONLY  windows shown only when this station is selected via Sked ===
                marker.bindPopup(() => {
                    const currentQTH = document.getElementById('qth').value.trim().toUpperCase();
                    const currentDX = document.getElementById('dx').value.trim().toUpperCase();
                    const dateStr = document.getElementById('date').value;
                    const currentBand = document.getElementById('bandSelect').value;

                    // Normalize the station's locator to uppercase for reliable comparison
                    const stationLocatorUpper = locator.toUpperCase();

                    // Only show windows if the DX field currently contains this station's locator
                    let windowsHTML = '';
                    if (currentDX === stationLocatorUpper &&
                        /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(currentQTH) &&
                        /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(stationLocatorUpper)) {

                        const windows = getCommonWindows(currentQTH, stationLocatorUpper, dateStr);

                        if (windows.length > 0) {
                            const moonIcon = `<svg width="14" height="14" viewBox="0 0 24 24" style="vertical-align:middle;"><path fill="currentColor" d="M12 2a9.93 9.93 0 0 0-7.06 2.94A10 10 0 1 0 22 12c0-.34-.02-.67-.05-1a8 8 0 0 1-9.95-9z"/></svg>`;

                            const baseDate = new Date(`${dateStr}T00:00:00Z`);
                            const baseDay = baseDate.getUTCDate();

                            function suffixFor(dateObj) {
                                const d = dateObj.getUTCDate();
                                if (d === baseDay) return "";
                                return d > baseDay ? "(+1)" : "(-1)";
                            }

                            windowsHTML = '<div style="margin-top:10px;"><strong>Common Moon Windows</strong><br>';
                            windows.forEach((w, i) => {
                                const start = formatTimeUTC(w.start);
                                const end = formatTimeUTC(w.end);
                                const startSuffix = suffixFor(w.start);
                                const endSuffix = suffixFor(w.end);
                                windowsHTML += `<div>${moonIcon} Window ${i+1}: ${start}${startSuffix}  ${end}${endSuffix}</div>`;
                            });
                            windowsHTML += '<div style="font-size:11px; color:#666; margin-top:4px; font-style:italic;">(-1) and (+1) denote the previous and next UTC day</div></div>';
                        } else {
                            windowsHTML = '<div style="margin-top:10px; color:#666;"><em>No common window today with your QTH</em></div>';
                        }
                    }

                    // Use current band for images
                    const bandSpecificImageUrl = `db/${sanitizedCallsign}-${currentBand}.jpg`;
                    const bandSpecificThumbUrl = `db/${sanitizedCallsign}_thumb-${currentBand}.jpg`;
                    const genericImageUrl = `db/${sanitizedCallsign}.jpg`;
                    const genericThumbUrl = `db/${sanitizedCallsign}_thumb.jpg`;

                    return `
                        <div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <div>
                                    <div style="font-weight:bold; font-size: 16px;">${callsignDisplay}</div>
                                    ${nameLine}
                                </div>
                                <div class="button-group-infowindow" style="gap: 6px; flex-shrink: 0;">
                                    ${skedButton}${emailButton}${qrzButton}
                                </div>
                            </div>
                            <div>Locator: ${locator}</div>
                            <div>Antenna: ${antenna}</div>
                            <div>Power: ${power}</div>
                            <div>Website: <a href="${website}" target="_blank">${displayWebsite}</a></div>
                            ${windowsHTML}
                            <div id="image-container-${sanitizedCallsign}" style="margin-top:10px;">
                                Station Picture (clickable):
                                <a id="image-link-${sanitizedCallsign}" href="${bandSpecificImageUrl}" target="_blank">
                                    <img id="station-image-${sanitizedCallsign}" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA" alt="${callsign} station"/>
                                </a>
                                <div id="image-placeholder-${sanitizedCallsign}" style="display:none;">
                                    <p><a href="datasubmission.html" target="_blank">Add Image</a></p>
                                </div>
                            </div>
                        </div>
                    `;
                });

                // Image loading + Sked button handler on popup open
                marker.on('popupopen', () => {
                    loadStationImage(sanitizedCallsign);

                    // Sked button: fill DX field
                    // Sked button: fill DX field AND refresh popup immediately
                    const skedBtn = document.getElementById(`sked-${sanitizedCallsign}`);
                    if (skedBtn) {
                        skedBtn.onclick = null;
                        skedBtn.addEventListener('click', (e) => {
                            e.stopPropagation();

                            document.getElementById('dx').value = locator.toUpperCase();
                            document.getElementById('dx').dispatchEvent(new Event('input', { bubbles: true }));

                            if (marker.isPopupOpen()) {
                                const popup = marker.getPopup();
                                if (popup) {
                                    popup.update(); // Refresh content (including windows)
                                    // Re-load image with possibly new band (if changed meanwhile)
                                    setTimeout(() => loadStationImage(sanitizedCallsign), 50);
                                }
                            }
                        });
                    }
                });
            });
        }

        function initMap() {
            try {
                // Initialize map
                map = L.map('map', {
                    zoom: 2,
                    center: [0, 0],
                    gestureHandling: true,
                    fullscreenControl: false
                });

                // Define and add OSM base layer
                var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);

                // Move zoom control to bottom right
                map.zoomControl.setPosition('bottomright');

                // Define CQ Zones and Maidenhead layers
                var cqzones, maidenhead;
                if (typeof L.cqzones === 'function') {
                    cqzones = L.cqzones({ color: 'rgba(255, 0, 0, 0.4)' });
                 
                } else {
                    console.error('L.cqzones is not defined. CQ Zones layer will not be available.');
                }

                if (typeof L.maidenhead === 'function') {
                    maidenhead = L.maidenhead();
                } else {
                    console.error('L.maidenhead is not defined. Maidenhead layer will not be available.');
                }

                // Add layer control (base + overlays)
                var overlays = {};
                if (cqzones) overlays["<span style='color: black'>CQ Zones</span>"] = cqzones;
                if (maidenhead) overlays["<span style='color: black'>Maidenhead</span>"] = maidenhead;

                L.control.layers({
                    'Map': osm
                }, overlays).addTo(map);

                // Load markers based on band
                const band = document.getElementById('bandSelect').value;
                const jsonFile = bandConfig[band].jsonFile;
                const showActiveOnly = isActiveStationsOnly;

                fetch(jsonFile)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                        return response.json();
                    })
                    .then(data => {
                        updateMarkers(data, showActiveOnly);
                    })
                    .catch(error => {
                        console.error(`Error fetching ${jsonFile} in initMap:`, error);
                        alert(`Failed to load station data for ${band}. Please try again later.`);
                    });

            } catch (error) {
                console.error('Error initializing map:', error);
                document.getElementById('map').innerHTML = '<p style="color: red; text-align: center;">Failed to load map. Please check your internet connection or try again later.</p>';
            }
        }

        let isActiveStationsOnly = false; // Default state (equivalent to checkbox checked)

        document.getElementById('activeStationsButton').addEventListener('click', () => {
          isActiveStationsOnly = !isActiveStationsOnly;
          const activeButton = document.getElementById('activeStationsButton');
          if (isActiveStationsOnly) {
            activeButton.classList.add('active');
          } else {
            activeButton.classList.remove('active');
          }
          activeButton.title = isActiveStationsOnly ? 'Showing Active Stations (Click to show All)' : 'Showing All Stations (Click to show Active only)';
          const band = document.getElementById('bandSelect').value;
          const jsonFile = bandConfig[band].jsonFile;
          fetch(jsonFile)
            .then(response => response.json())
            .then(data => {
              updateMarkers(data, isActiveStationsOnly);
            })
            .catch(error => {
              console.error(`Error fetching ${jsonFile}:`, error);
            });
        });
        
        document.getElementById('realTimeButton').addEventListener('click', () => {
            isRealTimeMode = !isRealTimeMode;
            const autoTrackButton = document.getElementById('realTimeButton');
            const hourSlider = document.getElementById('hour');
            const dateInput = document.getElementById('date');
            const prevDayButton = document.getElementById('prevDay');
            const nextDayButton = document.getElementById('nextDay');

            if (isRealTimeMode) {
                console.log('realTimeButton: Enabling real-time mode'); // Debug log
                autoTrackButton.classList.add('active');
                autoTrackButton.textContent = 'Stop';
                hourSlider.disabled = true;
                dateInput.disabled = true;
                prevDayButton.disabled = true;
                nextDayButton.disabled = true;
                startRealTimeUpdates();
            } else {
                console.log('realTimeButton: Disabling real-time mode'); // Debug log
                autoTrackButton.classList.remove('active');
                autoTrackButton.textContent = 'Track';
                hourSlider.disabled = false;
                dateInput.disabled = false;
                prevDayButton.disabled = false;
                nextDayButton.disabled = false;
                stopRealTimeUpdates();
                updateHourDisplay();
                updateChart(hourIndex, false);
            }
        });
        
                                                document.getElementById('bandSelect').addEventListener('change', () => {
                                                  const band = document.getElementById('bandSelect').value;
                                                  
                                                  // Save to localStorage
                                                  localStorage.setItem('emeObserverLastBand', band);
                                                  
                                                  updateBand(band);
                                                });
                                                
                                                // Show/hide the 144 MHz notice when band changes
                                                document.getElementById('bandSelect').addEventListener('change', function() {
                                                    const notice = document.getElementById('vhfNotice');
                                                    if (this.value === '144MHz') {
                                                        notice.classList.add('visible');
                                                    } else {
                                                        notice.classList.remove('visible');
                                                    }
                                                });

                                                // Run once on page load in case the saved band is 144MHz
                                                window.addEventListener('load', () => {
                                                    const currentBand = document.getElementById('bandSelect').value;
                                                    if (currentBand === '144MHz') {
                                                        document.getElementById('vhfNotice').classList.add('visible');
                                                    }
                                                });
                                                
        function parseCoordinates(coordinates) {
            const [latStr, lngStr] = coordinates.split(',');
            return {
                lat: parseFloat(latStr),
                lng: parseFloat(lngStr)
            };
        }

        function getMoonAnnotations(dateStr, lat, lon) {
            const observer = new Astronomy.Observer(lat, lon, 0);
            const jsDate = new Date(`${dateStr}T00:00:00Z`);
            const astroTime = Astronomy.MakeTime(jsDate);

            let riseEvent = null, setEvent = null;
            try {
                riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
            } catch (e) {
                console.warn(`Error calculating moonrise for ${dateStr}: ${e.message}`);
            }

            try {
                setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
            } catch (e) {
                console.warn(`Error calculating moonset for ${dateStr}: ${e.message}`);
            }

            const annotations = {};

            function formatTimeUTC(date) {
                return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
            }

            const targetDateStr = dateStr.slice(0, 10);

            if (riseEvent && riseEvent.date) {
                const riseDate = riseEvent.date;
                const riseDateStr = riseDate.toISOString().slice(0, 10);
                if (riseDateStr === targetDateStr) {
                    let index = timeToChartIndex(riseDate);
                    const isLate = riseDate.getUTCHours() >= 23 && riseDate.getUTCMinutes() >= 55;
                    annotations['moonrise'] = {
                        type: 'line',
                        mode: 'vertical',
                        scaleID: 'x',
                        value: isLate ? 287 : index,
                        borderColor: 'blue',
                        borderWidth: 1,
                        label: {
                            content: ['Rise', formatTimeUTC(riseDate)],
                            enabled: true,
                            position: 'top',
                            yAdjust: isLate ? -50 : -40,
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            color: 'white',
                            backgroundColor: 'rgba(0, 0, 255, 0.85)',
                            padding: 2,
                            cornerRadius: 6,
                            boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                            textAlign: 'center',
                            borderColor: 'rgba(255, 255, 255, 0.7)',
                            borderWidth: 1
                        }
                    };
                }
            }

            if (setEvent && setEvent.date) {
                const setDate = setEvent.date;
                const setDateStr = setDate.toISOString().slice(0, 10);
                if (setDateStr === targetDateStr) {
                    let index = timeToChartIndex(setDate);
                    const isLate = setDate.getUTCHours() >= 23 && setDate.getUTCMinutes() >= 55;
                    annotations['moonset'] = {
                        type: 'line',
                        mode: 'vertical',
                        scaleID: 'x',
                        value: isLate ? 287 : index,
                        borderColor: 'orange',
                        borderWidth: 1,
                        label: {
                            content: ['Set', formatTimeUTC(setDate)],
                            enabled: true,
                            position: 'top',
                            yAdjust: isLate ? -10 : -20,
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            color: 'white',
                            backgroundColor: 'rgba(255, 165, 0, 0.85)',
                            padding: 2,
                            cornerRadius: 6,
                            boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                            textAlign: 'center',
                            borderColor: 'rgba(255, 255, 255, 0.7)',
                            borderWidth: 1
                        }
                    };
                }
            }

            return annotations;
        }

        function timeToChartIndex(date) {
            if (!(date instanceof Date)) throw new Error("Expected a Date object");
            let hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
            if (hours >= 23.9167) {
                hours = 23.9167;
            }
            return hours * 12;
        }

        function getSkedAnnotations(dateStr, qthLat, qthLon, dxLat, dxLon) {
            const annotations = {};

            const qthLoc = document.getElementById('qth').value.trim().toUpperCase();
            const dxLoc  = document.getElementById('dx').value.trim().toUpperCase();

            if (!qthLoc || !dxLoc || !/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthLoc) || !/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxLoc)) {
                return annotations;
            }

            const windows = getCommonWindows(qthLoc, dxLoc, dateStr);
            if (windows.length === 0) return annotations;

            const dayStart = new Date(`${dateStr}T00:00:00Z`).getTime();
            const dayEnd   = new Date(`${dateStr}T23:59:59Z`).getTime();

            function format(time) {
                return `${String(time.getUTCHours()).padStart(2,'0')}:${String(time.getUTCMinutes()).padStart(2,'0')}`;
            }

            function index(time) {
                return (time.getUTCHours() + time.getUTCMinutes()/60) * 12;
            }

            windows.forEach((w, i) => {
                const startTime = w.start.getTime();
                const endTime   = w.end.getTime();

                // Base vertical position per window (alternates top/bottom for multiple windows)
                const basePosition = i % 2 === 0 ? 'top' : 'bottom';

                // Start label: always slightly above the line
                if (startTime >= dayStart && startTime <= dayEnd) {
                    annotations[`skedStart${i}`] = {
                        type: 'line',
                        scaleID: 'x',
                        value: index(w.start),
                        borderColor: 'rgba(0, 220, 0, 0.95)',
                        borderWidth: 1,
                        borderDash: [8, 5],
                        label: {
                            content: format(w.start),
                            enabled: true,
                            position: basePosition,
                            yAdjust: basePosition === 'top' ? -8 : 8,        // Push further away
                            backgroundColor: 'rgba(0, 140, 0, 0.0)',
                            color: '#008000',
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            padding: { top: 4, bottom: 4, left: 6, right: 6 },
                            cornerRadius: 5,
                            borderWidth: 1,
                            borderColor: 'rgba(255,255,255,0.3)'
                        }
                    };
                }

                // End label: always slightly below the line (opposite side of start)
                if (endTime >= dayStart && endTime <= dayEnd) {
                    const endPosition = basePosition === 'top' ? 'bottom' : 'top';  // opposite side
                    annotations[`skedEnd${i}`] = {
                        type: 'line',
                        scaleID: 'x',
                        value: index(w.end),
                        borderColor: 'rgba(230, 0, 0, 0.95)',
                        borderWidth: 1,
                        borderDash: [8, 5],
                        label: {
                            content: format(w.end),
                            enabled: true,
                            position: endPosition,
                            yAdjust: endPosition === 'top' ? -8 : 8,
                            backgroundColor: 'rgba(180, 0, 0, 0.0)',
                            color: '#B31B1B',
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            padding: { top: 4, bottom: 4, left: 6, right: 6 },
                            cornerRadius: 5,
                            borderWidth: 1,
                            borderColor: 'rgba(255,255,255,0.3)'
                        }
                    };
                }
            });

            return annotations;
        }

        function getCommonWindows(qthLoc, dxLoc, dateStr) {
            // Validation
            if (!qthLoc || !dxLoc ||
                !/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthLoc) ||
                !/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxLoc)) {
                return [];
            }

            const MS_DAY = 24 * 60 * 60 * 1000;
            const qth = qthToLatLon(qthLoc);
            const dx  = qthToLatLon(dxLoc);
            const qthObs = new Astronomy.Observer(qth.lat, qth.lon, 0);
            const dxObs  = new Astronomy.Observer(dx.lat,  dx.lon,  0);

            // UTC day boundaries
            const dayStartDate = new Date(`${dateStr}T00:00:00Z`);
            const dayStart = dayStartDate.getTime();
            const dayEnd   = dayStart + MS_DAY;

            // Helper to safely call SearchRiseSet and return Date or null
            const searchEvent = (body, obs, direction, timeObj) => {
                try {
                    return Astronomy.SearchRiseSet(body, obs, direction, timeObj, 2.0)?.date || null;
                } catch (e) {
                    // on failure return null to allow graceful fallback
                    console.warn("SearchRiseSet error:", e);
                    return null;
                }
            };

            // Collect several rises and sets around the day for an observer.
            // We take events from (dayStart - 1d) up to (dayEnd + 1d) by repeatedly asking
            // for the next rise (direction +1) and next set (direction -1).
            const collectEventsForObserver = (obs) => {
                const events = []; // {type: 'rise'|'set', date: Date}

                // collect rises: start search from dayStart - 1 day
                let t = new Date(dayStart - MS_DAY);
                for (let i = 0; i < 6; i++) { // 6 gives ample coverage across boundaries
                    const tm = Astronomy.MakeTime(t);
                    const r = searchEvent(Astronomy.Body.Moon, obs, +1, tm);
                    if (!r) break;
                    events.push({ type: 'rise', date: new Date(r) });
                    // advance just past this rise to find the next one
                    t = new Date(r.getTime() + 1000);
                    // stop if we've gathered well past the day end
                    if (t.getTime() > dayEnd + MS_DAY) break;
                }

                // collect sets similarly
                t = new Date(dayStart - MS_DAY);
                for (let i = 0; i < 6; i++) {
                    const tm = Astronomy.MakeTime(t);
                    const s = searchEvent(Astronomy.Body.Moon, obs, -1, tm);
                    if (!s) break;
                    events.push({ type: 'set', date: new Date(s) });
                    t = new Date(s.getTime() + 1000);
                    if (t.getTime() > dayEnd + MS_DAY) break;
                }

                // Sort events chronologically
                events.sort((a, b) => a.date.getTime() - b.date.getTime());

                // Pair rises with the next set to generate moon-up intervals.
                // We allow that the very first event could be a 'set' (meaning the rise was earlier),
                // in which case we try to locate a preceding rise from our collected rises.
                const risesOnly = events.filter(e => e.type === 'rise').map(e => e.date.getTime());
                const setsOnly  = events.filter(e => e.type === 'set').map(e => e.date.getTime());

                // Build event stream from merged sorted list (we already have 'events')
                const intervals = [];
                let currentRise = null;

                for (const ev of events) {
                    if (ev.type === 'rise') {
                        // start new interval if none open
                        if (!currentRise) currentRise = ev.date;
                        // if a rise occurs while one is already open, ignore duplicate/malformed rises
                    } else { // ev.type === 'set'
                        if (currentRise) {
                            // normal case: we have a rise followed by a set
                            const rise = new Date(currentRise.getTime());
                            const set  = new Date(ev.date.getTime());
                            if (set.getTime() > rise.getTime()) {
                                intervals.push({ start: rise, end: set });
                            }
                            currentRise = null;
                        } else {
                            // set without a recorded rise in the scanned window:
                            // try to find the nearest earlier rise (from risesOnly) that is < set
                            // This handles the case "rise yesterday, set today (start before our window)"
                            const earlierRises = risesOnly.filter(rt => rt < ev.date.getTime());
                            if (earlierRises.length > 0) {
                                const riseTs = earlierRises[earlierRises.length - 1];
                                intervals.push({ start: new Date(riseTs), end: new Date(ev.date) });
                            } else {
                                // nothing we can pair  skip
                            }
                        }
                    }
                }

                // If a rise remained open at the end, attempt to find its matching set (should be in setsOnly)
                if (currentRise) {
                    const futureSets = setsOnly.filter(st => st > currentRise.getTime());
                    if (futureSets.length > 0) {
                        intervals.push({ start: new Date(currentRise.getTime()), end: new Date(futureSets[0]) });
                        currentRise = null;
                    }
                }

                // Finally filter intervals to those that actually overlap the requested UTC day
                const overlapsDay = iv => (iv.start.getTime() < dayEnd) && (iv.end.getTime() > dayStart);
                return intervals.filter(overlapsDay);
            };

            const qthIntervals = collectEventsForObserver(qthObs); // array of {start, end}
            const dxIntervals  = collectEventsForObserver(dxObs);

            // If either has no intervals that touch the day, no common window
            if (!qthIntervals.length || !dxIntervals.length) return [];

            // Intersect the two interval lists to produce all overlapping windows
            const windows = [];
            for (const a of qthIntervals) {
                for (const b of dxIntervals) {
                    const s = Math.max(a.start.getTime(), b.start.getTime());
                    const e = Math.min(a.end.getTime(),   b.end.getTime());
                    if (s < e) {
                        // compute day offsets relative to the requested day for display
                        const offsetForTs = (ts) => (ts < dayStart ? -1 : (ts >= dayEnd ? +1 : 0));
                        const startDate = new Date(s);
                        const endDate   = new Date(e);
                        windows.push({
                            start: startDate,
                            end:   endDate,
                            dayOffsetStart: offsetForTs(s),
                            dayOffsetEnd:   offsetForTs(e)
                        });
                    }
                }
            }

            // Sort windows by start time for convenience
            windows.sort((A, B) => A.start.getTime() - B.start.getTime());

            return windows;
        }

        document.getElementById("hour").addEventListener("input", () => {
            hourIndex = parseInt(document.getElementById("hour").value);
            const hour = Math.floor(hourIndex / 12);
            const minutes = (hourIndex % 12) * 5;
            document.getElementById("hour-value").textContent = `UTC: ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            updateChart(hourIndex, false);
        });

        function adjustDate(days) {
            const dateInput = document.getElementById("date");
            const currentDate = new Date(dateInput.value);
            currentDate.setDate(currentDate.getDate() + days);
            dateInput.valueAsDate = currentDate;
            dateInput.value = currentDate.toISOString().slice(0,10);
            const changeEvent = new Event('change', { bubbles: true });
            dateInput.dispatchEvent(changeEvent);
            updateChart(hourIndex, false);
        }

        document.getElementById("prevDay").addEventListener("click", () => {
            adjustDate(-1);
        });

        document.getElementById("nextDay").addEventListener("click", () => {
            adjustDate(1);
        });

        document.getElementById("date").addEventListener("change", () => {
            const qthInput = document.getElementById("qth").value.trim().toUpperCase();
            const dxInput = document.getElementById("dx").value.trim().toUpperCase();
            moonDayData.date = null; // Invalidate Moon data cache
            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
                computeFullDayData(qthDayData, qthInput, document.getElementById("date").value, true);
            }
            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
                computeFullDayData(dxDayData, dxInput, document.getElementById("date").value, false);
            }
            updateChart(hourIndex, false);
            setTimeout(updateQthPopup, 0);  // Update after computations
            setTimeout(updateDxPopup,  0);   //  added
            // Refresh any open station popups so they show updated windows for new date
            map.eachLayer(layer => {
                if (layer instanceof L.Marker) {
                    const popup = layer.getPopup();
                    if (popup && popup.isOpen()) {
                        layer.openPopup(); // re-renders dynamic content safely
                        // Also reload the station image (band may have changed or fallback needed)
                        const callsignMatch = layer.options.title?.match(/^[A-Z0-9/]+/);
                        if (callsignMatch) {
                            const sanitized = sanitizeCallsign(callsignMatch[0]);
                            setTimeout(() => loadStationImage(sanitized), 100);
                        }
                    }
                }
            });
        });

                                                window.addEventListener('load', () => {
                                                    // 1. Very early  force correct band selection (helps Safari especially)
                                                    const bandSelect = document.getElementById('bandSelect');
                                                    const savedBand = localStorage.getItem('emeObserverLastBand');
                                                    
                                                    let initialBand = '10GHz'; // default fallback
                                                    
                                                    if (savedBand && bandConfig[savedBand]) {
                                                        initialBand = savedBand;
                                                        bandSelect.value = savedBand;           //  force it NOW
                                                    } else {
                                                        bandSelect.value = '10GHz';
                                                    }

                                                    // Immediately set the frequency according to chosen band
                                                    FREQUENCY_HZ = bandConfig[initialBand].frequency;

                                                    // 2. Initialize map (this takes time anyway)
                                                    initMap();

                                                    // 3. Set current date & time
                                                    const now = new Date();
                                                    const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                                    document.getElementById('date').valueAsDate = utcDate;
                                                    document.getElementById('date').value = utcDate.toISOString().slice(0,10);

                                                    let roundedHour = now.getUTCHours();
                                                    let roundedMinutes = Math.round(now.getUTCMinutes() / 5) * 5;
                                                    if (roundedMinutes >= 60) {
                                                        roundedMinutes = 0;
                                                        roundedHour += 1;
                                                    }
                                                    if (roundedHour >= 24) {
                                                        roundedHour -= 24;
                                                        utcDate.setUTCDate(utcDate.getUTCDate() + 1);
                                                        document.getElementById('date').valueAsDate = utcDate;
                                                        document.getElementById('date').value = utcDate.toISOString().slice(0,10);
                                                    }

                                                    hourIndex = roundedHour * 12 + (roundedMinutes / 5);
                                                    document.getElementById('hour').value = hourIndex;
                                                    document.getElementById('hour-value').textContent =
                                                        `UTC: ${String(roundedHour).padStart(2, '0')}:${String(roundedMinutes).padStart(2, '0')}`;

                                                    document.getElementById('showControlsPanel').classList.remove('visible');

                                                    // Ensure real-time is off at start
                                                    isRealTimeMode = false;
                                                    document.getElementById('realTimeButton').classList.remove('active');
                                                    document.getElementById('realTimeButton').textContent = 'Track';

                                                    // 4. Now load stations for the chosen band
                                                    const jsonFile = bandConfig[initialBand].jsonFile;

                                                    fetch(jsonFile)
                                                        .then(response => {
                                                            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                                                            return response.json();
                                                        })
                                                        .then(data => {
                                                            updateMarkers(data, isActiveStationsOnly);

                                                            // 5. Only now restore QTH (needs map + markers ready)
                                                            const savedQTH = localStorage.getItem('emeObserverLastQTH');
                                                            if (savedQTH && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(savedQTH)) {
                                                                document.getElementById('qth').value = savedQTH;
                                                                
                                                                const dateStr = document.getElementById("date").value;
                                                                computeLibrationForDay(savedQTH, dateStr, 'qth');
                                                                computeFullDayData(qthDayData, savedQTH, dateStr, true);

                                                                const {lat, lon} = qthToLatLon(savedQTH);
                                                                qthMarker = L.marker([lat, lon], { zIndexOffset: 1000 })
                                                                    .addTo(map)
                                                                    .bindPopup(`My Locator: ${savedQTH}`);
                                                            }

                                                            // 6. Final visual & data update
                                                            const currentNow = new Date();
                                                            updateMap(currentNow);
                                                            updateMoonChart(currentNow);
                                                            updateChart(hourIndex, false);
                                                        })
                                                        .catch(error => {
                                                            console.error("Critical startup fetch failed:", error);
                                                            // You could show user message here if you want
                                                        });
                                                });
            
        window.addEventListener('unload', () => {
          stopRealTimeUpdates();
        });

        const qthInputElem = document.getElementById("qth");
        const dxInputElem = document.getElementById("dx");

        function getCurrentIndex() {
          if (isRealTimeMode) {
            const now = new Date();
            const hour = now.getUTCHours();
            const minute = now.getUTCMinutes();
            return hour * 12 + (minute / 5);
          } else {
            return hourIndex;
          }
        }

                                                qthInputElem.addEventListener("input", () => {
                                                    const locator = qthInputElem.value.trim().toUpperCase();
                                                    const chartLabel = document.getElementById('chartLabel');

                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                        // Save valid locator to localStorage
                                                        localStorage.setItem('emeObserverLastQTH', locator);

                                                        chartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                        try {
                                                            computeLibrationForDay(locator, document.getElementById("date").value, 'qth');
                                                            computeFullDayData(qthDayData, locator, document.getElementById("date").value, true);
                                                            relDayData.date = null; // Force relative chart recompute if needed
                                                            if (qthDayData.libration.length === 0) {
                                                                console.warn(`No data computed for QTH ${locator}`);
                                                                document.getElementById("chartWrapper").style.display = "none";
                                                                if (chart) { chart.destroy(); chart = null; }
                                                                chartLabel.innerHTML = '<span class="metric-locator">No data for QTH</span>';
                                                            } else {
                                                                setTimeout(() => updateChart(getCurrentIndex(), isRealTimeMode), 0);
                                                            }
                                                        } catch (e) {
                                                            console.error(`Error computing libration for QTH ${locator}: ${e.message}`);
                                                            document.getElementById("chartWrapper").style.display = "none";
                                                            if (chart) { chart.destroy(); chart = null; }
                                                            chartLabel.innerHTML = '<span class="metric-locator">Error computing QTH data</span>';
                                                        }

                                                        const {lat, lon} = qthToLatLon(locator);
                                                        if (qthMarker) {
                                                            qthMarker.setLatLng([lat, lon]);
                                                        } else {
                                                            qthMarker = L.marker([lat, lon]).addTo(map).bindPopup(`My Locator: ${locator}`);
                                                        }
                                                    } else {
                                                        // Only remove from storage if field is cleared (optional  keeps last good one otherwise)
                                                        // Comment out next line if you want to keep last valid even after clearing
                                                        localStorage.removeItem('emeObserverLastQTH');

                                                        document.getElementById("chartWrapper").style.display = "none";
                                                        if (chart) { chart.destroy(); chart = null; }
                                                        relDayData.date = null;
                                                        chartLabel.innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
                                                        if (qthMarker) { qthMarker.remove(); qthMarker = null; }

                                                        updateChart(getCurrentIndex(), isRealTimeMode);
                                                    }
                                                    setTimeout(updateQthPopup, 0);
                                                    setTimeout(updateDxPopup, 0);
                                                });

        dxInputElem.addEventListener("input", () => {
            const locator = dxInputElem.value.trim().toUpperCase();
            const dxChartLabel = document.getElementById('dxchartLabel');
            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                dxChartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                try {
                    computeLibrationForDay(locator, document.getElementById("date").value, 'dx');
                    computeFullDayData(dxDayData, locator, document.getElementById("date").value, false);
                    // Invalidate relDayData to force recompute
                    relDayData.date = null;
                    if (dxDayData.libration.length === 0) {
                        console.warn(`No data computed for DX ${locator}`);
                        document.getElementById("dxChartWrapper").style.display = "none";
                        if (dxChart) {
                            dxChart.destroy();
                            dxChart = null;
                        }
                        dxChartLabel.innerHTML = '<span class="metric-locator">No data for DX</span>';
                    } else {
                        setTimeout(() => {
                            updateChart(getCurrentIndex(), isRealTimeMode);
                        }, 0);
                    }
                } catch (e) {
                    console.error(`Error computing libration for DX ${locator}: ${e.message}`);
                    document.getElementById("dxChartWrapper").style.display = "none";
                    if (dxChart) {
                        dxChart.destroy();
                        dxChart = null;
                    }
                    dxChartLabel.innerHTML = '<span class="metric-locator">Error computing DX data</span>';
                }
                const {lat, lon} = qthToLatLon(locator);
                if (dxMarker) {
                    dxMarker.setLatLng([lat, lon]);
                } else {
                    dxMarker = L.marker([lat, lon])
                        .addTo(map)
                        .bindPopup(`DX Locator: ${locator}`);
                }
                setTimeout(updateDxPopup, 0);
            } else {
                document.getElementById("dxChartWrapper").style.display = "none";
                if (dxChart) {
                    dxChart.destroy();
                    dxChart = null;
                }
                // Invalidate relDayData when DX is invalid
                relDayData.date = null;
                document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
                if (dxMarker) {
                    dxMarker.remove();
                    dxMarker = null;
                }

                // FIX: force relative chart to hide when DX locator is cleared/invalid
                updateChart(getCurrentIndex(), isRealTimeMode);
            }
        });

        function qthToLatLon(locator) {
            if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
                throw new Error("Invalid QTH locator format (must be 6 characters)");
            }
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
            const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
            return { lat, lon };
        }

        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }
        function calcPoloffset(latDeg, azMoonDeg, elMoonDeg) {
            const lat = degToRad(latDeg);
            const az = degToRad(azMoonDeg);
            const el = degToRad(elMoonDeg);

        const xx = Math.sin(lat) * Math.cos(el) - Math.cos(lat) * Math.cos(az) * Math.sin(el);
        const yy = Math.cos(lat) * Math.sin(az);

        let angleRad = Math.atan2(yy, xx);
        return radToDeg(angleRad);
    }

    function calcPoloffsetDiff(pol1, pol2) {
        let diff = (pol2 - pol1 + 720) % 180;
        if (diff > 90) diff -= 180;
        return diff;
    }
    function sanitizeCallsign(callsign) {
        return callsign.replace(/\//g, '_');
    }
    
    document.getElementById("toggleControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (!controls.classList.contains("folded")) {
            controls.classList.add("folded");
            toggleButton.style.display = "none";
            showButton.classList.add("visible");
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight;
                showButton.style.display = 'flex';
            }, 0);
        }
    });

    document.getElementById("showControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (controls.classList.contains("folded")) {
            controls.classList.remove("folded");
            toggleButton.style.display = "block";
            showButton.classList.remove("visible");
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight;
            }, 0);
            if (chart) chart.resize();
            if (dxChart) dxChart.resize();
            if (relativeChart) relativeChart.resize();
            if (moonChart) moonChart.resize();
        }
    });

    // New function to compute all popup data for a locator and date
    function getLocatorInfo(locator, dateStr) {
        if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
            return { error: 'Invalid locator' };
        }

        const { lat, lon } = qthToLatLon(locator);
        const observer = new Astronomy.Observer(lat, lon, 0);
        const jsDate = new Date(`${dateStr}T00:00:00Z`);
        const astroTime = Astronomy.MakeTime(jsDate);

        // Day of the week and date
        const dayOfWeek = jsDate.toLocaleString('en-US', { weekday: 'long', timeZone: 'UTC' });
        const formattedDate = jsDate.toISOString().slice(0, 10);

        // Moonrise/Moonset
        let moonrise = 'N/A', moonset = 'N/A';
        try {
            const moonRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
            const moonSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
            if (moonRiseEvent && moonRiseEvent.date) {
                moonrise = formatTimeUTC(moonRiseEvent.date);
            }
            if (moonSetEvent && moonSetEvent.date) {
                moonset = formatTimeUTC(moonSetEvent.date);
            }
        } catch (e) {
            console.warn(`Error calculating moon times for ${locator} on ${dateStr}: ${e.message}`);
        }

        // Sunrise/Sunset
        let sunrise = 'N/A', sunset = 'N/A';
        try {
            const sunRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, +1, astroTime, 1.0);
            const sunSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Sun, observer, -1, astroTime, 1.0);
            if (sunRiseEvent && sunRiseEvent.date) {
                sunrise = formatTimeUTC(sunRiseEvent.date);
            }
            if (sunSetEvent && sunSetEvent.date) {
                sunset = formatTimeUTC(sunSetEvent.date);
            }
        } catch (e) {
            console.warn(`Error calculating sun times for ${locator} on ${dateStr}: ${e.message}`);
        }

        return { dayOfWeek, formattedDate, moonrise, moonset, sunrise, sunset };
    }

    // Reuse your existing formatTimeUTC (or add if not present)
    function formatTimeUTC(date) {
        return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
    }

                                                function getMoonPhaseInfo(currentTime) {
                                                    const astroTime = Astronomy.MakeTime(currentTime);

                                                    const illum = Astronomy.Illumination(Astronomy.Body.Moon, astroTime);
                                                    const lib   = Astronomy.Libration(astroTime);

                                                    // Illumination percentage
                                                    const illuminationPct = (illum.phase_fraction * 100).toFixed(1);

                                                    // Phase angle (SunMoonEarth): ~180 new  ~0 full
                                                    const phaseAngle = illum.phase_angle.toFixed(1);

                                                    // TRUE orbital phase angle from New Moon (0360)
                                                    const moonPhaseDeg = Astronomy.MoonPhase(astroTime);

                                                    // Normalized orbital phase (01)
                                                    const phaseValue = (moonPhaseDeg / 360).toFixed(3);

                                                    // -------- CORRECT PHASE NAME LOGIC --------
                                                    const eps = 12; // degrees tolerance (~1 day)
                                                    let phaseName;

                                                    if (moonPhaseDeg < eps || moonPhaseDeg > 360 - eps) {
                                                        phaseName = "New Moon";
                                                    }
                                                    else if (Math.abs(moonPhaseDeg - 90) < eps) {
                                                        phaseName = "First Quarter";
                                                    }
                                                    else if (Math.abs(moonPhaseDeg - 180) < eps) {
                                                        phaseName = "Full Moon";
                                                    }
                                                    else if (Math.abs(moonPhaseDeg - 270) < eps) {
                                                        phaseName = "Last Quarter";
                                                    }
                                                    else if (moonPhaseDeg < 90) {
                                                        phaseName = "Waxing Crescent";
                                                    }
                                                    else if (moonPhaseDeg < 180) {
                                                        phaseName = "Waxing Gibbous";
                                                    }
                                                    else if (moonPhaseDeg < 270) {
                                                        phaseName = "Waning Gibbous";
                                                    }
                                                    else {
                                                        phaseName = "Waning Crescent";
                                                    }
                                                    // -----------------------------------------

                                                    // Apparent angular diameter (degrees)
                                                    const moonRadiusKm = 1737.4;
                                                    const distKm = lib.dist_km;

                                                    const angularDiameterDeg =
                                                        (2 * Math.atan(moonRadiusKm / distKm)) * (180 / Math.PI);

                                                    return {
                                                        angularDiameter: angularDiameterDeg.toFixed(3),
                                                        illumination: illuminationPct,
                                                        phaseValue: phaseValue,
                                                        phaseName: phaseName,
                                                        phaseAngle: phaseAngle
                                                    };
                                                }


                                                
                                                                                function updateQthPopup() {
                                                                                    if (!qthMarker) return;
                                                                                    
                                                                                    const locator = document.getElementById('qth').value.trim().toUpperCase();
                                                                                    const dateStr = document.getElementById('date').value;

                                                                                    const info = getLocatorInfo(locator, dateStr);
                                                                                    if (info.error) {
                                                                                        qthMarker.bindPopup(`My Locator: ${locator} (Invalid)`);
                                                                                        return;
                                                                                    }

                                                                                    // Use the exact current time (same as used for charts/map)
                                                                                    const isRealtime = document.getElementById('realTimeButton').classList.contains('active');
                                                                                    const exactTime = isRealtime ? new Date() : new Date(`${dateStr}T${Math.floor(hourIndex / 12).toString().padStart(2, '0')}:${String((hourIndex % 12) * 5).padStart(2, '0')}:00Z`);

                                                                                    const moonInfo = getMoonPhaseInfo(exactTime);

                                                                                    let topoDist = null;
                                                                                    let extraLoss = null;
                                                                                    const minDist = 353352.93;

                                                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                                                        try {
                                                                                            const { lat, lon } = qthToLatLon(locator);
                                                                                            const observer = new Astronomy.Observer(lat, lon, 0);  // height 0 m is fine for this
                                                                                            const time = Astronomy.MakeTime(exactTime);

                                                                                            // Geocentric Moon vector (apparent, with aberration)
                                                                                            const geoMoon = Astronomy.GeoVector(Astronomy.Body.Moon, time, true);

                                                                                            // Vector from Earth center to observer (with aberration)
                                                                                            const obsVec = Astronomy.ObserverVector(time, observer, true);

                                                                                            // Topocentric vector: observer  Moon
                                                                                            const topoVecX = geoMoon.x - obsVec.x;
                                                                                            const topoVecY = geoMoon.y - obsVec.y;
                                                                                            const topoVecZ = geoMoon.z - obsVec.z;

                                                                                            topoDist = Math.sqrt(topoVecX*topoVecX + topoVecY*topoVecY + topoVecZ*topoVecZ) * Astronomy.KM_PER_AU;

                                                                                            if (topoDist > 0) {
                                                                                                extraLoss = Math.max(0, 40 * Math.log10(topoDist / minDist));
                                                                                            }
                                                                                        } catch (e) {
                                                                                            console.warn("Error calculating topocentric distance:", e);
                                                                                        }
                                                                                    }

                                                                                    const moonIcon = `
                                                                                      <svg width="14" height="14" viewBox="0 0 24 24" style="vertical-align:middle;">
                                                                                        <path fill="currentColor" d="M12 2a9.93 9.93 0 0 0-7.06 2.94A10 10 0 1 0 22 12c0-.34-.02-.67-.05-1a8 8 0 0 1-9.95-9z"/>
                                                                                      </svg>
                                                                                    `;

                                                                                    const popupContent = `
                                                                                      My Locator: ${locator}<br>
                                                                                      <div style="height:4px"></div>
                                                                                      ${info.dayOfWeek} ${info.formattedDate}<br>
                                                                                      <div style="height:8px"></div>
                                                                                      <strong>Moon Data ${moonIcon}</strong><br>
                                                                                      Phase: ${moonInfo.phaseName} (${moonInfo.phaseValue})<br>
                                                                                      Illumination: ${moonInfo.illumination}%<br>
                                                                                      Phase angle: ${moonInfo.phaseAngle}<br>
                                                                                      Apparent diameter: ${moonInfo.angularDiameter}<br>
                                                                                      <div style="height:4px"></div>
                                                                                      <strong>Topocentric Data</strong><br>
                                                                                      Dist: ${topoDist != null ? topoDist.toFixed(0) + ' km' : 'N/A'}<br>
                                                                                      Extra Loss: ${extraLoss != null ? extraLoss.toFixed(2) + ' dB' : 'N/A'}<br>
                                                                                    `;

                                                                                    // If popup is currently open, update its content directly
                                                                                    if (qthMarker.getPopup() && qthMarker.isPopupOpen()) {
                                                                                        qthMarker.getPopup().setContent(popupContent);
                                                                                    } else {
                                                                                        qthMarker.bindPopup(popupContent);
                                                                                    }

                                                                                }
                                            
                                            function updateDxPopup() {
                                                if (!dxMarker) return;

                                                const locator = document.getElementById('dx').value.trim().toUpperCase();
                                                const dateStr = document.getElementById('date').value;

                                                if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                    dxMarker.bindPopup(`DX Locator: ${locator} (invalid)`);
                                                    return;
                                                }

                                                const qthLoc = document.getElementById('qth').value.trim().toUpperCase();
                                                const windows = getCommonWindows(qthLoc, locator, dateStr);

                                                const moonIcon = `<svg width="14" height="14" viewBox="0 0 24 24" style="vertical-align:middle;">
                                                                    <path fill="currentColor" d="M12 2a9.93 9.93 0 0 0-7.06 2.94A10 10 0 1 0 22 12c0-.34-.02-.67-.05-1a8 8 0 0 1-9.95-9z"/>
                                                                  </svg>`;

                                                // --------------------------------------------------
                                                // Helper: adds (-1) or (+1) when crossing midnight
                                                // --------------------------------------------------
                                                const baseDate = new Date(`${dateStr}T00:00:00Z`);
                                                const baseDay = baseDate.getUTCDate();

                                                function suffixFor(dateObj) {
                                                    const d = dateObj.getUTCDate();
                                                    if (d === baseDay) return "";      // same day
                                                    if (d === baseDay + 1 || (baseDay === 31 && d === 1)) return "(+1)";
                                                    if (d === baseDay - 1 || (baseDay === 1 && d >= 28)) return "(-1)";
                                                    // Fallback for month rollover in both directions
                                                    return d > baseDay ? "(+1)" : "(-1)";
                                                }
                                                // --------------------------------------------------

                                                let windowsHTML = '';
                                                if (windows.length === 0) {
                                                    windowsHTML = '<div>No common moon window today</div>';
                                                } else {
                                                    windows.forEach((w, i) => {
                                                        const start = formatTimeUTC(w.start);
                                                        const end   = formatTimeUTC(w.end);

                                                        const startSuffix = suffixFor(w.start);
                                                        const endSuffix   = suffixFor(w.end);

                                                        windowsHTML += `<div>${moonIcon} Window ${i+1}: ${start}${startSuffix}  ${end}${endSuffix}</div>`;
                                                    });
                                                }

                                                const jsDate = new Date(`${dateStr}T00:00:00Z`);
                                                const dayOfWeek = jsDate.toLocaleString('en-US', {weekday:'long', timeZone:'UTC'});

                                                const popupContent = `
                                                    DX Locator: ${locator}<br>
                                                    <div style="height:4px"></div>
                                                    ${dayOfWeek} ${dateStr}<br>
                                                    <div style="height:8px"></div>
                                                    <strong>Common Moon Windows</strong><br>
                                                    ${windowsHTML}
                                                    <div style="font-size:11px; color:#666; font-style:italic;">
                                                      (-1) and (+1) indicate the previous and next UTC day, respectively.
                                                    </div>
                                                `;

                                                dxMarker.bindPopup(popupContent);
                                            }
                                                function loadStationImage(sanitizedCallsign) {
                                                    const imageElement = document.getElementById(`station-image-${sanitizedCallsign}`);
                                                    const imageLink = document.getElementById(`image-link-${sanitizedCallsign}`);
                                                    const placeholder = document.getElementById(`image-placeholder-${sanitizedCallsign}`);

                                                    if (!imageElement || !imageLink || !placeholder) return;

                                                    const currentBand = document.getElementById('bandSelect').value;

                                                    fetch(`db/${sanitizedCallsign}_thumb-${currentBand}.jpg`, { method: 'HEAD' })
                                                        .then(response => {
                                                            if (response.ok) {
                                                                imageElement.src = `db/${sanitizedCallsign}_thumb-${currentBand}.jpg`;
                                                                imageLink.href = `db/${sanitizedCallsign}-${currentBand}.jpg`;
                                                                placeholder.style.display = 'none';
                                                            } else {
                                                                // Fallback to generic image
                                                                return fetch(`db/${sanitizedCallsign}_thumb.jpg`, { method: 'HEAD' });
                                                            }
                                                        })
                                                        .then(response => {
                                                            if (response === undefined) {
                                                                // Band-specific succeeded  do nothing more (prevents accidental removal)
                                                                return;
                                                            }
                                                            if (response.ok) {
                                                                imageElement.src = `db/${sanitizedCallsign}_thumb.jpg`;
                                                                imageLink.href = `db/${sanitizedCallsign}.jpg`;
                                                                placeholder.style.display = 'none';
                                                            } else {
                                                                imageElement.remove();
                                                                placeholder.style.display = 'block';
                                                            }
                                                        })
                                                        .catch(() => {
                                                            imageElement.remove();
                                                            placeholder.style.display = 'block';
                                                        });
                                                }

</script>
<script>
    // Close VHF notice when user clicks  (only for current page session)
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('close-notice')) {
            const notice = document.getElementById('vhfNotice');
            if (notice) {
                notice.classList.remove('visible');
            }
        }
    });
</script>
<div id="vhfNotice" class="vhf-notice">
    <button class="close-notice" aria-label="Close notice"></button>
    <p><strong>Note:</strong> The database for 144 MHz is still in the early stages of development. Please
       <a href="https://dxer.site/eme-observer/datasubmission.html" target="_blank" rel="noopener">submit your corrections and additions</a>.</p>
</div>
<!-- Ko-Fi -->
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script src="/kofi.js"></script>
<!-- 100% privacy-first analytics -->
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
