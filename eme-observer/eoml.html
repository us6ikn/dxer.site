<!DOCTYPE html>
<html lang="en">
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-7YST3WTEH3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-7YST3WTEH3');
        </script>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
            <title id="pageTitle">EME Observer - EME Station Map & EME QSO Planner</title>
                <meta name="description" id="metaDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked." />
                <meta name="keywords" content="EME, Moonbounce, Ham Radio, Amateur Radio, 10GHz, DX Map, Moon Tracking, Doppler Spread, Polarization Offset, Sublunar Point, Moon Azimuth, Moon Declination, Signal Loss, Libration, Moon Footprint, Moon Elevation" />
                <meta name="author" content="SA5IKN">
                    <meta name="robots" content="index, follow">
                        <meta property="og:title" id="ogTitle" content="EME Observer - EME Station Map & EME QSO Planner">
                            <meta property="og:type" content="website">
                                <meta property="og:description" id="ogDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked.">
                                    <meta property="og:image" content="https://dxer.site/social/eme-observer.jpg">
                                        <meta property="og:url" content="https://dxer.site/eme-observer/">
                                            <meta name="twitter:card" content="summary_large_image">
                                                <meta name="twitter:title" id="twitterTitle" content="EME Observer - EME Station Map & EME QSO Planner" />
                                                <meta name="twitter:description" id="twitterDescription" content="EME Observer is an Earth-Moon-Earth station map and QSO planner, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked." />
                                                <meta name="twitter:image" content="https://dxer.site/social/eme-observer.jpg" />
                                                <link rel="canonical" href="https://dxer.site/eme-observer/" />
                                                <!-- Favicon and App Icons -->
                                                <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
                                                    <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
                                                        <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
                                                            <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
                                                                <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
                                                                    <script type="application/ld+json">
                                                                        {
                                                                            "@context": "https://schema.org",
                                                                            "@type": "WebApplication",
                                                                            "name": "EME Observer",
                                                                            "url": "https://dxer.site/eme-observer/",
                                                                            "author": {
                                                                                "@type": "Person",
                                                                                "name": "SA5IKN"
                                                                            },
                                                                            "description": "EME Observer is an Earth-Moon-Earth station map and QSO planner, offering realtime moon tracking, lunar ephemeris, Dpol, libration rate, and path loss charts to plan your sked.",
                                                                            "applicationCategory": "Science",
                                                                            "operatingSystem": "All",
                                                                            "browserRequirements": "Requires JavaScript",
                                                                            "inLanguage": "en",
                                                                            "applicationSubCategory": "Amateur Radio Application",
                                                                            "offers": {
                                                                                "@type": "Offer",
                                                                                "price": "0.00",
                                                                                "priceCurrency": "USD"
                                                                            }
                                                                        }
                                                                    </script>
                                                                    <link rel="stylesheet" href="/leaflet/leaflet.css" />
                                                                        <!-- Move leaflet.js before dependent scripts -->
                                                                        <script src="/leaflet/leaflet.js"></script>
                                                                        <script src="https://unpkg.com/leaflet.vectorgrid@latest/dist/Leaflet.VectorGrid.js"></script>
                                                                        <script src="https://cdn.jsdelivr.net/npm/text-image/dist/text-image.js"></script>
                                                                        <script src="https://ha8tks.github.io/Leaflet.CQzones/src/L.CQzones.js"></script>
                                                                        <script src="https://ha8tks.github.io/Leaflet.Maidenhead/src/L.Maidenhead.js"></script>
                                                                        <script src="a.ob.js"></script>
                                                                    <style>
                                                                        html, body {
                                                                            margin: 0;
                                                                            padding: 0;
                                                                            height: 100%;
                                                                            overflow: hidden;
                                                                            font-family: Arial, sans-serif;
                                                                        }
                                                                        
                                                                        #chartWrapper, #dxChartWrapper, #relativeChartWrapper, #moonChartWrapper {
                                                                            width: 100%;
                                                                            max-width: 600px;
                                                                            height: 180px;
                                                                            margin-top: 6px;
                                                                            background-color: rgba(255, 255, 255, 0.85);
                                                                            border-radius: 6px;
                                                                            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
                                                                            overflow: hidden;
                                                                            position: relative;
                                                                            box-sizing: border-box;
                                                                            display: none;
                                                                        }
                                                                        
                                                                        #declinationChart, #dxDeclinationChart, #relativeDataChart, #moonDistanceChart {
                                                                            width: 100%;
                                                                            height: calc(100% - 20px);
                                                                            box-sizing: border-box;
                                                                        }
                                                                        
                                                                        #moonChartWrapper {
                                                                            display: block;
                                                                        }
                                                                        
                                                                        #moonDistanceChart {
                                                                            height: calc(100% - 40px);
                                                                            padding-bottom: 20px;
                                                                        }
                                                                        
                                                                        #chartLabel, #dxchartLabel, #relativeChartLabel, #moonChartLabel {
                                                                            text-align: center;
                                                                            margin-bottom: 0px;
                                                                            font-weight: normal;
                                                                            font-size: 11px;
                                                                            font-family: 'Arial, sans-serif';
                                                                            white-space: nowrap;
                                                                            overflow: hidden;
                                                                            text-overflow: ellipsis;
                                                                            max-width: 100%;
                                                                            padding: 2px 0;
                                                                        }
                                                                        
                                                                        #map {
                                                                            height: 100dvh;
                                                                            width: 100%;
                                                                            z-index: 0;
                                                                        }
                                                                        
                                                                        #controls {
                                                                            position: absolute;
                                                                            top: 10px;
                                                                            left: 10px;
                                                                            z-index: 5;
                                                                            background-color: rgba(255, 255, 255, 0.95);
                                                                            padding: 12px;
                                                                            border-radius: 8px;
                                                                            max-width: 95vw;
                                                                            max-height: 90vh;
                                                                            display: flex;
                                                                            flex-direction: column;
                                                                            box-sizing: border-box;
                                                                            transition: transform 0.3s ease;
                                                                        }
                                                                        
                                                                        #fixed-controls {
                                                                            position: sticky;
                                                                            top: 0;
                                                                            z-index: 10;
                                                                            background-color: inherit;
                                                                            padding-bottom: 10px;
                                                                            display: flex;
                                                                            flex-direction: column;
                                                                            gap: 10px;
                                                                        }
                                                                        
                                                                        #scrollable-controls {
                                                                            flex: 1;
                                                                            overflow-y: auto;
                                                                            max-height: calc(90vh - 180px); /* Adjusted for inline locators */
                                                                            padding-right: 5px;
                                                                        }
                                                                        
                                                                        #scrollable-controls::-webkit-scrollbar {
                                                                            width: 6px;
                                                                        }
                                                                        
                                                                        #scrollable-controls::-webkit-scrollbar-thumb {
                                                                            background-color: rgba(0, 123, 255, 0.5);
                                                                            border-radius: 3px;
                                                                        }
                                                                        
                                                                        #scrollable-controls::-webkit-scrollbar-track {
                                                                            background: transparent;
                                                                        }
                                                                        
                                                                        label {
                                                                            font-weight: bold;
                                                                            font-size: 14px;
                                                                        }
                                                                        
                                                                        #hour-value {
                                                                            margin-left: 10px;
                                                                            font-weight: normal;
                                                                        }
                                                                        
                                                                        #hour {
                                                                            width: 100%;
                                                                            margin-top: 5px;
                                                                            -webkit-appearance: none;
                                                                            appearance: none;
                                                                            height: 10px;
                                                                            background: rgba(0, 0, 0, 0.1);
                                                                            border-radius: 5px;
                                                                            outline: none;
                                                                            transition: background 0.3s ease;
                                                                            padding: 0;
                                                                        }
                                                                        
                                                                        #hour::-webkit-slider-thumb {
                                                                            -webkit-appearance: none;
                                                                            appearance: none;
                                                                            width: 20px;
                                                                            height: 20px;
                                                                            background: #007bff;
                                                                            border-radius: 50%;
                                                                            cursor: pointer;
                                                                        }
                                                                        
                                                                        #hour::-moz-range-thumb {
                                                                            width: 20px;
                                                                            height: 20px;
                                                                            background: #007bff;
                                                                            border-radius: 50%;
                                                                            cursor: pointer;
                                                                        }
                                                                        
                                                                        #hour:active {
                                                                            background: rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        #hour-container {
                                                                            position: relative;
                                                                            width: 100%;
                                                                            height: 40px;
                                                                            margin-top: 10px;
                                                                            padding: 5px 0;
                                                                        }
                                                                        
                                                                        #date-container {
                                                                            display: flex;
                                                                            align-items: center;
                                                                            justify-content: center;
                                                                            flex-wrap: wrap;
                                                                            gap: 5px;
                                                                            margin-top: 10px;
                                                                        }
                                                                        
                                                                        input[type="date"] {
                                                                            width: auto;
                                                                            max-width: 200px;
                                                                        }
                                                                        
                                                                        .app-name-wrapper {
                                                                            display: flex;
                                                                            flex-direction: column;
                                                                            align-items: flex-end;
                                                                            position: relative;
                                                                        }
                                                                        
                                                                        .creator-label {
                                                                            font-size: 10px;
                                                                            color: #555;
                                                                            font-style: italic;
                                                                            margin-bottom: -4px;
                                                                        }
                                                                        
                                                                        .app-name {
                                                                            font-size: 1.0rem;
                                                                            font-weight: bold;
                                                                            color: #2c3e50;
                                                                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                                                                        }
                                                                        
                                                                        .ghz-label {
                                                                            font-size: 10px;
                                                                            font-weight: bold;
                                                                            color: #2c3e50;
                                                                            margin-top: -4px;
                                                                        }
                                                                        
                                                                        #toggleMoonChart {
                                                                            font-size: 12px;
                                                                            padding: 4px 8px;
                                                                            background-color: #007bff;
                                                                            color: white;
                                                                            border: none;
                                                                            border-radius: 4px;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease;
                                                                        }
                                                                        
                                                                        #toggleMoonChart:hover {
                                                                            background-color: #0056b3;
                                                                        }
                                                                        
                                                                        #toggleMoonChart:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        #toggleControlsPanel {
                                                                            padding: 2px 3px;
                                                                            background-color: rgba(255, 255, 255, 0.3);
                                                                            color: #2c3e50;
                                                                            border: 1px solid rgba(0, 123, 255, 0.4);
                                                                            border-radius: 2px;
                                                                            font-size: 10px;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
                                                                            text-decoration: none;
                                                                            display: flex;
                                                                            align-items: center;
                                                                            justify-content: center;
                                                                            line-height: 1;
                                                                        }
                                                                        
                                                                        #toggleControlsPanel:hover {
                                                                            background-color: rgba(255, 255, 255, 0.5);
                                                                            color: #0056b3;
                                                                            border-color: rgba(0, 123, 255, 0.6);
                                                                        }
                                                                        
                                                                        #toggleControlsPanel:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        .locator-group {
                                                                            display: flex;
                                                                            gap: 10px;
                                                                            flex-wrap: wrap;
                                                                            align-items: center;
                                                                        }
                                                                        
                                                                        .locator-input {
                                                                            display: flex;
                                                                            align-items: center;
                                                                            gap: 5px;
                                                                        }
                                                                        
                                                                        .locator-input label {
                                                                            font-size: 12px;
                                                                            font-weight: normal;
                                                                        }
                                                                        
                                                                        .locator-input input {
                                                                            font-size: 12px;
                                                                            padding: 2px;
                                                                            border: 1px solid #ccc;
                                                                            border-radius: 3px;
                                                                        }
                                                                        
                                                                        .metric-label {
                                                                            font-weight: bold;
                                                                        }
                                                                        
                                                                        .metric-distance {
                                                                            color: #24a148;
                                                                        }
                                                                        
                                                                        .metric-declination {
                                                                            color: #ff832b;
                                                                        }
                                                                        
                                                                        .metric-pathloss {
                                                                            color: #24a148;
                                                                        }
                                                                        
                                                                        .metric-separator {
                                                                            color: #666;
                                                                            margin: 0 4px;
                                                                        }
                                                                        
                                                                        .metric-elevation {
                                                                            color: rgba(0, 0, 255, 0.6);
                                                                        }
                                                                        
                                                                        .metric-azimuth {
                                                                            color: #444;
                                                                        }
                                                                        
                                                                        .metric-libration {
                                                                            color: #ff0000;
                                                                        }
                                                                        
                                                                        .metric-doppler {
                                                                            color: green;
                                                                        }
                                                                        
                                                                        .metric-locator {
                                                                            color: #000;
                                                                            font-weight: bold;
                                                                        }
                                                                        
                                                                        .button-group-infowindow {
                                                                            display: flex;
                                                                            gap: 3px;
                                                                            margin-top: 6px;
                                                                            flex-wrap: wrap;
                                                                            justify-content: flex-start;
                                                                        }
                                                                        /* Ensure popup content is wide enough for images */
                                                                        .leaflet-popup-content {
                                                                            min-width: 275px !important; /* Slightly less than 300px to account for padding */
                                                                            max-width: 300px !important; /* Reinforce Leaflet's default max-width */
                                                                            box-sizing: border-box; /* Ensure padding is included in width calculations */
                                                                        }

                                                                        /* Style the image container to prevent overflow */
                                                                        #image-container {
                                                                            width: 100%; /* Ensure container spans full popup width */
                                                                            overflow: hidden; /* Prevent image from overflowing container */
                                                                            margin-top: 5px; /* Spacing above container */
                                                                        }

                                                                        /* Constrain images within the container */
                                                                        #image-container img {
                                                                            max-width: 100%; /* Fit within container */
                                                                            height: auto; /* Maintain aspect ratio */
                                                                            display: block; /* Prevent inline spacing issues */
                                                                            margin: 0 auto; /* Center the image */
                                                                        }
                                                                        .sked-button {
                                                                            font-size: 12px;
                                                                            padding: 2px 6px;
                                                                            margin-left: 5px;
                                                                            background-color: #28a745;
                                                                            color: white;
                                                                            border: none;
                                                                            border-radius: 3px;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease;
                                                                        }
                                                                        
                                                                        .sked-button:hover {
                                                                            background-color: #218838;
                                                                        }
                                                                        
                                                                        .sked-button:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
                                                                        }
                                                                        
                                                                        .email-button {
                                                                            background-color: #27A9F5;
                                                                            color: white !important; /* Ensure white text */
                                                                            border: none;
                                                                            padding: 2px 6px;
                                                                            cursor: pointer;
                                                                            font-size: 12px;
                                                                            border-radius: 3px;
                                                                            margin-left: 5px;
                                                                            text-decoration: none;
                                                                            transition: background-color 0.3s ease;
                                                                        }
                                                                        
                                                                        .email-button:hover {
                                                                            background-color: #279CF5;
                                                                        }
                                                                        
                                                                        .email-button:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
                                                                        }
                                                                        
                                                                        .qrz-button {
                                                                            background-color: #fd7e14;
                                                                            color: white !important; /* Ensure white text */
                                                                            border: none;
                                                                            padding: 2px 6px;
                                                                            cursor: pointer;
                                                                            font-size: 12px;
                                                                            border-radius: 3px;
                                                                            margin-left: 5px;
                                                                            text-decoration: none;
                                                                            transition: background-color 0.3s ease;
                                                                        }
                                                                        
                                                                        .qrz-button:hover {
                                                                            background-color: #e86c12; /* Darker orange on hover */
                                                                        }
                                                                        
                                                                        .qrz-button:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
                                                                        }
                                                                        
                                                                        .button-group {
                                                                            display: flex;
                                                                            gap: 3px;
                                                                            margin-top: 6px;
                                                                            flex-wrap: wrap;
                                                                            justify-content: center;
                                                                        }
                                                                        
                                                                        .nav-button {
                                                                            padding: 2px 3px;
                                                                            width: 60px; /* Fixed width to accommodate "Active" and "Statistics" */
                                                                            text-align: center; /* Center text to prevent layout shift */
                                                                            background-color: rgba(255, 255, 255, 0.3);
                                                                            color: #2c3e50;
                                                                            border: 1px solid rgba(0, 123, 255, 0.4);
                                                                            border-radius: 2px;
                                                                            font-size: 10px;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
                                                                            text-decoration: none;
                                                                            display: flex;
                                                                            align-items: center;
                                                                            justify-content: center;
                                                                            line-height: 1;
                                                                        }
                                                                        
                                                                        .nav-button:hover {
                                                                            background-color: rgba(255, 255, 255, 0.5);
                                                                            color: #0056b3;
                                                                            border-color: rgba(0, 123, 255, 0.6);
                                                                        }
                                                                        
                                                                        .nav-button:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        .nav-button.active {
                                                                            background-color: rgba(0, 123, 255, 0.2);
                                                                            font-weight: bold;
                                                                            border-color: rgba(0, 123, 255, 0.8);
                                                                        }
                                                                        
                                                                        .nav-button.icon-button {
                                                                            padding: 2px;
                                                                            font-size: 12px;
                                                                            width: 18px; /* Smaller width for icon buttons */
                                                                            height: 18px;
                                                                            display: flex;
                                                                            align-items: center;
                                                                            justify-content: center;
                                                                        }
                                                                        
                                                                        #controls.folded {
                                                                            transform: translateX(calc(-100% + 30px));
                                                                            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
                                                                        }
                                                                        
                                                                        #showControlsPanel {
                                                                            position: fixed;
                                                                            top: 30%;
                                                                            left: 35px;
                                                                            transform: translateY(-50%) scale(1);
                                                                            width: 24px;
                                                                            height: 24px;
                                                                            padding: 2px;
                                                                            background-color: rgba(255, 255, 255, 0.95);
                                                                            color: #2c3e50;
                                                                            border: 1px solid rgba(0, 123, 255, 0.4);
                                                                            border-radius: 4px;
                                                                            font-size: 12px;
                                                                            font-weight: bold;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
                                                                            display: none;
                                                                            align-items: center;
                                                                            justify-content: center;
                                                                            z-index: 1000;
                                                                            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
                                                                        }
                                                                        
                                                                        #showControlsPanel.visible {
                                                                            display: flex;
                                                                        }
                                                                        
                                                                        #showControlsPanel:hover {
                                                                            background-color: rgba(255, 255, 255, 1);
                                                                            color: #0056b3;
                                                                            border-color: rgba(0, 123, 255, 0.6);
                                                                            transform: translateY(-50%) scale(1.1);
                                                                        }
                                                                        
                                                                        #showControlsPanel:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        #showControlsPanel:not(.visible) {
                                                                            display: none !important;
                                                                        }
                                                                        
                                                                        @media (max-width: 600px) {
                                                                            #showControlsPanel {
                                                                                left: 32px;
                                                                                width: 20px;
                                                                                height: 20px;
                                                                                font-size: 10px;
                                                                                padding: 1px;
                                                                            }
                                                                            #controls {
                                                                                padding: 8px;
                                                                            }
                                                                            #fixed-controls {
                                                                                padding-bottom: 8px;
                                                                            }
                                                                            #scrollable-controls {
                                                                                max-height: calc(90vh - 160px);
                                                                            }
                                                                            .locator-input label {
                                                                                font-size: 10px;
                                                                            }
                                                                            .locator-input input {
                                                                                font-size: 10px;
                                                                                width: 80px;
                                                                            }
                                                                            .nav-button, #toggleControlsPanel {
                                                                                font-size: 8px;
                                                                                padding: 2px 3px;
                                                                                width: 50px; /* Slightly smaller width for mobile */
                                                                            }
                                                                            .nav-button.icon-button {
                                                                                font-size: 10px;
                                                                                width: 16px;
                                                                                height: 16px;
                                                                            }
                                                                        }
                                                                        
                                                                        .metric-rel-libration {
                                                                            color: red;
                                                                            font-weight: bold;
                                                                        }
                                                                        
                                                                        .metric-rel-doppler {
                                                                            color: green;
                                                                            font-weight: bold;
                                                                        }
                                                                        
                                                                        .metric-poloffset {
                                                                            color: blue;
                                                                            font-weight: bold;
                                                                        }
                                                                        .locator-input input[type="checkbox"] {
                                                                            margin-right: 5px;
                                                                            cursor: pointer;
                                                                        }
                                                                        
                                                                        .locator-input label[for="activeStations"] {
                                                                            font-size: 12px;
                                                                            font-weight: normal;
                                                                            cursor: pointer;
                                                                        }
                                                                        .band-select {
                                                                            font-size: 10px;
                                                                            font-weight: bold;
                                                                            color: #2c3e50;
                                                                            margin-top: -1px;
                                                                            padding: 2px;
                                                                            border: 1px solid #ccc;
                                                                            border-radius: 3px;
                                                                            background-color: #fff;
                                                                            cursor: pointer;
                                                                        }
                                                                        
                                                                        .band-select:focus {
                                                                            outline: none;
                                                                            border-color: #007bff;
                                                                            box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
                                                                        }
                                                                        
                                                                        /* Disabled styles for time slider and date controls */
                                                                        #hour:disabled {
                                                                            background: #ccc;
                                                                            cursor: not-allowed;
                                                                        }
                                                                        
                                                                        #hour:disabled::-webkit-slider-thumb {
                                                                            background: #999;
                                                                            cursor: not-allowed;
                                                                        }
                                                                        
                                                                        #hour:disabled::-moz-range-thumb {
                                                                            background: #999;
                                                                            cursor: not-allowed;
                                                                        }
                                                                        
                                                                        #date:disabled, #prevDay:disabled, #nextDay:disabled {
                                                                            background: #ccc;
                                                                            color: #999;
                                                                            cursor: not-allowed;
                                                                            opacity: 0.6;
                                                                        }
                                                                        .button-band-group {
                                                                            display: flex;
                                                                            align-items: center;
                                                                            gap: 5px;
                                                                            margin-top: -2px;
                                                                        }
                                                                        
                                                                        .auto-track-button {
                                                                            font-size: 10px; /* Smaller font size */
                                                                            padding: 1px 4px; /* Reduced padding */
                                                                            width: 40px; /* Fixed width to accommodate longest text */
                                                                            text-align: center; /* Center text to maintain alignment */
                                                                            background-color: #17a2b8;
                                                                            color: white;
                                                                            border: none;
                                                                            border-radius: 3px;
                                                                            cursor: pointer;
                                                                            transition: background-color 0.3s ease;
                                                                        }
                                                                        
                                                                        .auto-track-button:hover {
                                                                            background-color: #138496;
                                                                        }
                                                                        
                                                                        .auto-track-button:focus {
                                                                            outline: none;
                                                                            box-shadow: 0 0 3px rgba(23, 162, 184, 0.5);
                                                                        }
                                                                        
                                                                        .auto-track-button.active {
                                                                            background-color: #138496;
                                                                            font-weight: bold;
                                                                        }
                                                                        .metric-sun-sep {
                                                                            color: #ff832b; /* Yellow for Sun separation */
                                                                            font-weight: bold;
                                                                        }
                                                                        .metric-sgra-sep {
                                                                            color: #800080; /* Purple for Sgr A separation */
                                                                            font-weight: bold;
                                                                        }
                                                                        .leaflet-control-layers {
                                                                            background-color: rgba(255, 255, 255, 0.95);
                                                                            border-radius: 8px;
                                                                            padding: 10px;
                                                                            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
                                                                            font-family: 'Arial, sans-serif';
                                                                            font-size: 12px;
                                                                        }
                                                                        .leaflet-control-layers label {
                                                                            font-weight: normal;
                                                                            color: #2c3e50;
                                                                        }
                                                                        .leaflet-control-layers input[type="checkbox"] {
                                                                            margin-right: 5px;
                                                                        }
                                                                        .leaflet-control-layers-overlays {
                                                                            margin-top: 5px;
                                                                        }
                                                                        
                                                                    </style>
                                                                    
    <!-- Added for noise map -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    
    </head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div id="fixed-controls">
          <div id="date-container">
              <div class="app-name-wrapper">
                <div class="creator-label">by SA5IKN</div>
                <div class="app-name">EME Observer</div>
                <div class="button-band-group">
                  <button id="realTimeButton" class="auto-track-button">Track</button>
                  <select id="bandSelect" class="band-select">
                    <option value="432MHz">432MHz</option>
                    <option value="1296MHz">1296MHz</option>
                    <option value="2320MHz">2320MHz</option>
                    <option value="3400MHz">3400MHz</option>
                    <option value="5760MHz">5760MHz</option>
                    <option value="10GHz" selected>10GHz</option>
                    <option value="24GHz">24GHz</option>
                    <option value="47GHz">47GHz</option>
                    <option value="76GHz">76GHz</option>
                  </select>
                </div>
              </div>
            <button id="prevDay">←</button>
            <input type="date" id="date" />
            <button id="nextDay">→</button>
            <span id="hour-value">Time (UTC): 00:00</span>
          </div>
          <div class="button-group">
            <button id="activeStationsButton" class="nav-button">All</button>
            <a href="statistics.html" class="nav-button">Statistics</a>
            <a href="table.html" class="nav-button">Table</a>
            <a href="datasubmission.html" class="nav-button">Add Station</a>
            <a href="/" class="nav-button icon-button">🏠</a>
            <a href="user-guide.html" class="nav-button icon-button">?</a>
            <button id="toggleControlsPanel" class="nav-button">←</button>
          </div>
          <input type="range" id="hour" min="0" max="47" value="0" step="1" />
          <div class="locator-group">
            <div class="locator-input">
              <label for="qth">My Locator:</label>
              <input type="text" id="qth" maxlength="6" size="8" placeholder="eg JO89tt" />
            </div>
            <div class="locator-input">
              <label for="dx">DX Locator:</label>
              <input type="text" id="dx" maxlength="6" size="8" placeholder="eg IO91vm" />
            </div>
          </div>
        </div>
      <div id="scrollable-controls">
        <div id="chartWrapper" style="display: none;">
          <div id="chartLabel"></div>
          <canvas id="declinationChart"></canvas>
        </div>
        <div id="dxChartWrapper" style="display: none;">
          <div id="dxchartLabel"></div>
          <canvas id="dxDeclinationChart"></canvas>
        </div>
        <div id="relativeChartWrapper" style="display: none;">
          <div id="relativeChartLabel"></div>
          <canvas id="relativeDataChart"></canvas>
        </div>
        <div id="moonChartWrapper" style="display: block;">
          <div id="moonChartLabel"></div>
          <canvas id="moonDistanceChart"></canvas>
        </div>
      </div>
    </div>
    <button id="showControlsPanel" style="display: none;">→</button>
    
    <!-- Noise Map Container -->
    <div id="noiseMapContainer" style="display:none; position:fixed; top:10%; left:10%; width:80%; height:80%; background:rgba(255,255,255,0.95); border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,0.3); z-index:1000; overflow:hidden;"></div>
    
<script src="chart.js"></script>
<script src="chartjs-plugin-annotation@1.4.0"></script>
<script src="l.ob.js"></script>
<script src="/leaflet/Leaflet.greatCircle.js"></script>
<script>
    let chart;
    let dxChart;
    let relativeChart;
    let moonChart;
    let rawData = [];
    let dxRawData = [];
    let moonDataForMonth = [];
    let hourIndex = 0;
    let lat = 0;
    let lon = 0;
    let dxLat = 0;
    let dxLon = 0;
    let moonMarker;
    let footprintCircle;
    let currentInfoWindow = null;
    let map;
    let realTimeInterval = null; // Store the interval ID for real-time updates
    let isRealTimeMode = false; // Track real-time mode state
    let moonDayData = { date: null, data: [], labels: [] };

    // NEW: Caches for day data to avoid recompute
    let qthDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
    let dxDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
    let relDayData = { date: null, libration: [], dopplers: [], polOffsets: [] };

    const MOON_RADIUS = 1.7374e6;
    const SPEED_OF_LIGHT = 299792458;
    
    // Define band frequencies and display names
    const bandConfig = {
    '432MHz': { frequency: 0.432e9, display: '432 MHz', jsonFile: 'stn_432MHz.json' },
      '1296MHz': { frequency: 1.296e9, display: '1296 MHz', jsonFile: 'stn_1296MHz.json' },
      '2320MHz': { frequency: 2.320e9, display: '2320 MHz', jsonFile: 'stn_2320MHz.json' },
      '3400MHz': { frequency: 3.400e9, display: '3400 MHz', jsonFile: 'stn_3400MHz.json' },
      '5760MHz': { frequency: 5.760e9, display: '5760 MHz', jsonFile: 'stn_5760MHz.json' },
      '10GHz': { frequency: 10.368e9, display: '10 GHz', jsonFile: 'stn_10GHz.json' },
      '24GHz': { frequency: 24.000e9, display: '24 GHz', jsonFile: 'stn_24GHz.json' },
      '47GHz': { frequency: 47.000e9, display: '47 GHz', jsonFile: 'stn_47GHz.json' },
      '76GHz': { frequency: 76.000e9, display: '76 GHz', jsonFile: 'stn_76GHz.json' }
    };

    // Default to 10GHz
    let FREQUENCY_HZ = bandConfig['10GHz'].frequency;

    // Helper function to update hour-value display
    function updateHourDisplay() {
        const hour = Math.floor(hourIndex / 2);
        const minutes = (hourIndex % 2) * 30;
        document.getElementById('hour-value').textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    function updateBand(band) {
        // Stop real-time updates and disable real-time mode
        stopRealTimeUpdates();
        isRealTimeMode = false;
        console.log('updateBand: Real-time mode disabled, realTimeInterval cleared'); // Debug log

        // Update UI to reflect real-time mode is off
        const autoTrackButton = document.getElementById('realTimeButton');
        autoTrackButton.classList.remove('active');
        autoTrackButton.textContent = 'Track';
        document.getElementById('hour').disabled = false;
        document.getElementById('date').disabled = false;
        document.getElementById('prevDay').disabled = false;
        document.getElementById('nextDay').disabled = false;

        // Update hour-value to match slider position
        updateHourDisplay();

        // Update frequency
        FREQUENCY_HZ = bandConfig[band].frequency;

        // Invalidate caches
        qthDayData.date = null;
        dxDayData.date = null;
        relDayData.date = null;

        // Update JSON file and markers
        const jsonFile = bandConfig[band].jsonFile;
        const showActiveOnly = isActiveStationsOnly;
        markers.forEach(marker => marker.remove());
        markers = [];
        fetch(jsonFile)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                updateMarkers(data, showActiveOnly);
                // Recompute data for current locators
                const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                const dateStr = document.getElementById("date").value;
                if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                    computeLibrationForDay(qthInput, dateStr, 'qth');
                    computeFullDayData(qthDayData, qthInput, dateStr, true);
                }
                if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                    computeLibrationForDay(dxInput, dateStr, 'dx');
                    computeFullDayData(dxDayData, dxInput, dateStr, false);
                }
                // Update charts with new data, ensuring real-time mode is off
                if (!isRealTimeMode) {
                    console.log(`updateBand: Updating chart with hourIndex=${hourIndex}, isRealTimeMode=${isRealTimeMode}`); // Debug log
                    updateChart(hourIndex, false);
                } else {
                    console.warn('updateBand: Skipped chart update due to unexpected real-time mode'); // Debug log
                }
            })
            .catch(error => {
                console.error(`Error fetching ${jsonFile}:`, error);
            });
    }

    function computeLibrationForDay(locator, dateStr, type) {
        if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
            console.warn(`Invalid locator: ${locator}`);
            return [];
        }

        let lat, lon;
        try {
            ({ lat, lon } = qthToLatLon(locator));
        } catch (e) {
            console.error(`Error converting locator ${locator} to lat/lon: ${e.message}`);
            return [];
        }

        const date = new Date(dateStr);
        if (isNaN(date.getTime())) {
            console.error(`Invalid date string: ${dateStr}`);
            return [];
        }
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();

        const results = [];
        for (let i = 0; i < 48; i++) {
            const hour = Math.floor(i / 2);
            const minute = (i % 2) * 30;
            const dt = new Date(Date.UTC(year, month - 1, day, hour, minute));
            const isoDate = dt.toISOString().replace('.000Z', '');

            try {
                const [libLat, libLon] = EMEastroLib.topocentricLibration(year, month, day, hour, minute, lat, lon);
                if (isNaN(libLat) || isNaN(libLon) || libLat === null || libLon === null) {
                    throw new Error(`Invalid libration values: lat=${libLat}, lon=${libLon}`);
                }
                results.push({
                    date: isoDate,
                    lat: libLat,
                    lon: libLon
                });
            } catch (e) {
                console.warn(`Error computing libration for ${isoDate} at ${locator}: ${e.message}`);
                results.push({
                    date: isoDate,
                    lat: null,
                    lon: null
                });
            }
        }

        const librationRates = results.map((curr, i, arr) => {
            if (
                i <= 0 ||
                i >= arr.length - 1 ||
                arr[i-1].lat === null ||
                arr[i-1].lon === null ||
                arr[i+1].lat === null ||
                arr[i+1].lon === null ||
                curr.lat === null ||
                curr.lon === null
            ) {
                return { date: curr.date, rate: null, dldt: null, dbdt: null };
            }

            try {
                const dlat = (arr[i+1].lat - arr[i-1].lat) / 60;
                const dlon = (arr[i+1].lon - arr[i-1].lon) / 60;
                if (isNaN(dlat) || isNaN(dlon) || !isFinite(dlat) || !isFinite(dlon)) {
                    console.warn(`Invalid dlat/dlon for ${curr.date} at ${locator}: dlat=${dlat}, dlon=${dlon}`);
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }
                const rate = Math.sqrt(dlat * dlat + dlon * dlon);
                if (isNaN(rate) || !isFinite(rate)) {
                    console.warn(`Invalid rate for ${curr.date} at ${locator}: rate=${rate}, dlat=${dlat}, dlon=${dlon}`);
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }
                return { date: curr.date, rate, dldt: dlat, dbdt: dlon };
            } catch (e) {
                console.warn(`Error computing rate for ${curr.date} at ${locator}: ${e.message}`);
                return { date: curr.date, rate: null, dldt: null, dbdt: null };
            }
        });

        // Update cache
        const cache = type === 'qth' ? qthDayData : dxDayData;
        cache.date = dateStr;
        cache.libration = librationRates;

        if (type === 'qth') {
            rawData = librationRates.slice();
            document.getElementById("chartWrapper").style.display = rawData.some(r => r.rate != null) ? "block" : "none";
        } else {
            dxRawData = librationRates.slice();
            document.getElementById("dxChartWrapper").style.display = dxRawData.some(r => r.rate != null) ? "block" : "none";
        }
        return librationRates;
    }

    function computeFullDayData(cache, locator, dateStr, isQth) {
        const { lat: obsLat, lon: obsLon } = qthToLatLon(locator);
        const libData = cache.libration;
        const elevations = [];
        const azimuths = [];
        const dopplers = [];
        const rates = [];

        for (let i = 0; i < 48; i++) {
            const hour = Math.floor(i / 2);
            const minutes = (i % 2) * 30;
            const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00Z`);
            const observer = new Astronomy.Observer(obsLat, obsLon, 0);
            const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
            const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
            const elevationDeg = hor.altitude;
            const azimuthDeg = hor.azimuth;

            let rate = libData[i]?.rate ?? null;
            let doppler = null;
            if (elevationDeg > 0 && rate != null) {
                rates.push(rate * 1000);
                const omegaRadSec = rate * (Math.PI / 180) / 60;
                doppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
            } else {
                rates.push(null);
                doppler = null;
            }

            elevations.push(elevationDeg > 0 ? elevationDeg : null);
            azimuths.push(elevationDeg > 0 ? azimuthDeg : null);
            dopplers.push(doppler);
        }

        cache.elevations = elevations;
        cache.azimuths = azimuths;
        cache.dopplers = dopplers;
        cache.rates = rates;
    }

    function interpolate(a, b, frac) {
        if (a === null || b === null) return null;
        return a + (b - a) * frac;
    }

    function getValueAtIndex(data, index) {
        if (index < 0 || index > 47) return null;
        const floorIdx = Math.floor(index);
        const ceilIdx = Math.ceil(index);
        const frac = index - floorIdx;
        if (floorIdx === ceilIdx) return data[floorIdx];
        return interpolate(data[floorIdx], data[ceilIdx], frac);
    }

    function computeRelativeAtIndex(idx, qthData, dxData) {
        const qthL = qthData.libration[idx];
        const dxL = dxData.libration[idx];
        if (!qthL || !dxL || qthL.dldt == null || dxL.dldt == null) {
            return { libration: null, doppler: null, pol: null };
        }

        const qthElev = qthData.elevations[idx];
        const dxElev = dxData.elevations[idx];
        if (qthElev <= 0 || dxElev <= 0) {
            return { libration: null, doppler: null, pol: null };
        }

        const dldt_sum = qthL.dldt + dxL.dldt;
        const dbdt_sum = qthL.dbdt + dxL.dbdt;
        const relLibration = Math.sqrt(dldt_sum * dldt_sum + dbdt_sum * dbdt_sum) / 2;

        const omegaRadSec = relLibration * (Math.PI / 180) / 60;
        const relDoppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;

        // Pol offset
        const qthAz = qthData.azimuths[idx];
        const dxAz = dxData.azimuths[idx];
        let pol = null;
        if (qthAz != null && dxAz != null) {
            const polQth = calcPoloffset(lat, qthAz, qthElev);
            const polDx = calcPoloffset(dxLat, dxAz, dxElev);
            pol = calcPoloffsetDiff(polQth, polDx);
        }

        return { libration: relLibration, doppler: relDoppler, pol };
    }
                                            
                                            function angularSeparation(ra1, dec1, ra2, dec2) {
                                                const d1 = degToRad(dec1);
                                                const d2 = degToRad(dec2);
                                                const r1 = degToRad(ra1 * 15); // Convert RA from hours to degrees
                                                const r2 = degToRad(ra2 * 15);
                                                const cosSep = Math.sin(d1) * Math.sin(d2) + Math.cos(d1) * Math.cos(d2) * Math.cos(r1 - r2);
                                                // Handle floating-point errors
                                                const sep = Math.acos(Math.max(-1, Math.min(1, cosSep)));
                                                return radToDeg(sep);
                                            }
                                            
                                            function vectorToEquatorial(vector, ofdate) {
                                                try {
                                                    const moonEq = Astronomy.EquatorFromVector(vector);
                                                    if (!moonEq || isNaN(moonEq.ra) || isNaN(moonEq.dec)) {
                                                        throw new Error('Invalid equatorial coordinates');
                                                    }
                                                    // Use Astronomy.Libration for distance instead of vector.length()
                                                    const astroTime = Astronomy.MakeTime(vector.t);
                                                    const libration = Astronomy.Libration(astroTime);
                                                    if (!libration || isNaN(libration.dist_km)) {
                                                        throw new Error('Invalid libration data');
                                                    }
                                                    return {
                                                        ra: moonEq.ra, // Right ascension in hours
                                                        dec: moonEq.dec, // Declination in degrees
                                                        dist: libration.dist_km // Distance in kilometers
                                                    };
                                                } catch (e) {
                                                    console.error(`Error in vectorToEquatorial: ${e.message}`);
                                                    return null;
                                                }
                                            }
                                            
                                            function updateMap(currentTime) {
                                                if (!map) {
                                                    console.error('Map is not initialized in updateMap');
                                                    return;
                                                }

                                                const utcTimeString = currentTime.toISOString();

                                                if (!currentTime || isNaN(currentTime.getTime())) {
                                                    console.warn(`Invalid currentTime in updateMap: ${utcTimeString}`);
                                                    return;
                                                }

                                                // Clear previous footprints and moon marker
                                                map.eachLayer(layer => {
                                                    if (layer instanceof L.Polygon || layer instanceof L.Polyline || layer instanceof L.Circle || layer === moonMarker) {
                                                        if (layer.options && layer.options.color === '#0000FF' || layer === moonMarker) {
                                                            map.removeLayer(layer);
                                                        }
                                                    }
                                                });

                                                try {
                                                    const time = Astronomy.MakeTime(currentTime);
                                                    const observer = new Astronomy.Observer(0, 0, 0); // Reference at Earth's center
                                                    const moon = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
                                                    const libration = Astronomy.Libration(time);

                                                    if (!moon || isNaN(moon.ra) || isNaN(moon.dec) || !libration || isNaN(libration.dist_km)) {
                                                        throw new Error('Invalid moon or libration data');
                                                    }

                                                    // Calculate sublunar point
                                                    const raDeg = moon.ra * 15; // RA in degrees
                                                    const decDeg = moon.dec; // Declination in degrees
                                                    let gastDeg = Astronomy.SiderealTime(time) * 15; // Greenwich Apparent Sidereal Time in degrees
                                                    gastDeg = ((gastDeg % 360) + 360) % 360; // Normalize to [0, 360]
                                                    let lonDeg = raDeg - gastDeg; // Longitude in degrees
                                                    lonDeg = ((lonDeg + 180) % 360) - 180; // Normalize to [-180, 180]
                                                    const lat = decDeg; // Latitude is equal to declination
                                                    const lon = lonDeg;

                                                    // Calculate footprint radius
                                                    const earthRadiusKm = 6371; // Earth's mean radius
                                                    const safeRatio = Math.min(1, Math.max(-1, earthRadiusKm / (earthRadiusKm + libration.dist_km)));
                                                    const theta_rad = Math.acos(safeRatio);
                                                    const footprintRadius_m = earthRadiusKm * theta_rad * 1000; // Radius in meters

                                                    // Add moon marker
                                                    moonMarker = L.marker([lat, lon], {
                                                        icon: L.icon({
                                                            iconUrl: 'images/moon-icon.png', // Ensure this path is correct
                                                            iconSize: [40, 40],
                                                            iconAnchor: [10, 10]
                                                        }),
                                                        title: `Moon Sublunar (${lat.toFixed(2)}°, ${lon.toFixed(2)}°)`
                                                    }).addTo(map);

                                                    // Add moon footprint using L.greatCircle
                                                    try {
                                                        footprintCircle = L.greatCircle([lat, lon], {
                                                            radius: footprintRadius_m,
                                                            color: '#0000FF',
                                                            fillColor: '#0088FF',
                                                            fillOpacity: 0.2,
                                                            weight: 1,
                                                            wrapElements: true,
                                                            clipLat: 85,
                                                            degStep: 0.5,
                                                            maxCopies: -1
                                                        }).addTo(map);
                                                    } catch (e) {
                                                        console.warn(`L.greatCircle failed: ${e.message}. Falling back to L.circle`);
                                                        footprintCircle = L.circle([lat, lon], {
                                                            radius: footprintRadius_m,
                                                            color: '#0000FF',
                                                            fillColor: '#0088FF',
                                                            fillOpacity: 0.3,
                                                            weight: 2
                                                        }).addTo(map);
                                                    }

                                                } catch (error) {
                                                    console.error(`Error calculating sublunar point for ${utcTimeString}: ${error.message}`);
                                                    // Defensive cleanup
                                                    if (moonMarker) {
                                                        map.removeLayer(moonMarker);
                                                        moonMarker = null;
                                                    }
                                                    if (footprintCircle) {
                                                        map.removeLayer(footprintCircle);
                                                        footprintCircle = null;
                                                    }
                                                }
                                            }

                                            function calculateMoonDataForMonth(dateStr) {
                                                // Check cache
                                                if (moonDayData.date === dateStr) {
                                                    return moonDayData;
                                                }

                                                const startDate = new Date(dateStr);
                                                startDate.setUTCDate(1);
                                                startDate.setUTCHours(0, 0, 0, 0);
                                                const endDate = new Date(startDate);
                                                endDate.setUTCDate(endDate.getUTCDate() + 31); // Slightly over a month to ensure coverage

                                                const data = [];
                                                const labels = [];

                                                // Sgr A coordinates (J2000): RA = 17h45m40.0409s = 17.76112247h, Dec = -29°00'28.118" = -29.00781056°
                                                const sgrA = { ra: 17.76112247, dec: -29.00781056 };

                                                // Generate daily labels for the chart (DD-MM)
                                                for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
                                                    const day = String(dt.getUTCDate()).padStart(2, '0');
                                                    const month = String(dt.getUTCMonth() + 1).padStart(2, '0');
                                                    labels.push(`${day}-${month}`);
                                                }

                                                // Compute hourly data
                                                for (let dt = new Date(startDate); dt <= endDate; dt.setUTCHours(dt.getUTCHours() + 1)) {
                                                    try {
                                                        const dateString = dt.toISOString().slice(0, 10);
                                                        const time = dt.toISOString();
                                                        const astroTime = Astronomy.MakeTime(new Date(time));
                                                        
                                                        const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                                                        if (!moonVector) {
                                                            throw new Error('GeoVector returned null or undefined');
                                                        }
                                                        const moon = vectorToEquatorial(moonVector, false);
                                                        if (!moon) {
                                                            throw new Error('vectorToEquatorial returned null');
                                                        }
                                                        const libration = Astronomy.Libration(astroTime);
                                                        if (!libration) {
                                                            throw new Error('Libration returned null or undefined');
                                                        }
                                                        const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                                                        if (!sunVector) {
                                                            throw new Error('Sun GeoVector returned null or undefined');
                                                        }
                                                        const sun = Astronomy.EquatorFromVector(sunVector);
                                                        if (!sun || isNaN(sun.ra) || isNaN(sun.dec)) {
                                                            throw new Error('Invalid Sun equatorial coordinates');
                                                        }

                                                        const distanceKm = libration.dist_km;
                                                        const declination = moon.dec;
                                                        const sunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                                                        const sgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);

                                                        if (distanceKm != null && declination != null && !isNaN(declination) && !isNaN(sunSep) && !isNaN(sgrASep)) {
                                                            data.push({
                                                                date: dateString,
                                                                time: time,
                                                                index: (dt - startDate) / (1000 * 60 * 60), // Hours since start
                                                                distance: distanceKm,
                                                                declination: declination,
                                                                sunSep: sunSep,
                                                                sgrASep: sgrASep
                                                            });
                                                        } else {
                                                            console.warn(`Missing data for ${time}: distance=${distanceKm}, declination=${declination}, sunSep=${sunSep}, sgrASep=${sgrASep}`);
                                                        }
                                                    } catch (e) {
                                                        console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
                                                    }
                                                }

                                                // Update cache
                                                moonDayData.date = dateStr;
                                                moonDayData.data = data;
                                                moonDayData.labels = labels;

                                                return { data, labels };
                                            }

                                            function updateMoonChart(currentTime) {
                                                const dateInput = document.getElementById("date").value;
                                                const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

                                                // Aggregate hourly data to daily for plotting (average per day)
                                                const dailyData = [];
                                                for (let day = 0; day < labels.length; day++) {
                                                    const dayStart = day * 24;
                                                    const dayEnd = Math.min((day + 1) * 24, moonData.length);
                                                    let distanceSum = 0, declinationSum = 0, count = 0;
                                                    for (let i = dayStart; i < dayEnd; i++) {
                                                        if (moonData[i]) {
                                                            distanceSum += moonData[i].distance;
                                                            declinationSum += moonData[i].declination;
                                                            count++;
                                                        }
                                                    }
                                                    dailyData.push({
                                                        distance: count > 0 ? distanceSum / count : null,
                                                        declination: count > 0 ? declinationSum / count : null
                                                    });
                                                }

                                                const distances = dailyData.map(d => d.distance);
                                                const declinations = dailyData.map(d => d.declination);

                                                // Calculate selected day index with hourly precision
                                                const startDate = new Date(dateInput);
                                                startDate.setUTCDate(1);
                                                startDate.setUTCHours(0, 0, 0, 0);
                                                const selectedIndex = (currentTime - startDate) / (1000 * 60 * 60); // Hours since start

                                                let currentDistance = null;
                                                let currentDeclination = null;
                                                let pathLoss = null;
                                                let currentSunSep = null;
                                                let currentSgrASep = null;
                                                const minDist = 356352.93;
                                                const sgrA = { ra: 17.76112247, dec: -29.00781056 };

                                                try {
                                                    const astroTime = Astronomy.MakeTime(currentTime);
                                                    const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                                                    if (!moonVector) {
                                                        throw new Error('GeoVector returned null or undefined');
                                                    }
                                                    const moon = vectorToEquatorial(moonVector, false);
                                                    const libration = Astronomy.Libration(astroTime);
                                                    const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                                                    if (!sunVector) {
                                                        throw new Error('Sun GeoVector returned null or undefined');
                                                    }
                                                    const sun = Astronomy.EquatorFromVector(sunVector);

                                                    if (moon && libration && sun && !isNaN(sun.ra) && !isNaN(sun.dec)) {
                                                        currentDistance = libration.dist_km;
                                                        currentDeclination = moon.dec;
                                                        currentSunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                                                        currentSgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);
                                                        if (currentDistance != null) {
                                                            pathLoss = 40 * Math.log10(currentDistance / minDist);
                                                        }
                                                    } else {
                                                        throw new Error("Invalid current Moon or Sun data");
                                                    }
                                                } catch (e) {
                                                    console.warn(`Error calculating current Moon data for ${currentTime.toISOString()}: ${e.message}`);
                                                }

                                                // Determine the selected band and whether to show M-SgrA-related data
                                                const band = document.getElementById('bandSelect').value;
                                                const showSgrASep = band === '432MHz';

                                                // Find intervals where sunSep < 10 degrees with hourly precision
                                                const annotations = {
                                                    timeMarker: {
                                                        type: 'line',
                                                        mode: 'vertical',
                                                        scaleID: 'x',
                                                        value: selectedIndex / 24, // Map to daily scale
                                                        borderColor: 'black',
                                                        borderWidth: 2,
                                                        label: { enabled: false }
                                                    }
                                                };

                                                let sunSepInterval = null;
                                                let sgrASepInterval = null;

                                                for (let i = 0; i < moonData.length; i++) {
                                                    const dayData = moonData[i];
                                                    if (dayData.sunSep < 10) {
                                                        if (!sunSepInterval) {
                                                            sunSepInterval = { start: dayData.index, end: dayData.index };
                                                        } else {
                                                            sunSepInterval.end = dayData.index;
                                                        }
                                                    } else if (sunSepInterval) {
                                                        annotations[`sunSep${sunSepInterval.start}`] = {
                                                            type: 'box',
                                                            xScaleID: 'x',
                                                            xMin: sunSepInterval.start / 24, // Map to daily scale
                                                            xMax: (sunSepInterval.end + 1) / 24,
                                                            yMin: -30, // Span full declination range
                                                            yMax: 30,
                                                            backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                                                            borderWidth: 0, // No border
                                                            label: { enabled: false } // No label
                                                        };
                                                        sunSepInterval = null;
                                                    }

                                                    // Only process sgrASep annotations if 144MHz or 432MHz is selected
                                                    if (showSgrASep && dayData.sgrASep < 10) {
                                                        if (!sgrASepInterval) {
                                                            sgrASepInterval = { start: dayData.index, end: dayData.index };
                                                        } else {
                                                            sgrASepInterval.end = dayData.index;
                                                        }
                                                    } else if (sgrASepInterval) {
                                                        annotations[`sgrASep${sgrASepInterval.start}`] = {
                                                            type: 'box',
                                                            xScaleID: 'x',
                                                            xMin: sgrASepInterval.start / 24, // Map to daily scale
                                                            xMax: (sgrASepInterval.end + 1) / 24,
                                                            yMin: -30, // Span full declination range
                                                            yMax: 30,
                                                            backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                                                            borderWidth: 0, // No border
                                                            label: { enabled: false } // No label
                                                        };
                                                        sgrASepInterval = null;
                                                    }
                                                }

                                                // Handle intervals that extend to the last data point
                                                if (sunSepInterval) {
                                                    annotations[`sunSep${sunSepInterval.start}`] = {
                                                        type: 'box',
                                                        xScaleID: 'x',
                                                        xMin: sunSepInterval.start / 24,
                                                        xMax: (sunSepInterval.end + 1) / 24,
                                                        yMin: -30,
                                                        yMax: 30,
                                                        backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                                                        borderWidth: 0, // No border
                                                        label: { enabled: false } // No label
                                                    };
                                                }

                                                if (showSgrASep && sgrASepInterval) {
                                                    annotations[`sgrASep${sgrASepInterval.start}`] = {
                                                        type: 'box',
                                                        xScaleID: 'x',
                                                        xMin: sgrASepInterval.start / 24,
                                                        xMax: (sgrASepInterval.end + 1) / 24,
                                                        yMin: -30,
                                                        yMax: 30,
                                                        backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                                                        borderWidth: 0, // No border
                                                        label: { enabled: false } // No label
                                                    };
                                                }

                                                // Construct the moonChartLabel content
                                                let labelContent =
                                                    `<span class="metric-label metric-distance">Dist:</span> ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}` +
                                                    `<span class="metric-separator">|</span>` +
                                                    `<span class="metric-label metric-declination">Decl:</span> ${currentDeclination != null ? currentDeclination.toFixed(1) + '°' : 'N/A'}` +
                                                    `<span class="metric-separator">|</span>` +
                                                    `<span class="metric-label metric-pathloss">Extra Loss:</span> ${pathLoss != null ? pathLoss.toFixed(2) + ' dB' : 'N/A'}` +
                                                    `<span class="metric-separator">|</span>` +
                                                    `<span class="metric-label metric-sun-sep">M-Sun:</span> ${currentSunSep != null ? currentSunSep.toFixed(1) + '°' : 'N/A'}`;

                                                // Conditionally add M-SgrA separation for 144MHz or 432MHz
                                                if (showSgrASep) {
                                                    labelContent +=
                                                        `<span class="metric-separator">|</span>` +
                                                        `<span class="metric-label metric-sgra-sep">M-SgrA:</span> ${currentSgrASep != null ? currentSgrASep.toFixed(1) + '°' : 'N/A'}`;
                                                }

                                                document.getElementById('moonChartLabel').innerHTML = labelContent;

                                                if (!moonChart) {
                                                    moonChart = new Chart(document.getElementById("moonDistanceChart"), {
                                                        type: 'line',
                                                        data: {
                                                            labels,
                                                            datasets: [
                                                                {
                                                                    label: "Moon Distance (km)",
                                                                    data: distances,
                                                                    borderColor: "#24a148",
                                                                    pointRadius: 0,
                                                                    borderWidth: 1.5,
                                                                    tension: 0.2,
                                                                    yAxisID: "y1"
                                                                },
                                                                {
                                                                    label: "Moon Declination (°)",
                                                                    data: declinations,
                                                                    borderColor: "#ff832b",
                                                                    pointRadius: 0,
                                                                    borderWidth: 1.5,
                                                                    tension: 0.2,
                                                                    yAxisID: "y2"
                                                                }
                                                            ]
                                                        },
                                                        options: {
                                                            responsive: true,
                                                            maintainAspectRatio: false,
                                                            scales: {
                                                                x: {
                                                                    title: {
                                                                        display: true,
                                                                        text: "Date (DD-MM)",
                                                                        font: { size: 10, family: 'Arial, sans-serif' }
                                                                    },
                                                                    ticks: { font: { size: 10 } }
                                                                },
                                                                y1: {
                                                                    type: "linear",
                                                                    display: true,
                                                                    position: "left",
                                                                    title: {
                                                                        display: true,
                                                                        text: "Distance (\u00D710³ km)",
                                                                        color: "#24a148",
                                                                        font: { size: 12, family: 'Arial, sans-serif' }
                                                                    },
                                                                    min: 356400,
                                                                    max: 406700,
                                                                    ticks: {
                                                                        stepSize: 10000,
                                                                        color: "#24a148",
                                                                        font: { size: 12 },
                                                                        callback: function(value) {
                                                                            return (value / 1000).toFixed(0);
                                                                        }
                                                                    },
                                                                    grid: { drawTicks: true, drawBorder: true }
                                                                },
                                                                y2: {
                                                                    type: "linear",
                                                                    display: true,
                                                                    position: "right",
                                                                    title: {
                                                                        display: true,
                                                                        text: "Declination (°)",
                                                                        color: "#ff832b",
                                                                        font: { size: 12, family: 'Arial, sans-serif' }
                                                                    },
                                                                    min: -30,
                                                                    max: 30,
                                                                    ticks: {
                                                                        stepSize: 10,
                                                                        callback: val => val + "°",
                                                                        color: "#ff832b",
                                                                        font: { size: 12 }
                                                                    },
                                                                    grid: { drawOnChartArea: false }
                                                                },
                                                                y3: {
                                                                    type: "linear",
                                                                    display: true,
                                                                    position: "right",
                                                                    title: {
                                                                        display: true,
                                                                        text: "Extra Path Loss (dB)",
                                                                        color: "#24a148",
                                                                        font: { size: 12, family: 'Arial, sans-serif' }
                                                                    },
                                                                    min: 0,
                                                                    max: 2.5,
                                                                    ticks: {
                                                                        stepSize: 0.5,
                                                                        callback: val => val.toFixed(1),
                                                                        color: "#24a148",
                                                                        font: { size: 12 }
                                                                    },
                                                                    grid: { drawOnChartArea: false },
                                                                    offset: true
                                                                }
                                                            },
                                                            plugins: {
                                                                legend: { display: false },
                                                                annotation: { annotations }
                                                            }
                                                        }
                                                    });
                                                } else {
                                                    moonChart.data.labels = labels;
                                                    moonChart.data.datasets[0].data = distances;
                                                    moonChart.data.datasets[1].data = declinations;
                                                    moonChart.options.plugins.annotation.annotations = annotations;
                                                    moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedIndex / 24;
                                                    moonChart.options.scales.y1.min = 356400;
                                                    moonChart.options.scales.y1.max = 406700;
                                                    moonChart.options.scales.y2.min = -30;
                                                    moonChart.options.scales.y2.max = 30;
                                                    moonChart.options.scales.y3.min = 0;
                                                    moonChart.options.scales.y3.max = 2.5;
                                                    moonChart.update('none');
                                                }
                                            }

    function updateChart(index, isRealtime = false) {
        const qthInput = document.getElementById("qth").value.trim().toUpperCase();
        const dxInput = document.getElementById("dx").value.trim().toUpperCase();
        const dateInput = document.getElementById("date").value;
        let dateStr;
        try {
          dateStr = new Date(dateInput).toISOString().slice(0, 10);
        } catch (e) {
          console.error('Invalid date input, using current date');
          dateStr = new Date().toISOString().slice(0, 10);
        }
        const band = document.getElementById('bandSelect').value;
        const maxDoppler = (FREQUENCY_HZ / bandConfig['10GHz'].frequency) * 300;

        let qthValid = false;
        if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
          if (qthDayData.date !== dateStr) {
            rawData = computeLibrationForDay(qthInput, dateStr, 'qth');
            computeFullDayData(qthDayData, qthInput, dateStr, true);
          }
          qthValid = qthDayData.libration.length === 48;
          try {
            ({ lat, lon } = qthToLatLon(qthInput));
          } catch (e) {
            console.error(`Error converting QTH locator ${qthInput} to lat/lon: ${e.message}`);
            lat = 0;
            lon = 0;
          }
        }

        let dxValid = false;
        if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
          if (dxDayData.date !== dateStr) {
            dxRawData = computeLibrationForDay(dxInput, dateStr, 'dx');
            computeFullDayData(dxDayData, dxInput, dateStr, false);
          }
          dxValid = dxDayData.libration.length === 48;
          try {
            ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
          } catch (e) {
            console.error(`Error converting DX locator ${dxInput} to lat/lon: ${e.message}`);
            dxLat = 0;
            dxLon = 0;
          }
        }

        // Get current values (interpolated if real-time)
        let currentElevQth = null, currentAzQth = null, currentRateQth = null, currentDopplerQth = null;
        if (qthValid) {
          currentElevQth = getValueAtIndex(qthDayData.elevations, index);
          currentAzQth = getValueAtIndex(qthDayData.azimuths, index);
          currentRateQth = getValueAtIndex(qthDayData.rates, index);
          currentDopplerQth = getValueAtIndex(qthDayData.dopplers, index);
        }

        let currentElevDx = null, currentAzDx = null, currentRateDx = null, currentDopplerDx = null;
        if (dxValid) {
          currentElevDx = getValueAtIndex(dxDayData.elevations, index);
          currentAzDx = getValueAtIndex(dxDayData.azimuths, index);
          currentRateDx = getValueAtIndex(dxDayData.rates, index);
          currentDopplerDx = getValueAtIndex(dxDayData.dopplers, index);
        }

        // Relative current
        let currentRelRate = null, currentRelDoppler = null, currentPolOffset = null;
        if (qthValid && dxValid) {
          const floorIdx = Math.floor(index);
          const ceilIdx = Math.ceil(index);
          const frac = index - floorIdx;
          const relFloor = computeRelativeAtIndex(floorIdx, qthDayData, dxDayData);
          const relCeil = computeRelativeAtIndex(ceilIdx, qthDayData, dxDayData);
          currentRelRate = interpolate(relFloor.libration * 1000, relCeil.libration * 1000, frac);
          currentRelDoppler = interpolate(relFloor.doppler, relCeil.doppler, frac);
          currentPolOffset = interpolate(relFloor.pol, relCeil.pol, frac);
        }

        // Chart data from caches
        const qthRates = qthDayData.rates || Array(48).fill(null);
        const qthElevs = qthDayData.elevations || Array(48).fill(null);
        const qthDopps = qthDayData.dopplers || Array(48).fill(null);

        const dxRates = dxDayData.rates || Array(48).fill(null);
        const dxElevs = dxDayData.elevations || Array(48).fill(null);
        const dxDopps = dxDayData.dopplers || Array(48).fill(null);

        let relLibrations = Array(48).fill(null);
        let relDopplers = Array(48).fill(null);
        let polOffsets = Array(48).fill(null);
        if (qthValid && dxValid && relDayData.date !== dateStr) {
          for (let i = 0; i < 48; i++) {
            const rel = computeRelativeAtIndex(i, qthDayData, dxDayData);
            relLibrations[i] = rel.libration ? rel.libration * 1000 : null;
            relDopplers[i] = rel.doppler;
            polOffsets[i] = rel.pol;
          }
          relDayData.date = dateStr;
          relDayData.libration = relLibrations;
          relDayData.dopplers = relDopplers;
          relDayData.polOffsets = polOffsets;
        } else if (qthValid && dxValid) {
          relLibrations = relDayData.libration;
          relDopplers = relDayData.dopplers;
          polOffsets = relDayData.polOffsets;
        }

        const labels = Array(48).fill('').map((_, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`);

        const qthAnnotation = {
          timeMarker: {
            type: 'line',
            mode: 'vertical',
            scaleID: 'x',
            value: index,
            borderColor: 'black',
            borderWidth: 2,
            label: { enabled: false }
          }
        };

        if (qthValid) {
          try {
            const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
            Object.assign(qthAnnotation, moonAnnotations);
          } catch (e) {
            console.warn(`Error getting moon annotations for QTH: ${e.message}`);
          }
        }

        if (qthValid) {
          document.getElementById("chartWrapper").style.display = "block";

          if (!chart) {
            chart = new Chart(document.getElementById("declinationChart"), {
              type: 'line',
              data: {
                labels,
                datasets: [
                  {
                    label: "Libration Rate (×10⁻³ °/min)",
                    data: qthRates,
                    borderColor: "#ff0000",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y1"
                  },
                  {
                    label: "Moon Elevation (°)",
                    data: qthElevs,
                    borderColor: "rgba(0, 0, 255, 0.6)",
                    backgroundColor: "rgba(0, 0, 255, 0.15)",
                    fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                    pointRadius: 0,
                    borderWidth: 1,
                    tension: 0.3,
                    yAxisID: "y2"
                  },
                  {
                    label: "Doppler Spread, Hz",
                    data: qthDopps,
                    borderColor: "green",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y3"
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                    ticks: { font: { size: 10 } }
                  },
                  y1: {
                    type: "linear",
                    display: true,
                    position: "right",
                    title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: 5,
                    ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                    grid: { drawTicks: true, drawBorder: true }
                  },
                  y2: {
                    position: "left",
                    display: true,
                    min: 0,
                    max: 90,
                    title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                    grid: { drawOnChartArea: false },
                    ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                  },
                  y3: {
                    type: "linear",
                    display: true,
                    position: "right",
                    offset: true,
                    title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: maxDoppler,
                    grid: { drawOnChartArea: false },
                    ticks: {
                      stepSize: Math.ceil(maxDoppler / 6),
                      color: "green",
                      font: { size: 12 },
                      callback: function(value) {
                        return Math.round(value); // Format as integer
                      }
                    }
                  }
                },
                plugins: {
                  legend: { display: false },
                  annotation: { annotations: qthAnnotation }
                }
              }
            });
          } else {
            chart.data.labels = labels;
            chart.data.datasets[0].data = qthRates;
            chart.data.datasets[1].data = qthElevs;
            chart.data.datasets[2].data = qthDopps;
            chart.options.plugins.annotation.annotations = qthAnnotation;
            chart.options.plugins.annotation.annotations.timeMarker.value = index;
            chart.options.scales.y3.max = maxDoppler;
            chart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
            chart.update('none');
          }

          const rateStr = currentRateQth != null ? (currentRateQth / 1000).toFixed(4) : null;
          document.getElementById('chartLabel').innerHTML =
            `<span class="metric-locator">${qthInput}</span>` +
            `<span class="metric-separator"></span>` +
            `<span class="metric-label metric-elevation">El:</span> ${currentElevQth != null ? currentElevQth.toFixed(1) + '°' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-azimuth">Az:</span> ${currentAzQth != null ? currentAzQth.toFixed(1) + '°' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '°/min' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerQth != null ? currentDopplerQth.toFixed(0) + ' Hz' : 'N/A'}`;
        } else {
          document.getElementById("chartWrapper").style.display = "none";
          if (chart) {
            chart.destroy();
            chart = null;
          }
          document.getElementById('chartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
        }

        const dxAnnotation = {
          timeMarker: {
            type: 'line',
            mode: 'vertical',
            scaleID: 'x',
            value: index,
            borderColor: 'black',
            borderWidth: 2,
            label: { enabled: false }
          }
        };

        if (dxValid) {
          try {
            const moonAnnotations = getMoonAnnotations(dateStr, dxLat, dxLon);
            Object.assign(dxAnnotation, moonAnnotations);
          } catch (e) {
            console.warn(`Error getting moon annotations for DX: ${e.message}`);
          }
        }

        if (dxValid) {
          document.getElementById("dxChartWrapper").style.display = "block";

          if (!dxChart) {
            dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
              type: 'line',
              data: {
                labels,
                datasets: [
                  {
                    label: "Libration Rate (×10⁻³ °/min)",
                    data: dxRates,
                    borderColor: "#ff0000",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y1"
                  },
                  {
                    label: "Moon Elevation (°)",
                    data: dxElevs,
                    borderColor: "rgba(0, 0, 255, 0.6)",
                    backgroundColor: "rgba(0, 0, 255, 0.15)",
                    fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                    pointRadius: 0,
                    borderWidth: 1,
                    tension: 0.3,
                    yAxisID: "y2"
                  },
                  {
                    label: "Doppler Spread, Hz",
                    data: dxDopps,
                    borderColor: "green",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y3"
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                    ticks: { font: { size: 10 } }
                  },
                  y1: {
                    type: "linear",
                    display: true,
                    position: "right",
                    title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: 5,
                    ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                    grid: { drawTicks: true, drawBorder: true }
                  },
                  y2: {
                    position: "left",
                    display: true,
                    min: 0,
                    max: 90,
                    title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                    grid: { drawOnChartArea: false },
                    ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                  },
                  y3: {
                    type: "linear",
                    display: true,
                    position: "right",
                    offset: true,
                    title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: maxDoppler,
                    grid: { drawOnChartArea: false },
                    ticks: {
                      stepSize: Math.ceil(maxDoppler / 6),
                      color: "green",
                      font: { size: 12 },
                      callback: function(value) {
                        return Math.round(value); // Format as integer
                      }
                    }
                  }
                },
                plugins: {
                  legend: { display: false },
                  annotation: { annotations: dxAnnotation }
                }
              }
            });
          } else {
            dxChart.data.labels = labels;
            dxChart.data.datasets[0].data = dxRates;
            dxChart.data.datasets[1].data = dxElevs;
            dxChart.data.datasets[2].data = dxDopps;
            dxChart.options.plugins.annotation.annotations = dxAnnotation;
            dxChart.options.plugins.annotation.annotations.timeMarker.value = index;
            dxChart.options.scales.y3.max = maxDoppler;
            dxChart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
            dxChart.update('none');
          }

          const rateStr = currentRateDx != null ? (currentRateDx / 1000).toFixed(4) : null;
          document.getElementById('dxchartLabel').innerHTML =
            `<span class="metric-locator">${dxInput}</span>` +
            `<span class="metric-separator"></span>` +
            `<span class="metric-label metric-elevation">El:</span> ${currentElevDx != null ? currentElevDx.toFixed(1) + '°' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-azimuth">Az:</span> ${currentAzDx != null ? currentAzDx.toFixed(1) + '°' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '°/min' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerDx != null ? currentDopplerDx.toFixed(0) + ' Hz' : 'N/A'}`;
        } else {
          document.getElementById("dxChartWrapper").style.display = "none";
          if (dxChart) {
            dxChart.destroy();
            dxChart = null;
          }
          document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
        }

        const relativeAnnotation = {
          timeMarker: {
            type: 'line',
            mode: 'vertical',
            scaleID: 'x',
            value: index,
            borderColor: 'black',
            borderWidth: 2,
            label: { enabled: false }
          }
        };

        if (qthValid && dxValid) {
          try {
            const skedAnnotations = getSkedAnnotations(dateStr, lat, lon, dxLat, dxLon);
            Object.assign(relativeAnnotation, skedAnnotations);
          } catch (e) {
            console.warn(`Error getting sked annotations: ${e.message}`);
          }
        }

        if (qthValid && dxValid && relLibrations.some(r => r != null)) {
          document.getElementById("relativeChartWrapper").style.display = "block";

          if (!relativeChart) {
            relativeChart = new Chart(document.getElementById("relativeDataChart"), {
              type: 'line',
              data: {
                labels,
                datasets: [
                  {
                    label: "Relative Libration (×10⁻³ °/min)",
                    data: relLibrations,
                    borderColor: "red",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y1"
                  },
                  {
                    label: "Relative Spread, Hz",
                    data: relDopplers,
                    borderColor: "green",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y2"
                  },
                  {
                    label: "Polarization Offset (°)",
                    data: polOffsets,
                    borderColor: "blue",
                    pointRadius: 0,
                    borderWidth: 1.5,
                    tension: 0.2,
                    yAxisID: "y3"
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                    ticks: { font: { size: 10 } }
                  },
                  y1: {
                    type: "linear",
                    display: true,
                    position: "right",
                    title: { display: true, text: "Rel. Libration (×10⁻³ °/min)", color: "red", font: { size: 10, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: 5,
                    ticks: { stepSize: 1, color: "red", font: { size: 12 } },
                    grid: { drawTicks: true, drawBorder: true }
                  },
                  y2: {
                    type: "linear",
                    display: true,
                    position: "right",
                    offset: true,
                    title: { display: true, text: "Rel. Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                    min: 0,
                    max: maxDoppler,
                    grid: { drawOnChartArea: false },
                    ticks: {
                      stepSize: Math.ceil(maxDoppler / 6),
                      color: "green",
                      font: { size: 12 },
                      callback: function(value) {
                        return Math.round(value); // Format as integer
                      }
                    }
                  },
                  y3: {
                    type: "linear",
                    display: true,
                    position: "left",
                    title: { display: true, text: "Polarization Offset (°)", color: "blue", font: { size: 12, family: 'Arial, sans-serif' } },
                    min: -90,
                    max: 90,
                    grid: { drawOnChartArea: false },
                    ticks: { stepSize: 30, callback: val => val + "°", color: "blue", font: { size: 12 } }
                  }
                },
                plugins: {
                  legend: { display: false },
                  annotation: { annotations: relativeAnnotation }
                }
              }
            });
          } else {
            relativeChart.data.labels = labels;
            relativeChart.data.datasets[0].data = relLibrations;
            relativeChart.data.datasets[1].data = relDopplers;
            relativeChart.data.datasets[2].data = polOffsets;
            relativeChart.options.plugins.annotation.annotations = relativeAnnotation;
            relativeChart.options.plugins.annotation.annotations.timeMarker.value = index;
            relativeChart.options.scales.y2.max = maxDoppler;
            relativeChart.options.scales.y2.ticks.stepSize = Math.ceil(maxDoppler / 6);
            relativeChart.update('none');
          }

          const relRateStr = currentRelRate != null ? (currentRelRate / 1000).toFixed(4) : null;
          document.getElementById('relativeChartLabel').innerHTML =
            `<span class="metric-label metric-rel-libration">Rel LR:</span> ${relRateStr != null ? relRateStr + '°/min' : 'N/A'}` +
            `<span class="metric-separator"> | </span>` +
            `<span class="metric-label metric-rel-doppler">DX Width:</span> ${currentRelDoppler != null ? currentRelDoppler.toFixed(0) + ' Hz' : 'N/A'}` +
            `<span class="metric-separator"> | </span>` +
            `<span class="metric-label metric-poloffset">Dpol:</span> ${currentPolOffset != null ? currentPolOffset.toFixed(1) + '°' : 'N/A'}`;
        } else {
          document.getElementById("relativeChartWrapper").style.display = "none";
          if (relativeChart) {
            relativeChart.destroy();
            relativeChart = null;
          }
          document.getElementById('relativeChartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH and DX</span>';
        }

        // Update map and moon chart with exact time
        const exactTime = isRealtime ? new Date() : new Date(`${dateStr}T${Math.floor(index / 2).toString().padStart(2, '0')}:${String((index % 2) * 30).padStart(2, '0')}:00Z`);
        updateMap(exactTime);
        updateMoonChart(exactTime);
    }

                                            function startRealTimeUpdates() {
                                                if (isRealTimeMode) {
                                                    console.log('startRealTimeUpdates: Starting real-time updates'); // Debug log
                                                    stopRealTimeUpdates(); // Clear any existing interval
                                                    updateRealTime(); // Perform immediate update
                                                    const now = new Date();
                                                    const secondsUntilNextMinute = 60 - now.getUTCSeconds();
                                                    const millisecondsUntilNextMinute = secondsUntilNextMinute * 1000 - now.getUTCMilliseconds();
                                                    setTimeout(() => {
                                                        if (isRealTimeMode) { // Double-check mode
                                                            updateRealTime();
                                                            realTimeInterval = setInterval(updateRealTime, 60000);
                                                        } else {
                                                            console.log('startRealTimeUpdates: Aborted interval start due to real-time mode off'); // Debug log
                                                        }
                                                    }, millisecondsUntilNextMinute);
                                                } else {
                                                    console.log('startRealTimeUpdates: Skipped because real-time mode is off'); // Debug log
                                                }
                                            }

    function stopRealTimeUpdates() {
      if (realTimeInterval) {
        clearInterval(realTimeInterval);
        realTimeInterval = null;
      }
    }

                                            function updateRealTime() {
                                                if (!isRealTimeMode) {
                                                    console.log('updateRealTime: Skipped because real-time mode is off');
                                                    return;
                                                }
                                                console.log('updateRealTime: Running real-time update');
                                                const now = new Date();
                                                const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                                document.getElementById('date').valueAsDate = utcDate;
                                                document.getElementById('date').value = utcDate.toISOString().slice(0, 10);

                                                const hour = now.getUTCHours();
                                                const minute = now.getUTCMinutes();
                                                const fractionalIndex = hour + (minute / 60);
                                                const displayHour = String(hour).padStart(2, '0');
                                                const displayMin = String(minute).padStart(2, '0');
                                                document.getElementById('hour-value').textContent = `Time (UTC): ${displayHour}:${displayMin}`;

                                                const dateStr = utcDate.toISOString().slice(0, 10);
                                                const qthInput = document.getElementById('qth').value.trim().toUpperCase();
                                                const dxInput = document.getElementById('dx').value.trim().toUpperCase();
                                                if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && qthDayData.date !== dateStr) {
                                                    computeLibrationForDay(qthInput, dateStr, 'qth');
                                                    computeFullDayData(qthDayData, qthInput, dateStr, true);
                                                }
                                                if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && dxDayData.date !== dateStr) {
                                                    computeLibrationForDay(dxInput, dateStr, 'dx');
                                                    computeFullDayData(dxDayData, dxInput, dateStr, false);
                                                }
                                                if (moonDayData.date !== dateStr) {
                                                    moonDayData.date = null; // Invalidate Moon data cache
                                                    calculateMoonDataForMonth(dateStr);
                                                }
                                                updateChart(fractionalIndex, true);
                                                // Update noise map if visible
                                                const noiseContainer = document.getElementById('noiseMapContainer');
                                                if (noiseContainer.style.display === 'block') {
                                                    const noiseIndex = fractionalIndex * 6; // 6 indices per hour (10-min steps)
                                                    noiseChangeTime(noiseIndex);
                                                    updateNoiseTimeDisplay();
                                                }
                                            }
    
    function decodeEmail(obfuscated) {
        try {
            const reversed = obfuscated.split('').reverse().join('');
            return atob(reversed);
        } catch (e) {
            return '';
        }
    }
    
    let markers = []; // Store markers globally for filtering

                                            function updateMarkers(data, showActiveOnly) {
                                                // Clear existing markers
                                                markers.forEach(marker => marker.remove());
                                                markers = [];

                                                const coordinateMap = new Map();

                                                // First pass: Count stations per coordinate
                                                data.forEach(station => {
                                                    const { Coordinates, Note = '' } = station;
                                                    if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                                                        return; // Skip stations with DXpedition or SK in Note
                                                    }
                                                    const [latStr, lngStr] = Coordinates.split(',');
                                                    const lat = parseFloat(latStr);
                                                    const lng = parseFloat(lngStr);
                                                    if (isNaN(lat) || isNaN(lng)) {
                                                        console.warn(`Invalid coordinates for station ${station.Call}: ${Coordinates}`);
                                                        return;
                                                    }
                                                    const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                                                    coordinateMap.set(coordKey, (coordinateMap.get(coordKey) || 0) + 1);
                                                });

                                                // Get the current band
                                                const band = document.getElementById('bandSelect').value;

                                                // Second pass: Create markers with conditional offsets
                                                data.forEach(station => {
                                                    const {
                                                        Call: callsign,
                                                        Locator: locator,
                                                        Antenna: antenna,
                                                        Power: power,
                                                        Website: website,
                                                        CK: obfuscatedEmail = '',
                                                        Coordinates,
                                                        Note = '',
                                                        Name = ''
                                                    } = station;

                                                    if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                                                        return; // Skip stations with DXpedition or SK in Note
                                                    }

                                                    const email = decodeEmail(obfuscatedEmail);
                                                    const [latStr, lngStr] = Coordinates.split(',');
                                                    const lat = parseFloat(latStr);
                                                    const lng = parseFloat(lngStr);
                                                    if (isNaN(lat) || isNaN(lng)) {
                                                        console.warn(`Skipping station ${callsign} due to invalid coordinates: ${Coordinates}`);
                                                        return;
                                                    }

                                                    const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                                                    let offsetIndex = coordinateMap.get(coordKey + '_index') || 0;
                                                    coordinateMap.set(coordKey + '_index', offsetIndex + 1);

                                                    let markerPosition = [lat, lng];
                                                    const count = coordinateMap.get(coordKey);
                                                    if (count > 1) {
                                                        const offset = 0.01;
                                                        const angle = (offsetIndex * 2 * Math.PI) / count;
                                                        markerPosition = [
                                                            lat + offset * Math.cos(angle),
                                                            lng + offset * Math.sin(angle)
                                                        ];
                                                    }

                                                    let iconUrl = "images/EME_home.png";
                                                    if (/Inactive/i.test(Note)) {
                                                        iconUrl = "images/EME_inactive.png";
                                                    } else if (/SK/i.test(Note)) {
                                                        iconUrl = "images/EME_SK.png";
                                                    } else if (/DXpedition|Portable/i.test(Note)) {
                                                        iconUrl = "images/EME_dxped2.png";
                                                    }

                                                    const marker = L.marker(markerPosition, {
                                                        icon: L.icon({
                                                            iconUrl: iconUrl,
                                                            iconSize: [20, 20]
                                                        }),
                                                        title: callsign
                                                    }).addTo(map);

                                                    markers.push(marker);

                                                    const isLocatorValid = /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator);
                                                    const sanitizedCallsign = sanitizeCallsign(callsign);
                                                    const skedButton = isLocatorValid ?
                                                        `<button id="sked-${sanitizedCallsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>` :
                                                        '';
                                                    const emailButton = email ?
                                                        `<a id="email-${sanitizedCallsign}" class="email-button" href="mailto:${email}">Email</a>` :
                                                        '';
                                                    const qrzButton = `<a id="qrz-${sanitizedCallsign}" class="qrz-button" href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ</a>`;
                                                    const callsignDisplay = callsign +
                                                        (/SK/i.test(Note) ? ' (SK)' : '') +
                                                        (/Inactive/i.test(Note) ? ' (not active)' : '');
                                                    const displayWebsite = website.length > 30 ? website.slice(0, 30) + '...' : website;
                                                    const nameLine = Name ? `<div><strong>${Name}</strong></div>` : '';

                                                    // Construct band-specific and generic image URLs
                                                    const bandSpecificImageUrl = `db/${sanitizedCallsign}-${band}.jpg`;
                                                    const bandSpecificThumbUrl = `db/${sanitizedCallsign}_thumb-${band}.jpg`;
                                                    const genericImageUrl = `db/${sanitizedCallsign}.jpg`;
                                                    const genericThumbUrl = `db/${sanitizedCallsign}_thumb.jpg`;

                                                    const infoContent = `
                                                        <div>
                                                            <div style="font-weight:bold; font-size: 16px;">${callsignDisplay}</div>
                                                            ${nameLine}
                                                            <div class="button-group-infowindow">
                                                                ${skedButton}${emailButton}${qrzButton}
                                                            </div>
                                                            <div>Locator: ${locator}</div>
                                                            <div>Antenna: ${antenna}</div>
                                                            <div>Power: ${power}</div>
                                                            <div>Website: <a href="${website}" target="_blank">${displayWebsite}</a></div>
                                                            <div id="image-container-${sanitizedCallsign}">
                                                                Station Picture (clickable):<br>
                                                                <a id="image-link-${sanitizedCallsign}" href="${bandSpecificImageUrl}" target="_blank">
                                                                    <img id="station-image-${sanitizedCallsign}" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA" alt="${callsign} station"/>
                                                                </a>
                                                                <div id="image-placeholder-${sanitizedCallsign}" style="display:none;">
                                                                    <p><a href="datasubmission.html" target="_blank">Add Image</a></p>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    `;

                                                    marker.bindPopup(infoContent);

                                                    marker.on('click', () => {
                                                        map.closePopup();
                                                        marker.openPopup();

                                                        setTimeout(() => {
                                                            const imageElement = document.getElementById(`station-image-${sanitizedCallsign}`);
                                                            const imageLink = document.getElementById(`image-link-${sanitizedCallsign}`);
                                                            const placeholder = document.getElementById(`image-placeholder-${sanitizedCallsign}`);

                                                            // Check for band-specific thumbnail
                                                            fetch(bandSpecificThumbUrl, { method: 'HEAD' })
                                                                .then(response => {
                                                                    if (response.ok) {
                                                                        // Band-specific image exists
                                                                        imageElement.src = bandSpecificThumbUrl;
                                                                        imageLink.href = bandSpecificImageUrl;
                                                                        placeholder.style.display = 'none';
                                                                    } else {
                                                                        // Fall back to generic thumbnail
                                                                        return fetch(genericThumbUrl, { method: 'HEAD' })
                                                                            .then(genericResponse => {
                                                                                if (genericResponse.ok) {
                                                                                    imageElement.src = genericThumbUrl;
                                                                                    imageLink.href = genericImageUrl;
                                                                                    placeholder.style.display = 'none';
                                                                                } else {
                                                                                    // No image available
                                                                                    imageElement.remove();
                                                                                    placeholder.style.display = 'block';
                                                                                }
                                                                            });
                                                                    }
                                                                })
                                                                .catch(() => {
                                                                    // Error fetching band-specific image, try generic
                                                                    return fetch(genericThumbUrl, { method: 'HEAD' })
                                                                        .then(genericResponse => {
                                                                            if (genericResponse.ok) {
                                                                                imageElement.src = genericThumbUrl;
                                                                                imageLink.href = genericImageUrl;
                                                                                placeholder.style.display = 'none';
                                                                            } else {
                                                                                imageElement.remove();
                                                                                placeholder.style.display = 'block';
                                                                            }
                                                                        })
                                                                        .catch(() => {
                                                                            imageElement.remove();
                                                                            placeholder.style.display = 'block';
                                                                        });
                                                                });

                                                            const skedButton = document.getElementById(`sked-${sanitizedCallsign}`);
                                                            if (skedButton) {
                                                                skedButton.addEventListener('click', () => {
                                                                    const locator = skedButton.getAttribute('data-locator');
                                                                    document.getElementById('dx').value = locator;
                                                                    const inputEvent = new Event('input', { bubbles: true });
                                                                    document.getElementById('dx').dispatchEvent(inputEvent);
                                                                });
                                                            }

                                                            const emailButton = document.getElementById(`email-${sanitizedCallsign}`);
                                                            if (emailButton) {
                                                                emailButton.addEventListener('click', () => {
                                                                });
                                                            }

                                                            const qrzButton = document.getElementById(`qrz-${sanitizedCallsign}`);
                                                            if (qrzButton) {
                                                                qrzButton.addEventListener('click', () => {
                                                                });
                                                            }
                                                        }, 100);
                                                    });
                                                });
                                            }

                                            function initMap() {
                                                try {
                                                    // Define tile layer
                                                    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                                                        minZoom: 0,
                                                        maxZoom: 20
                                                    });

                                                    // Initialize map with the tile layer and zoom control in bottomright
                                                    map = L.map('map', {
                                                        zoom: 2,
                                                        center: [0, 0],
                                                        gestureHandling: true,
                                                        fullscreenControl: false,
                                                        layers: [osm],
                                                        zoomControl: true // Enable zoom control (already true by default)
                                                    });

                                                    // Move zoom control to bottomright
                                                    map.zoomControl.setPosition('bottomright');

                                                    // Define CQ Zones and Maidenhead layers with error handling
                                                    var cqzones, maidenhead;
                                                    if (typeof L.cqzones === 'function') {
                                                        cqzones = L.cqzones({color : 'rgba(255, 0, 0, 0.4)'});
                                                        cqzones.addTo(map); // Add CQ Zones layer to the map by default
                                                    } else {
                                                        console.error('L.cqzones is not defined. CQ Zones layer will not be available.');
                                                    }
                                                    if (typeof L.maidenhead === 'function') {
                                                        maidenhead = L.maidenhead();
                                                    } else {
                                                        console.error('L.maidenhead is not defined. Maidenhead layer will not be available.');
                                                    }

                                                    // Add layer control
                                                    var overlays = {};
                                                    if (cqzones) overlays["<span style='color: black'>CQ Zones</span>"] = cqzones;
                                                    if (maidenhead) overlays["<span style='color: black'>Maidenhead</span>"] = maidenhead;

                                                    L.control.layers({
                                                        'Map': osm
                                                    }, overlays).addTo(map);

                                                    const band = document.getElementById('bandSelect').value;
                                                    const jsonFile = bandConfig[band].jsonFile;
                                                    const showActiveOnly = isActiveStationsOnly;
                                                    fetch(jsonFile)
                                                        .then(response => {
                                                            if (!response.ok) {
                                                                throw new Error(`HTTP error! Status: ${response.status}`);
                                                            }
                                                            return response.json();
                                                        })
                                                        .then(data => {
                                                            updateMarkers(data, showActiveOnly);
                                                        })
                                                        .catch(error => {
                                                            console.error(`Error fetching ${jsonFile} in initMap:`, error);
                                                            alert(`Failed to load station data for ${band}. Please try again later.`);
                                                        });
                                                } catch (error) {
                                                    console.error('Error initializing map:', error);
                                                    document.getElementById('map').innerHTML = '<p style="color: red; text-align: center;">Failed to load map. Please check your internet connection or try again later.</p>';
                                                }
                                            }
    
    let isActiveStationsOnly = false; // Default state (equivalent to checkbox checked)

    document.getElementById('activeStationsButton').addEventListener('click', () => {
      isActiveStationsOnly = !isActiveStationsOnly;
      const activeButton = document.getElementById('activeStationsButton');
      activeButton.textContent = isActiveStationsOnly ? 'Active' : 'All';
      if (isActiveStationsOnly) {
        activeButton.classList.add('active');
      } else {
        activeButton.classList.remove('active');
      }
      const band = document.getElementById('bandSelect').value;
      const jsonFile = bandConfig[band].jsonFile;
      fetch(jsonFile)
        .then(response => response.json())
        .then(data => {
          updateMarkers(data, isActiveStationsOnly);
        })
        .catch(error => {
          console.error(`Error fetching ${jsonFile}:`, error);
        });
    });
    
                                            document.getElementById('realTimeButton').addEventListener('click', () => {
                                                isRealTimeMode = !isRealTimeMode;
                                                const autoTrackButton = document.getElementById('realTimeButton');
                                                const hourSlider = document.getElementById('hour');
                                                const dateInput = document.getElementById('date');
                                                const prevDayButton = document.getElementById('prevDay');
                                                const nextDayButton = document.getElementById('nextDay');

                                                if (isRealTimeMode) {
                                                    console.log('realTimeButton: Enabling real-time mode'); // Debug log
                                                    autoTrackButton.classList.add('active');
                                                    autoTrackButton.textContent = 'Stop';
                                                    hourSlider.disabled = true;
                                                    dateInput.disabled = true;
                                                    prevDayButton.disabled = true;
                                                    nextDayButton.disabled = true;
                                                    startRealTimeUpdates();
                                                } else {
                                                    console.log('realTimeButton: Disabling real-time mode'); // Debug log
                                                    autoTrackButton.classList.remove('active');
                                                    autoTrackButton.textContent = 'Track';
                                                    hourSlider.disabled = false;
                                                    dateInput.disabled = false;
                                                    prevDayButton.disabled = false;
                                                    nextDayButton.disabled = false;
                                                    stopRealTimeUpdates();
                                                    updateHourDisplay();
                                                    updateChart(hourIndex, false);
                                                }
                                            });
    
    document.getElementById('bandSelect').addEventListener('change', () => {
      const band = document.getElementById('bandSelect').value;
      updateBand(band);
    });

    function parseCoordinates(coordinates) {
        const [latStr, lngStr] = coordinates.split(',');
        return {
            lat: parseFloat(latStr),
            lng: parseFloat(lngStr)
        };
    }

    function getMoonAnnotations(dateStr, lat, lon) {
        const observer = new Astronomy.Observer(lat, lon, 0);
        const jsDate = new Date(`${dateStr}T00:00:00Z`);
        const astroTime = Astronomy.MakeTime(jsDate);

        let riseEvent = null, setEvent = null;
        try {
            riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
        } catch (e) {
            console.warn(`Error calculating moonrise for ${dateStr}: ${e.message}`);
        }

        try {
            setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
        } catch (e) {
            console.warn(`Error calculating moonset for ${dateStr}: ${e.message}`);
        }

        const annotations = {};

        function formatTimeUTC(date) {
            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
        }

        const targetDateStr = dateStr.slice(0, 10);

        if (riseEvent && riseEvent.date) {
            const riseDate = riseEvent.date;
            const riseDateStr = riseDate.toISOString().slice(0, 10);
            if (riseDateStr === targetDateStr) {
                let index = timeToChartIndex(riseDate);
                const isLate = riseDate.getUTCHours() >= 23 && riseDate.getUTCMinutes() >= 30;
                annotations['moonrise'] = {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: isLate ? 47 : index,
                    borderColor: 'blue',
                    borderWidth: 1,
                    label: {
                        content: ['Rise', formatTimeUTC(riseDate)],
                        enabled: true,
                        position: 'top',
                        yAdjust: isLate ? -50 : -40,
                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                        color: 'white',
                        backgroundColor: 'rgba(0, 0, 255, 0.85)',
                        padding: 2,
                        cornerRadius: 6,
                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                        textAlign: 'center',
                        borderColor: 'rgba(255, 255, 255, 0.7)',
                        borderWidth: 1
                    }
                };
            }
        }

        if (setEvent && setEvent.date) {
            const setDate = setEvent.date;
            const setDateStr = setDate.toISOString().slice(0, 10);
            if (setDateStr === targetDateStr) {
                let index = timeToChartIndex(setDate);
                const isLate = setDate.getUTCHours() >= 23 && setDate.getUTCMinutes() >= 30;
                annotations['moonset'] = {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: isLate ? 47 : index,
                    borderColor: 'orange',
                    borderWidth: 1,
                    label: {
                        content: ['Set', formatTimeUTC(setDate)],
                        enabled: true,
                        position: 'top',
                        yAdjust: isLate ? -10 : -20,
                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                        color: 'white',
                        backgroundColor: 'rgba(255, 165, 0, 0.85)',
                        padding: 2,
                        cornerRadius: 6,
                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                        textAlign: 'center',
                        borderColor: 'rgba(255, 255, 255, 0.7)',
                        borderWidth: 1
                    }
                };
            }
        }

        return annotations;
    }

    function timeToChartIndex(date) {
        if (!(date instanceof Date)) throw new Error("Expected a Date object");
        let hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
        if (hours >= 23.5) {
            hours = 23.5;
        }
        return hours * 2;
    }

    function getSkedAnnotations(dateStr, qthLat, qthLon, dxLat, dxLon) {
        const annotations = {};
        const targetDateStr = dateStr.slice(0, 10);
        const jsDate = new Date(`${dateStr}T00:00:00Z`);
        const astroTime = Astronomy.MakeTime(jsDate);

        const qthObserver = new Astronomy.Observer(qthLat, qthLon, 0);
        const dxObserver = new Astronomy.Observer(dxLat, dxLon, 0);

        let qthRiseEvent = null, qthSetEvent = null, dxRiseEvent = null, dxSetEvent = null;
        try {
            qthRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, +1, astroTime, 1.0);
            qthSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, -1, astroTime, 1.0);
            dxRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, +1, astroTime, 1.0);
            dxSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, -1, astroTime, 1.0);
        } catch (e) {
            console.warn(`Error calculating moonrise/set: ${e.message}`);
            return annotations;
        }

        function formatTimeUTC(date) {
            if (!date) return 'N/A';
            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
        }

        function timeToChartIndex(date) {
            if (!(date instanceof Date)) return null;
            const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
            let index = Math.round(hours * 2);
            if (index < 0) index = 0;
            if (index > 47) index = 47;
            return index;
        }

        let skedStartTime = null, skedEndTime = null;
        if (qthRiseEvent && qthSetEvent && dxRiseEvent && dxSetEvent &&
            qthRiseEvent.date && qthSetEvent.date && dxRiseEvent.date && dxSetEvent.date) {
            const qthRise = qthRiseEvent.date;
            const qthSet = qthSetEvent.date;
            const dxRise = dxRiseEvent.date;
            const dxSet = dxSetEvent.date;

            const isSameDay = (date) => date.toISOString().slice(0, 10) === targetDateStr;

            if (isSameDay(qthRise) && isSameDay(qthSet) && isSameDay(dxRise) && isSameDay(dxSet)) {
                // Sked start is the later of the two rise times
                skedStartTime = qthRise > dxRise ? qthRise : dxRise;
                // Sked end is the earlier of the two set times
                skedEndTime = qthSet < dxSet ? qthSet : dxSet;
            }
        }

        // No annotations for sked start/end as per user request
        return annotations;
    }

    document.getElementById("hour").addEventListener("input", () => {
        hourIndex = parseInt(document.getElementById("hour").value);
        const hour = Math.floor(hourIndex / 2);
        const minutes = (hourIndex % 2) * 30;
        document.getElementById("hour-value").textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        updateChart(hourIndex, false);
    });

    function adjustDate(days) {
        const dateInput = document.getElementById("date");
        const currentDate = new Date(dateInput.value);
        currentDate.setDate(currentDate.getDate() + days);
        dateInput.valueAsDate = currentDate;
        dateInput.value = currentDate.toISOString().slice(0,10);
        updateChart(hourIndex, false);
    }

    document.getElementById("prevDay").addEventListener("click", () => {
        adjustDate(-1);
    });

    document.getElementById("nextDay").addEventListener("click", () => {
        adjustDate(1);
    });

                                            document.getElementById("date").addEventListener("change", () => {
                                                const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                                                const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                                                moonDayData.date = null; // Invalidate Moon data cache
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                                                    computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
                                                    computeFullDayData(qthDayData, qthInput, document.getElementById("date").value, true);
                                                }
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                                                    computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
                                                    computeFullDayData(dxDayData, dxInput, document.getElementById("date").value, false);
                                                }
                                                updateChart(hourIndex, false);
                                            });

                                            window.onload = () => {
                                                // Initialize map first
                                                initMap();

                                                const now = new Date();
                                                const utcHours = now.getUTCHours();
                                                const utcMinutes = now.getUTCMinutes();

                                                const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                                document.getElementById('date').valueAsDate = utcDate;
                                                document.getElementById('date').value = utcDate.toISOString().slice(0,10);

                                                let roundedHour = utcHours;
                                                let roundedMinutes = utcMinutes >= 15 && utcMinutes < 45 ? 30 : 0;
                                                if (utcMinutes >= 45) {
                                                    roundedHour += 1;
                                                    roundedMinutes = 0;
                                                }
                                                if (roundedHour >= 24) {
                                                    roundedHour -= 24;
                                                    utcDate.setUTCDate(utcDate.getUTCDate() + 1);
                                                    document.getElementById('date').valueAsDate = utcDate;
                                                    document.getElementById('date').value = utcDate.toISOString().slice(0,10);
                                                }

                                                hourIndex = roundedHour * 2 + (roundedMinutes === 30 ? 1 : 0);
                                                document.getElementById('hour').value = hourIndex;
                                                document.getElementById('hour-value').textContent =
                                                    `Time (UTC): ${String(roundedHour).padStart(2, '0')}:${String(roundedMinutes).padStart(2, '0')}`;

                                                document.getElementById('showControlsPanel').classList.remove('visible');

                                                // Ensure real-time mode is off initially
                                                isRealTimeMode = false;
                                                document.getElementById('realTimeButton').classList.remove('active');
                                                document.getElementById('realTimeButton').textContent = 'Track';

                                                const qthInput = document.getElementById('qth').value.trim().toUpperCase();
                                                const dxInput = document.getElementById('dx').value.trim().toUpperCase();
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                                                    computeLibrationForDay(qthInput, document.getElementById('date').value, 'qth');
                                                    computeFullDayData(qthDayData, qthInput, document.getElementById('date').value, true);
                                                }
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                                                    computeLibrationForDay(dxInput, document.getElementById('date').value, 'dx');
                                                    computeFullDayData(dxDayData, dxInput, document.getElementById('date').value, false);
                                                }

                                                // Initialize band (this calls updateMarkers, which needs map to be initialized)
                                                updateBand(document.getElementById('bandSelect').value);

                                                const currentNow = new Date();
                                                updateMap(currentNow);
                                                updateMoonChart(currentNow);
                                                updateChart(hourIndex, false);
                                            };
                                                
    window.addEventListener('unload', () => {
      stopRealTimeUpdates();
    });

    const qthInputElem = document.getElementById("qth");
    const dxInputElem = document.getElementById("dx");

                                            qthInputElem.addEventListener("input", () => {
                                                const locator = qthInputElem.value.trim().toUpperCase();
                                                const chartLabel = document.getElementById('chartLabel');
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                    chartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                    try {
                                                        computeLibrationForDay(locator, document.getElementById("date").value, 'qth');
                                                        computeFullDayData(qthDayData, locator, document.getElementById("date").value, true);
                                                        // Invalidate relDayData to force recompute
                                                        relDayData.date = null;
                                                        if (qthDayData.libration.length === 0) {
                                                            console.warn(`No data computed for QTH ${locator}`);
                                                            document.getElementById("chartWrapper").style.display = "none";
                                                            if (chart) {
                                                                chart.destroy();
                                                                chart = null;
                                                            }
                                                            chartLabel.innerHTML = '<span class="metric-locator">No data for QTH</span>';
                                                        } else {
                                                            setTimeout(() => {
                                                                updateChart(hourIndex, isRealTimeMode);
                                                            }, 0);
                                                        }
                                                    } catch (e) {
                                                        console.error(`Error computing libration for QTH ${locator}: ${e.message}`);
                                                        document.getElementById("chartWrapper").style.display = "none";
                                                        if (chart) {
                                                            chart.destroy();
                                                            chart = null;
                                                        }
                                                        chartLabel.innerHTML = '<span class="metric-locator">Error computing QTH data</span>';
                                                    }
                                                } else {
                                                    document.getElementById("chartWrapper").style.display = "none";
                                                    if (chart) {
                                                        chart.destroy();
                                                        chart = null;
                                                    }
                                                    // Invalidate relDayData when QTH is invalid
                                                    relDayData.date = null;
                                                    chartLabel.innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
                                                }
                                            });

                                            dxInputElem.addEventListener("input", () => {
                                                const locator = dxInputElem.value.trim().toUpperCase();
                                                const dxChartLabel = document.getElementById('dxchartLabel');
                                                if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                    dxChartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                    try {
                                                        computeLibrationForDay(locator, document.getElementById("date").value, 'dx');
                                                        computeFullDayData(dxDayData, locator, document.getElementById("date").value, false);
                                                        // Invalidate relDayData to force recompute
                                                        relDayData.date = null;
                                                        if (dxDayData.libration.length === 0) {
                                                            console.warn(`No data computed for DX ${locator}`);
                                                            document.getElementById("dxChartWrapper").style.display = "none";
                                                            if (dxChart) {
                                                                dxChart.destroy();
                                                                dxChart = null;
                                                            }
                                                            dxChartLabel.innerHTML = '<span class="metric-locator">No data for DX</span>';
                                                        } else {
                                                            setTimeout(() => {
                                                                updateChart(hourIndex, isRealTimeMode);
                                                            }, 0);
                                                        }
                                                    } catch (e) {
                                                        console.error(`Error computing libration for DX ${locator}: ${e.message}`);
                                                        document.getElementById("dxChartWrapper").style.display = "none";
                                                        if (dxChart) {
                                                            dxChart.destroy();
                                                            dxChart = null;
                                                        }
                                                        dxChartLabel.innerHTML = '<span class="metric-locator">Error computing DX data</span>';
                                                    }
                                                } else {
                                                    document.getElementById("dxChartWrapper").style.display = "none";
                                                    if (dxChart) {
                                                        dxChart.destroy();
                                                        dxChart = null;
                                                    }
                                                    // Invalidate relDayData when DX is invalid
                                                    relDayData.date = null;
                                                    document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
                                                }
                                            });

    function qthToLatLon(locator) {
        if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
            throw new Error("Invalid QTH locator format (must be 6 characters)");
        }
        locator = locator.toUpperCase();
        const A = 'A'.charCodeAt(0);
        const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
        const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
        return { lat, lon };
    }

    function degToRad(deg) {
        return deg * Math.PI / 180;
    }

    function radToDeg(rad) {
        return rad * 180 / Math.PI;
    }
    function calcPoloffset(latDeg, azMoonDeg, elMoonDeg) {
        const lat = degToRad(latDeg);
        const az = degToRad(azMoonDeg);
        const el = degToRad(elMoonDeg);

        const xx = Math.sin(lat) * Math.cos(el) - Math.cos(lat) * Math.cos(az) * Math.sin(el);
        const yy = Math.cos(lat) * Math.sin(az);

        let angleRad = Math.atan2(yy, xx);
        return radToDeg(angleRad);
    }

    function calcPoloffsetDiff(pol1, pol2) {
        let diff = (pol2 - pol1 + 720) % 180;
        if (diff > 90) diff -= 180;
        return diff;
    }
    function sanitizeCallsign(callsign) {
        return callsign.replace(/\//g, '_');
    }
    
    document.getElementById("toggleControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (!controls.classList.contains("folded")) {
            controls.classList.add("folded");
            toggleButton.style.display = "none";
            showButton.classList.add("visible");
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight;
                showButton.style.display = 'flex';
            }, 0);
        }
    });

    document.getElementById("showControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (controls.classList.contains("folded")) {
            controls.classList.remove("folded");
            toggleButton.style.display = "block";
            showButton.classList.remove("visible");
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight;
            }, 0);
            if (chart) chart.resize();
            if (dxChart) dxChart.resize();
            if (relativeChart) relativeChart.resize();
            if (moonChart) moonChart.resize();
        }
    });
    
    // Noise Map Integration
    // Add toggle in scrollable-controls
    const noiseToggleLabel = document.createElement('label');
    const toggleNoiseMap = document.createElement('input');
    toggleNoiseMap.type = 'checkbox';
    toggleNoiseMap.id = 'toggleNoiseMap';
    noiseToggleLabel.appendChild(toggleNoiseMap);
    noiseToggleLabel.append(' Noise Map');
    document.getElementById('scrollable-controls').appendChild(noiseToggleLabel);

    let noiseMapInitialized = false;
    let noiseScene, noiseCamera, noiseRenderer, noiseControls, noiseRaycaster, noiseMouse, noiseSpheres = [], noiseMinNoise = Infinity, noiseMaxNoise = -Infinity, noiseRawPoints = [];
    let noiseMoonTrajectoryGroup, noiseSunTrajectoryGroup, noiseMoonPositions = [], noiseDxMoonPositions = [], noiseSunPositions = [], noiseCommonMoonWindow = [], noiseCurrentTimeIndex = 0;
    let noiseMoonMarker, noiseSunMarker, noiseAzStep = 5, noiseElStep = 5;
    let noiseShowSunCheckbox, noiseColorBarCanvas, noiseColorBarContext, noiseMinNoiseLabel, noiseMaxNoiseLabel, noiseColorBarContainer, noiseInfoBox, noiseDemoStatus, noiseCsvUpload;
    let noiseCloseButton;
    let noiseAnimateId;
    let noiseResizeObserver;

    function getNoiseColor(noise) {
      const range = noiseMaxNoise - noiseMinNoise;
      const norm = range === 0 ? 0.5 : (noise - noiseMinNoise) / range;
      return new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
    }

    function noiseCalculateStepSizes() {
      if (!noiseRawPoints.length) {
        return { azStep: 5, elStep: 5 };
      }

      const azValues = [...new Set(noiseRawPoints.map(p => p.az))].sort((a, b) => a - b);
      const elValues = [...new Set(noiseRawPoints.map(p => p.el))].sort((a, b) => a - b);

      const azDiffs = azValues.slice(1).map((v, i) => v - azValues[i]).filter(d => d > 0);
      const elDiffs = elValues.slice(1).map((v, i) => v - elValues[i]).filter(d => d > 0);

      const azStep = azDiffs.length ? Math.min(...azDiffs) : 5;
      const elStep = elDiffs.length ? Math.min(...elDiffs) : 5;

      return { azStep, elStep };
    }

    function noiseInterpolateNoiseAtPosition(azimuth, elevation) {
      if (!noiseRawPoints.length) {
        return null;
      }

      const maxDistance = Math.max(noiseAzStep, noiseElStep) * 1.0;
      const maxClosestDistance = 6;
      const minPoints = 1;

      const pointsWithDistance = noiseRawPoints.map(point => {
        const dAz = Math.abs(point.az - azimuth);
        const dEl = Math.abs(point.el - elevation);
        const distance = Math.sqrt(dAz * dAz + dEl * dEl);
        return { ...point, distance };
      });

      const nearbyPoints = pointsWithDistance.filter(p => p.distance <= maxDistance);

      if (nearbyPoints.length >= minPoints) {
        if (nearbyPoints.length === 1) {
          return { noise: nearbyPoints[0].noise };
        }

        let totalWeight = 0;
        let weightedNoise = 0;
        nearbyPoints.forEach(point => {
          const weight = 1 / (point.distance * point.distance + 1e-6);
          weightedNoise += weight * point.noise;
          totalWeight += weight;
        });

        if (totalWeight === 0) {
          return null;
        }

        const interpolatedNoise = weightedNoise / totalWeight;
        return { noise: Math.max(noiseMinNoise, Math.min(noiseMaxNoise, interpolatedNoise)) };
      }

      const closestPoint = pointsWithDistance.reduce((min, p) => p.distance < min.distance ? p : min, pointsWithDistance[0]);
      if (closestPoint.distance <= maxClosestDistance) {
        return { noise: closestPoint.noise };
      }
      return null;
    }

    function noiseDrawColorBar() {
      if (noiseMinNoise === Infinity || noiseMaxNoise === -Infinity) {
        noiseColorBarContainer.style.display = 'none';
        return;
      }
      noiseColorBarContainer.style.display = 'flex';

      noiseMinNoiseLabel.textContent = `${noiseMinNoise.toFixed(2)} dB`;
      noiseMaxNoiseLabel.textContent = `${noiseMaxNoise.toFixed(2) } dB`;

      const dpr = window.devicePixelRatio || 1;
      const computedStyle = getComputedStyle(noiseColorBarCanvas);
      const canvasWidth = parseFloat(computedStyle.width);
      const canvasHeight = parseFloat(computedStyle.height);
      noiseColorBarCanvas.width = canvasWidth * dpr;
      noiseColorBarCanvas.height = canvasHeight * dpr;
      noiseColorBarContext.scale(dpr, dpr);

      noiseColorBarContext.save();
      noiseColorBarContext.setTransform(1, 0, 0, 1, 0, 0);
      noiseColorBarContext.clearRect(0, 0, noiseColorBarCanvas.width, noiseColorBarCanvas.height);

      const gradient = noiseColorBarContext.createLinearGradient(0, noiseColorBarCanvas.height, 0, 0);
      for (let i = 0; i <= 1; i += 0.1) {
        const norm = i;
        const color = new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
        gradient.addColorStop(i, `#${color.getHexString()}`);
      }
      noiseColorBarContext.fillStyle = gradient;
      noiseColorBarContext.fillRect(0, 0, noiseColorBarCanvas.width, noiseColorBarCanvas.height);

      if (noiseMoonPositions.length && noiseMoonPositions[noiseCurrentTimeIndex] && noiseMoonPositions[noiseCurrentTimeIndex].elevation > 0 && noiseRawPoints.length) {
        const moonData = noiseMoonPositions[noiseCurrentTimeIndex];
        const noisePoint = noiseInterpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
        if (noisePoint) {
          const noise = noisePoint.noise;
          const norm = (noiseMaxNoise - noiseMinNoise) === 0 ? 0.5 : (noise - noiseMinNoise) / (noiseMaxNoise - noiseMinNoise);
          let y = noiseColorBarCanvas.height * (1 - norm);
          y = Math.max(2 * dpr, Math.min(noiseColorBarCanvas.height - 2 * dpr, y));

          const isMobile = window.innerWidth <= 600 || window.matchMedia("(orientation: portrait)").matches;
          const triangleSize = isMobile ? 12 : 18;
          const textOffset = isMobile ? 14 : 22;
          const fontSize = isMobile ? 12 : 14;

          noiseColorBarContext.strokeStyle = '#000000';
          noiseColorBarContext.lineWidth = 2 * dpr;
          noiseColorBarContext.beginPath();
          noiseColorBarContext.moveTo(noiseColorBarCanvas.width, y);
          noiseColorBarContext.lineTo(noiseColorBarCanvas.width + triangleSize * dpr, y - (triangleSize / 2) * dpr);
          noiseColorBarContext.lineTo(noiseColorBarCanvas.width + triangleSize * dpr, y + (triangleSize / 2) * dpr);
          noiseColorBarContext.closePath();
          noiseColorBarContext.stroke();

          noiseColorBarContext.fillStyle = '#ffffff';
          noiseColorBarContext.fill();

          noiseColorBarContext.fillStyle = '#ffffff';
          noiseColorBarContext.strokeStyle = '#000000';
          noiseColorBarContext.lineWidth = 1 * dpr;
          noiseColorBarContext.font = `bold ${fontSize * dpr}px Segoe UI`;
          noiseColorBarContext.textAlign = 'left';
          noiseColorBarContext.textBaseline = 'middle';
          noiseColorBarContext.strokeText(`${noise.toFixed(2)} dB`, noiseColorBarCanvas.width + textOffset * dpr, y);
          noiseColorBarContext.fillText(`${noise.toFixed(2)} dB`, noiseColorBarCanvas.width + textOffset * dpr, y);

          noiseColorBarContext.fillStyle = '#ff0000';
          noiseColorBarContext.fillRect(0, y - 2 * dpr, 5 * dpr, 4 * dpr);
        }
      }

      noiseColorBarContext.restore();
    }

    function updateNoiseMoonMarker() {
      if (!noiseMoonPositions.length || !noiseMoonPositions[noiseCurrentTimeIndex]) {
        if (noiseMoonMarker) noiseMoonMarker.visible = false;
        return false;
      }

      const moonData = noiseMoonPositions[noiseCurrentTimeIndex];
      if (moonData.elevation <= 0) {
        if (noiseMoonMarker) noiseMoonMarker.visible = false;
        return false;
      }

      if (!noiseMoonMarker) {
        const geom = new THREE.SphereGeometry(0.03);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        noiseMoonMarker = new THREE.Mesh(geom, mat);
        noiseScene.add(noiseMoonMarker);
      }

      noiseMoonMarker.visible = true;
      noiseMoonMarker.position.copy(moonData.position);
      return true;
    }

    function updateNoiseSunMarker() {
      if (!noiseSunPositions.length || !noiseShowSunCheckbox.checked || !noiseSunPositions[noiseCurrentTimeIndex]) {
        if (noiseSunMarker) noiseSunMarker.visible = false;
        return false;
      }

      const sunData = noiseSunPositions[noiseCurrentTimeIndex];
      if (sunData.elevation <= 0) {
        if (noiseSunMarker) noiseSunMarker.visible = false;
        return false;
      }

      if (!noiseSunMarker) {
        const geom = new THREE.SphereGeometry(0.02);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
        noiseSunMarker = new THREE.Mesh(geom, mat);
        noiseScene.add(noiseSunMarker);
      }

      noiseSunMarker.visible = true;
      noiseSunMarker.position.copy(sunData.position);
      return true;
    }

    function updateNoiseInfoBox() {
      let html = '';

      if (noiseMoonPositions.length && noiseMoonPositions[noiseCurrentTimeIndex]) {
        const moonData = noiseMoonPositions[noiseCurrentTimeIndex];
        if (moonData.elevation > 0) {
          const noisePoint = noiseInterpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
          const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A';
          html += `
            <b>Moon</b><br>
            Az: ${moonData.azimuth.toFixed(1)}° El: ${moonData.elevation.toFixed(1)}°<br>
            ${noiseText}
          `;
        } else {
          html += `
            <b>Moon</b><br>
            Moon below horizon
          `;
        }
      } else {
        html += `
          <b>Moon</b><br>
          Moon below horizon
        `;
      }

      if (noiseDxMoonPositions.length && noiseDxMoonPositions[noiseCurrentTimeIndex]) {
        const dxMoonData = noiseDxMoonPositions[noiseCurrentTimeIndex];
        html += `<br>`;
        if (dxMoonData.elevation > 0) {
          html += `
            <b>DX Moon</b><br>
            Az: ${dxMoonData.azimuth.toFixed(1)}° El: ${dxMoonData.elevation.toFixed(1)}°
          `;
        } else {
          html += `
            <b>DX Moon</b><br>
            DX Moon below horizon
          `;
        }
      }

      if (noiseShowSunCheckbox.checked && noiseSunPositions.length && noiseSunPositions[noiseCurrentTimeIndex]) {
        const sunData = noiseSunPositions[noiseCurrentTimeIndex];
        html += `<br>`;
        if (sunData.elevation > 0) {
          html += `
            <b>Sun</b><br>
            Az: ${sunData.azimuth.toFixed(1)}° El: ${sunData.elevation.toFixed(1)}°
          `;
        } else {
          html += `
            <b>Sun</b><br>
            Sun below horizon
          `;
        }
      } else if (noiseShowSunCheckbox.checked) {
        html += `
          <br><b>Sun</b><br>
          Sun below horizon
        `;
      }

      noiseInfoBox.innerHTML = html;
      noiseInfoBox.style.display = 'block';
    }

    function updateNoiseTimeDisplay() {
      if (!noiseMoonPositions.length || !noiseMoonPositions[noiseCurrentTimeIndex]) {
        updateNoiseInfoBox();
        noiseDrawColorBar();
        return;
      }

      const time = noiseMoonPositions[noiseCurrentTimeIndex].time;
      const moonVisible = noiseMoonPositions[noiseCurrentTimeIndex].elevation > 0;
      const sunVisible = noiseShowSunCheckbox.checked && noiseSunPositions[noiseCurrentTimeIndex]?.elevation > 0;

      updateNoiseInfoBox();
      noiseDrawColorBar();
    }

    function noiseChangeTime(index) {
      if (!noiseMoonPositions.length) return;
      noiseCurrentTimeIndex = Math.max(0, Math.min(index, noiseMoonPositions.length - 1));
      updateNoiseMoonMarker();
      updateNoiseSunMarker();
      updateNoiseTimeDisplay();
    }

    function noiseAddTrajectories(selectedDate) {
      const grid = document.getElementById('qth').value || 'JO89tt';
      const dxGrid = document.getElementById('dx').value;
      const coords = maidenheadToLatLon(grid);
      let dxCoords = null;
      if (dxGrid && isValidGrid(dxGrid)) {
        dxCoords = maidenheadToLatLon(dxGrid);
      }

      if (!coords) {
        return;
      }

      const lat = coords.lat;
      const lon = coords.lon;
      const observer = new Astronomy.Observer(lat, lon, 0);
      let dxObserver = null;
      if (dxCoords) {
        dxObserver = new Astronomy.Observer(dxCoords.lat, dxCoords.lon, 0);
      }

      const date = selectedDate ? new Date(selectedDate) : new Date();
      const startOfDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

      noiseMoonTrajectoryGroup.clear();
      noiseSunTrajectoryGroup.clear();
      if (noiseMoonMarker) noiseScene.remove(noiseMoonMarker);
      if (noiseSunMarker) noiseScene.remove(noiseSunMarker);
      noiseMoonMarker = null;
      noiseSunMarker = null;
      noiseMoonPositions = [];
      noiseDxMoonPositions = [];
      noiseSunPositions = [];
      noiseCommonMoonWindow = [];
      noiseCurrentTimeIndex = 0;

      let moonSegment = [];
      let sunSegment = [];
      let commonMoonSegment = [];
      const moonSegments = [];
      const sunSegments = [];
      const commonMoonSegments = [];

      let firstMoonVisibleIndex = -1;
      let firstSunVisibleIndex = -1;

      for (let minutes = 0; minutes < 1440; minutes += 10) {
        const time = new Date(startOfDay.getTime() + minutes * 60 * 1000);
        if (time >= endOfDay) break;

        const moonEq = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, false);
        const moonHor = Astronomy.Horizon(time, observer, moonEq.ra, moonEq.dec, 'normal');
        const moonElevationDeg = moonHor.altitude;
        const moonAzimuthDeg = moonHor.azimuth;

        const azRadMoon = THREE.MathUtils.degToRad(360 - moonAzimuthDeg);
        const elRadMoon = THREE.MathUtils.degToRad(Math.max(moonElevationDeg, 0));
        const r = 1;
        const xMoon = r * Math.cos(elRadMoon) * Math.sin(azRadMoon);
        const yMoon = r * Math.sin(elRadMoon);
        const zMoon = r * Math.cos(elRadMoon) * Math.cos(azRadMoon);
        const moonPoint = new THREE.Vector3(xMoon, yMoon, zMoon);

        if (moonElevationDeg > 0) {
          moonSegment.push(moonPoint);
          if (firstMoonVisibleIndex === -1) firstMoonVisibleIndex = minutes / 10;
        } else {
          if (moonSegment.length > 1) moonSegments.push(moonSegment);
          moonSegment = [];
        }
        noiseMoonPositions.push({ time, position: moonPoint, azimuth: moonAzimuthDeg, elevation: moonElevationDeg });

        let isCommon = false;
        if (dxObserver) {
          const dxMoonEq = Astronomy.Equator(Astronomy.Body.Moon, time, dxObserver, true, false);
          const dxMoonHor = Astronomy.Horizon(time, dxObserver, dxMoonEq.ra, dxMoonEq.dec, 'normal');
          const dxMoonElevationDeg = dxMoonHor.altitude;
          const dxMoonAzimuthDeg = dxMoonHor.azimuth;

          if (dxMoonElevationDeg > 0 && moonElevationDeg > 0) {
            commonMoonSegment.push(moonPoint);
            isCommon = true;
          }
          noiseDxMoonPositions.push({ time, azimuth: dxMoonAzimuthDeg, elevation: dxMoonElevationDeg });
        }

        if (isCommon) {
          noiseCommonMoonWindow.push({ time, index: minutes / 10 });
        } else if (commonMoonSegment.length > 1) {
          commonMoonSegments.push(commonMoonSegment);
          commonMoonSegment = [];
        }

        const sunEq = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, false);
        const sunHor = Astronomy.Horizon(time, observer, sunEq.ra, sunEq.dec, 'normal');
        const sunElevationDeg = sunHor.altitude;
        const sunAzimuthDeg = sunHor.azimuth;

        const azRadSun = THREE.MathUtils.degToRad(360 - sunAzimuthDeg);
        const elRadSun = THREE.MathUtils.degToRad(Math.max(sunElevationDeg, 0));
        const xSun = r * Math.cos(elRadSun) * Math.sin(azRadSun);
        const ySun = r * Math.sin(elRadSun);
        const zSun = r * Math.cos(elRadSun) * Math.cos(azRadSun);
        const sunPoint = new THREE.Vector3(xSun, ySun, zSun);

        if (sunElevationDeg > 0) {
          sunSegment.push(sunPoint);
          if (firstSunVisibleIndex === -1) firstSunVisibleIndex = minutes / 10;
        } else {
          if (sunSegment.length > 1) sunSegments.push(sunSegment);
          sunSegment = [];
        }
        noiseSunPositions.push({ time, position: sunPoint, azimuth: sunAzimuthDeg, elevation: sunElevationDeg });
      }

      if (moonSegment.length > 1) moonSegments.push(moonSegment);
      if (sunSegment.length > 1) sunSegments.push(sunSegment);
      if (commonMoonSegment.length > 1) commonMoonSegments.push(commonMoonSegment);

      moonSegments.forEach(seg => {
        const geom = new THREE.BufferGeometry().setFromPoints(seg);
        const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const line = new THREE.Line(geom, mat);
        line.userData = { isMoonTrajectory: true };
        noiseMoonTrajectoryGroup.add(line);
      });

      commonMoonSegments.forEach(seg => {
        const geom = new THREE.BufferGeometry().setFromPoints(seg);
        const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 1 });
        const line = new THREE.Line(geom, mat);
        line.userData = { isCommonMoonTrajectory: true };
        noiseMoonTrajectoryGroup.add(line);
      });

      sunSegments.forEach(seg => {
        const geom = new THREE.BufferGeometry().setFromPoints(seg);
        const mat = new THREE.LineBasicMaterial({ color: 0xffa500 });
        const line = new THREE.Line(geom, mat);
        line.userData = { isSunTrajectory: true };
        noiseSunTrajectoryGroup.add(line);
      });

      noiseSunTrajectoryGroup.visible = noiseShowSunCheckbox.checked;

      if (firstMoonVisibleIndex !== -1) {
        noiseCurrentTimeIndex = firstMoonVisibleIndex;
      } else if (noiseShowSunCheckbox.checked && firstSunVisibleIndex !== -1) {
        noiseCurrentTimeIndex = firstSunVisibleIndex;
      } else {
        noiseCurrentTimeIndex = 72;
      }
      updateNoiseMoonMarker();
      updateNoiseSunMarker();
      updateNoiseTimeDisplay();
    }

    function isValidGrid(locator) {
      if (!locator || locator.length < 4 || locator.length > 6) return false;
      locator = locator.toUpperCase();
      const regex = /^[A-R]{2}[0-9]{2}([A-X]{2})?$/;
      return regex.test(locator);
    }

    function maidenheadToLatLon(locator) {
      if (!locator || locator.length < 4) return null;
      locator = locator.toUpperCase();
      const A = 'A'.charCodeAt(0);
      let lon = (locator.charCodeAt(0) - A) * 20 - 180;
      let lat = (locator.charCodeAt(1) - A) * 10 - 90;
      lon += parseInt(locator[2]) * 2;
      lat += parseInt(locator[3]) * 1;
      if (locator.length >= 6) {
        lon += (locator.charCodeAt(4) - A) * 5 / 60;
        lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
      }
      lon += 2.5 / 60;
      lat += 1.25 / 60;
      return { lat, lon };
    }

    function noiseAddAzimuthCompass() {
      const compassRadius = 1.05;
      const labelDistance = 1.2;
      const compassGroup = new THREE.Group();

      const fontLoader = new THREE.FontLoader();
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
        const directions = [
          { label: 'N', az: 0, color: 0xff0000 },
          { label: 'E', az: 90, color: 0xffffff },
          { label: 'S', az: 180, color: 0xffffff },
          { label: 'W', az: 270, color: 0xffffff }
        ];

        directions.forEach(dir => {
          const azRad = THREE.MathUtils.degToRad(360 - dir.az);
          const x = labelDistance * Math.sin(azRad);
          const z = labelDistance * Math.cos(azRad);
          const y = 0;

          const textGeom = new THREE.TextGeometry(dir.label, {
            font: font,
            size: 0.1,
            height: 0.001
          });
          const textMat = new THREE.MeshBasicMaterial({ color: dir.color });
          const text = new THREE.Mesh(textGeom, textMat);
          text.position.set(x, y, z);
          text.lookAt(0, 0, 0);
          compassGroup.add(text);
        });

        const ringGeom = new THREE.RingGeometry(compassRadius - 0.002, compassRadius + 0.002, 256);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9
        });
        const ring = new THREE.Mesh(ringGeom, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0;
        compassGroup.add(ring);

        for (let i = 0; i < 360; i += 10) {
          const angle = THREE.MathUtils.degToRad(360 - i);
          const isMajor = i % 30 === 0;
          const outer = compassRadius + 0.02;
          const inner = compassRadius - (isMajor ? 0.05 : 0.02);

          const x1 = inner * Math.cos(angle);
          const z1 = inner * Math.sin(angle);
          const x2 = outer * Math.cos(angle);
          const z2 = outer * Math.sin(angle);

          const tickGeom = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x1, 0, z1),
            new THREE.Vector3(x2, 0, z2)
          ]);
          const tickMat = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: isMajor ? 1.0 : 0.5
          });
          const tick = new THREE.Line(tickGeom, tickMat);
          compassGroup.add(tick);

          if (isMajor && ![0, 90, 180, 270].includes(i)) {
            const labelDist = compassRadius + 0.1;
            const lx = labelDist * Math.sin(angle);
            const lz = labelDist * Math.cos(angle);

            const degGeom = new THREE.TextGeometry(i.toString(), {
              font: font,
              size: 0.045,
              height: 0.001
            });
            const degMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const label = new THREE.Mesh(degGeom, degMat);
            label.position.set(lx, 0, lz);
            label.lookAt(0, 0, 0);
            label.rotation.y += Math.PI;
            compassGroup.add(label);
          }
        }

        noiseScene.add(compassGroup);
      }, undefined, (error) => {});
    }

    function noiseParseCsvData(csvText, csvSource) {
      Papa.parse(csvText, {
        header: true,
        delimiter: ";",
        skipEmptyLines: true,
        complete: function (results) {
          noiseRawPoints.length = 0;
          noiseSpheres.forEach(s => noiseScene.remove(s));
          noiseSpheres.length = 0;
          noiseMinNoise = Infinity;
          noiseMaxNoise = -Infinity;

          const headers = results.meta.fields;
          const requiredColumns = ['Azimuth', 'Elevation', 'Noise'];
          const hasRequiredColumns = requiredColumns.every(col => headers.includes(col));
          if (!hasRequiredColumns) {
            noiseDemoStatus.textContent = 'Error: CSV must contain Azimuth, Elevation, and Noise columns';
            noiseDemoStatus.style.color = 'red';
            noiseDemoStatus.style.display = 'block';
            return;
          }

          results.data.forEach(row => {
            if (row.Valid !== undefined && row.Valid !== "True") return;

            const az = parseFloat(row.Azimuth?.replace(",", "."));
            const el = parseFloat(row.Elevation?.replace(",", "."));
            const noise = parseFloat(row.Noise?.replace(",", "."));

            if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

            noiseMinNoise = Math.min(noiseMinNoise, noise);
            noiseMaxNoise = Math.max(noiseMaxNoise, noise);

            noiseRawPoints.push({ az, el, noise });
          });

          if (noiseRawPoints.length === 0) {
            noiseDemoStatus.textContent = 'Error: No valid data points in CSV';
            noiseDemoStatus.style.color = 'red';
            noiseDemoStatus.style.display = 'block';
            return;
          }

          const steps = noiseCalculateStepSizes();
          noiseAzStep = steps.azStep;
          noiseElStep = steps.elStep;

          noiseRawPoints.forEach(point => {
            const azRad = THREE.MathUtils.degToRad(360 - point.az);
            const elRad = THREE.MathUtils.degToRad(point.el);
            const r = 1;

            const x = r * Math.cos(elRad) * Math.sin(azRad);
            const y = r * Math.sin(elRad);
            const z = r * Math.cos(elRad) * Math.cos(azRad);

            const geometry = new THREE.SphereGeometry(0.02, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: getNoiseColor(point.noise) });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);

            sphere.userData = {
              azimuth: point.az,
              elevation: point.el,
              noise: point.noise
            };

            noiseSpheres.push(sphere);
            noiseScene.add(sphere);
          });

          let isCompleteDome = false;
          if (noiseRawPoints.length > 0) {
            const azValues = [...new Set(noiseRawPoints.map(p => p.az))].sort((a, b) => a - b);
            const elValues = [...new Set(noiseRawPoints.map(p => p.el))].sort((a, b) => a - b);
            const azRange = azValues[azValues.length - 1] - azValues[0];
            const elRange = elValues[elValues.length - 1] - elValues[0];
            isCompleteDome = azRange > 300 && elRange > 80;
          }

          if (!noiseRawPoints.length || isCompleteDome) {
            const distance = 2;
            const azRad = THREE.MathUtils.degToRad(180);
            const elRad = THREE.MathUtils.degToRad(30);
            noiseCamera.position.set(
              distance * Math.cos(elRad) * Math.sin(azRad),
              distance * Math.sin(elRad),
              distance * Math.cos(elRad) * Math.cos(azRad)
            );
            noiseCamera.lookAt(0, 0, 0);
            noiseControls.target.set(0, 0, 0);
          } else {
            const boundingBox = new THREE.Box3();
            noiseSpheres.forEach(s => boundingBox.expandByPoint(s.position));

            const center = new THREE.Vector3();
            boundingBox.getCenter(center);

            const size = new THREE.Vector3();
            boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z) || 2;

            let avgPosition = new THREE.Vector3();
            noiseSpheres.forEach(s => avgPosition.add(s.position));
            avgPosition.divideScalar(noiseSpheres.length);

            const directionToData = avgPosition.clone().normalize();
            const distance = maxDim * 2;
            noiseCamera.position.copy(directionToData.clone().multiplyScalar(distance));
            noiseCamera.lookAt(center);
            noiseControls.target.copy(center);
          }

          noiseControls.update();
          noiseAddAzimuthCompass();
          updateNoiseTimeDisplay();
          noiseDrawColorBar();

          if (csvSource === 'demo') {
            noiseDemoStatus.textContent = 'Demo loaded!';
            noiseDemoStatus.style.color = 'red';
            noiseDemoStatus.style.display = 'block';
          } else if (csvSource === 'stored') {
            noiseDemoStatus.textContent = 'Stored CSV loaded';
            noiseDemoStatus.style.color = 'blue';
            noiseDemoStatus.style.display = 'block';
          } else {
            noiseDemoStatus.textContent = 'CSV loaded!';
            noiseDemoStatus.style.color = 'blue';
            noiseDemoStatus.style.display = 'block';
          }
        },
        error: function (error) {
          noiseDemoStatus.textContent = 'Error: Invalid CSV format';
          noiseDemoStatus.style.color = 'red';
          noiseDemoStatus.style.display = 'block';
        }
      });
    }

    function initNoiseMap() {
      const container = document.getElementById('noiseMapContainer');

      // Create noiseControls
      const noiseControls = document.createElement('div');
      noiseControls.style.position = 'absolute';
      noiseControls.style.top = '10px';
      noiseControls.style.left = '10px';
      noiseControls.style.background = 'white';
      noiseControls.style.padding = '5px';
      container.appendChild(noiseControls);

      noiseCsvUpload = document.createElement('input');
      noiseCsvUpload.type = 'file';
      noiseCsvUpload.accept = '.csv';
      noiseControls.appendChild(noiseCsvUpload);

      const sunLabel = document.createElement('label');
      noiseShowSunCheckbox = document.createElement('input');
      noiseShowSunCheckbox.type = 'checkbox';
      noiseShowSunCheckbox.checked = false;
      sunLabel.appendChild(noiseShowSunCheckbox);
      sunLabel.append(' Show Sun');
      noiseControls.appendChild(sunLabel);

      // colorBarContainer
      noiseColorBarContainer = document.createElement('div');
      noiseColorBarContainer.style.position = 'absolute';
      noiseColorBarContainer.style.bottom = '10px';
      noiseColorBarContainer.style.right = '10px';
      noiseColorBarContainer.style.display = 'flex';
      noiseColorBarContainer.style.flexDirection = 'column';
      noiseColorBarContainer.style.alignItems = 'center';
      container.appendChild(noiseColorBarContainer);

      noiseMinNoiseLabel = document.createElement('span');
      noiseColorBarContainer.appendChild(noiseMinNoiseLabel);

      noiseColorBarCanvas = document.createElement('canvas');
      noiseColorBarCanvas.width = 20;
      noiseColorBarCanvas.height = 200;
      noiseColorBarCanvas.style.width = '20px';
      noiseColorBarCanvas.style.height = '200px';
      noiseColorBarContainer.appendChild(noiseColorBarCanvas);

      noiseColorBarContext = noiseColorBarCanvas.getContext('2d');

      noiseMaxNoiseLabel = document.createElement('span');
      noiseColorBarContainer.appendChild(noiseMaxNoiseLabel);

      // infoBox
      noiseInfoBox = document.createElement('div');
      noiseInfoBox.style.position = 'absolute';
      noiseInfoBox.style.bottom = '10px';
      noiseInfoBox.style.left = '10px';
      noiseInfoBox.style.background = 'white';
      noiseInfoBox.style.padding = '5px';
      noiseInfoBox.style.border = '1px solid #ccc';
      noiseInfoBox.style.display = 'none';
      container.appendChild(noiseInfoBox);

      // demoStatus
      noiseDemoStatus = document.createElement('div');
      noiseDemoStatus.style.position = 'absolute';
      noiseDemoStatus.style.top = '50px';
      noiseDemoStatus.style.left = '10px';
      noiseDemoStatus.style.display = 'none';
      container.appendChild(noiseDemoStatus);

      // close button
      noiseCloseButton = document.createElement('button');
      noiseCloseButton.textContent = 'Close';
      noiseCloseButton.style.position = 'absolute';
      noiseCloseButton.style.top = '5px';
      noiseCloseButton.style.right = '5px';
      container.appendChild(noiseCloseButton);

      // canvas div
      const canvasDiv = document.createElement('div');
      canvasDiv.style.width = '100%';
      canvasDiv.style.height = '100%';
      container.appendChild(canvasDiv);

      noiseScene = new THREE.Scene();
      noiseMoonTrajectoryGroup = new THREE.Group();
      noiseSunTrajectoryGroup = new THREE.Group();
      noiseScene.add(noiseMoonTrajectoryGroup);
      noiseScene.add(noiseSunTrajectoryGroup);

      noiseRenderer = new THREE.WebGLRenderer({ antialias: true });
      noiseRenderer.setSize(canvasDiv.clientWidth, canvasDiv.clientHeight);
      canvasDiv.appendChild(noiseRenderer.domElement);

      noiseCamera = new THREE.PerspectiveCamera(75, canvasDiv.clientWidth / canvasDiv.clientHeight, 0.1, 1000);
      const defaultDistance = 2;
      const defaultAzRad = THREE.MathUtils.degToRad(180);
      const defaultElRad = THREE.MathUtils.degToRad(30);
      noiseCamera.position.set(
        defaultDistance * Math.cos(defaultElRad) * Math.sin(defaultAzRad),
        defaultDistance * Math.sin(defaultElRad),
        defaultDistance * Math.cos(defaultElRad) * Math.cos(defaultAzRad)
      );
      noiseCamera.lookAt(0, 0, 0);

      noiseControls = new THREE.OrbitControls(noiseCamera, noiseRenderer.domElement);
      noiseControls.enableDamping = true;
      noiseControls.target.set(0, 0, 0);
      noiseControls.update();

      noiseRaycaster = new THREE.Raycaster();
      noiseMouse = new THREE.Vector2();

      noiseAddAzimuthCompass();

      // Load stored or demo CSV
      const storedCsv = localStorage.getItem('skyObserverCsv');
      if (storedCsv) {
        noiseParseCsvData(storedCsv, 'stored');
      } else {
        fetch('2025-05-29_20.44.04.csv')
          .then(response => response.text())
          .then(csv => noiseParseCsvData(csv, 'demo'))
          .catch(error => {
            console.error('Error loading demo CSV:', error);
            const distance = 2;
            const azRad = THREE.MathUtils.degToRad(180);
            const elRad = THREE.MathUtils.degToRad(30);
            noiseCamera.position.set(
              distance * Math.cos(elRad) * Math.sin(azRad),
              distance * Math.sin(elRad),
              distance * Math.cos(elRad) * Math.cos(azRad)
            );
            noiseCamera.lookAt(0, 0, 0);
            noiseControls.target.set(0, 0, 0);
            noiseControls.update();
            noiseAddTrajectories(document.getElementById('date').value);
          });
      }

      // Event listeners
      noiseShowSunCheckbox.addEventListener('change', () => {
        noiseSunTrajectoryGroup.visible = noiseShowSunCheckbox.checked;
        updateNoiseSunMarker();
        updateNoiseTimeDisplay();
      });

      noiseCsvUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const csvText = event.target.result;
          localStorage.setItem('skyObserverCsv', csvText);
          noiseParseCsvData(csvText, 'uploaded');
        };
        reader.readAsText(file);
      });

      noiseCloseButton.addEventListener('click', () => {
        toggleNoiseMap.checked = false;
        container.style.display = 'none';
        cancelAnimationFrame(noiseAnimateId);
        removeNoiseListeners();
      });

      // Click event for raycaster
      noiseRenderer.domElement.addEventListener('click', (event) => {
        const rect = noiseRenderer.domElement.getBoundingClientRect();
        noiseMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        noiseMouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

        noiseRaycaster.setFromCamera(noiseMouse, noiseCamera);
        const intersects = noiseRaycaster.intersectObjects([
          ...noiseSpheres,
          noiseMoonMarker,
          noiseSunMarker
        ].filter(obj => obj !== null));

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject === noiseMoonMarker && noiseMoonPositions[noiseCurrentTimeIndex] && noiseMoonPositions[noiseCurrentTimeIndex].elevation > 0) {
            const moonData = noiseMoonPositions[noiseCurrentTimeIndex];
            const noisePoint = noiseInterpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
            const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
            noiseInfoBox.innerHTML = `
              <b>Moon</b><br>
              Az: ${moonData.azimuth.toFixed(1)}° El: ${moonData.elevation.toFixed(1)}°<br>
              ${noiseText}
            `;
            noiseInfoBox.style.display = 'block';
          } else if (clickedObject === noiseSunMarker && noiseShowSunCheckbox.checked && noiseSunPositions[noiseCurrentTimeIndex] && noiseSunPositions[noiseCurrentTimeIndex].elevation > 0) {
            const sunData = noiseSunPositions[noiseCurrentTimeIndex];
            noiseInfoBox.innerHTML = `
              <b>Sun</b><br>
              Az: ${sunData.azimuth.toFixed(1)}° El: ${sunData.elevation.toFixed(1)}°
            `;
            noiseInfoBox.style.display = 'block';
          } else if (clickedObject.userData?.noise !== undefined) {
            const { azimuth, elevation, noise } = clickedObject.userData;
            noiseInfoBox.innerHTML = `
              <b>Measurement</b><br>
              Az: ${azimuth.toFixed(1)}° El: ${elevation.toFixed(1)}°<br>
              Noise: ${noise.toFixed(2)} dB
            `;
            noiseInfoBox.style.display = 'block';
          }
        } else {
          updateNoiseInfoBox();
        }
      });

      // Touch event
      noiseRenderer.domElement.addEventListener('touchend', (event) => {
        const touch = event.changedTouches[0];
        if (!touch) return;

        const rect = noiseRenderer.domElement.getBoundingClientRect();
        noiseMouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        noiseMouse.y = - ((touch.clientY - rect.top) / rect.height) * 2 + 1;

        noiseRaycaster.setFromCamera(noiseMouse, noiseCamera);
        const intersects = noiseRaycaster.intersectObjects([
          ...noiseSpheres,
          noiseMoonMarker,
          noiseSunMarker
        ].filter(obj => obj !== null));

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject === noiseMoonMarker && noiseMoonPositions[noiseCurrentTimeIndex] && noiseMoonPositions[noiseCurrentTimeIndex].elevation > 0) {
            const moonData = noiseMoonPositions[noiseCurrentTimeIndex];
            const noisePoint = noiseInterpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
            const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
            noiseInfoBox.innerHTML = `
              <b>Moon</b><br>
              Az: ${moonData.azimuth.toFixed(1)}° El: ${moonData.elevation.toFixed(1)}°<br>
              ${noiseText}
            `;
            noiseInfoBox.style.display = 'block';
          } else if (clickedObject === noiseSunMarker && noiseShowSunCheckbox.checked && noiseSunPositions[noiseCurrentTimeIndex] && noiseSunPositions[noiseCurrentTimeIndex].elevation > 0) {
            const sunData = noiseSunPositions[noiseCurrentTimeIndex];
            noiseInfoBox.innerHTML = `
              <b>Sun</b><br>
              Az: ${sunData.azimuth.toFixed(1)}° El: ${sunData.elevation.toFixed(1)}°
            `;
            noiseInfoBox.style.display = 'block';
          } else if (clickedObject.userData?.noise !== undefined) {
            const { azimuth, elevation, noise } = clickedObject.userData;
            noiseInfoBox.innerHTML = `
              <b>Measurement</b><br>
              Az: ${azimuth.toFixed(1)}° El: ${elevation.toFixed(1)}°<br>
              Noise: ${noise.toFixed(2)} dB
            `;
            noiseInfoBox.style.display = 'block';
          }
        } else {
          updateNoiseInfoBox();
        }
      });

      function noiseAnimate() {
        noiseAnimateId = requestAnimationFrame(noiseAnimate);
        noiseControls.update();
        noiseRenderer.render(noiseScene, noiseCamera);
      }

      noiseAnimate();

      // Resize observer
      noiseResizeObserver = new ResizeObserver(() => {
        noiseCamera.aspect = noiseRenderer.domElement.clientWidth / noiseRenderer.domElement.clientHeight;
        noiseCamera.updateProjectionMatrix();
        noiseRenderer.setSize(noiseRenderer.domElement.clientWidth, noiseRenderer.domElement.clientHeight);
        noiseDrawColorBar();
      });
      noiseResizeObserver.observe(noiseRenderer.domElement.parentElement);

      noiseMapInitialized = true;
    }

    // Listeners functions
    function updateNoiseTraj() {
      noiseAddTrajectories(document.getElementById('date').value);
      noiseChangeTime(getNoiseCurrentIndex());
      updateNoiseTimeDisplay();
    }

    function updateNoiseTime() {
      noiseChangeTime(getNoiseCurrentIndex());
      updateNoiseTimeDisplay();
    }

    function getNoiseCurrentIndex() {
      return document.getElementById('hour').value * 3;
    }

    toggleNoiseMap.addEventListener('change', () => {
      const container = document.getElementById('noiseMapContainer');
      if (toggleNoiseMap.checked) {
        if (!noiseMapInitialized) {
          initNoiseMap();
        }
        container.style.display = 'block';
        noiseAddTrajectories(document.getElementById('date').value);
        noiseChangeTime(getNoiseCurrentIndex());
        updateNoiseTimeDisplay();
        // Add listeners
        document.getElementById('qth').addEventListener('input', updateNoiseTraj);
        document.getElementById('dx').addEventListener('input', updateNoiseTraj);
        document.getElementById('date').addEventListener('change', updateNoiseTraj);
        document.getElementById('hour').addEventListener('input', updateNoiseTime);
      } else {
        container.style.display = 'none';
        cancelAnimationFrame(noiseAnimateId);
        // Remove listeners
        document.getElementById('qth').removeEventListener('input', updateNoiseTraj);
        document.getElementById('dx').removeEventListener('input', updateNoiseTraj);
        document.getElementById('date').removeEventListener('change', updateNoiseTraj);
        document.getElementById('hour').removeEventListener('input', updateNoiseTime);
      }
    });

</script>
<!-- Ko-Fi -->
<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script src="/kofi.js"></script></body>
</html>
