<!DOCTYPE html>
<html lang="en">
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7YST3WTEH3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7YST3WTEH3');
    </script>
    <meta charset="UTF-8" />
    <title>EME Observer – 10GHz Moonbounce Station Map, Moon Data & Sked Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="description" content="EME Observer is a 10GHz Moonbounce station map and QSO planner with moon tracking, Dpol, libration, moonrise and moonset times, signal loss chart, and tools for ham radio EME." />
        <meta name="keywords" content="EME, Moonbounce, Ham Radio, Amateur Radio, 10GHz, DX Map, Moon Tracking, Doppler Spread, Polarization Offset, Sublunar Point, Moon Azimuth, Moon Declination, Signal Loss, Libration, Moon Footprint, Moon Elevation" />
        <meta name="author" content="SA5IKN">
        <meta name="robots" content="index, follow">
                
                <!-- Open Graph Meta (Facebook, LinkedIn, etc.) -->
                  <meta property="og:title" content="EME Observer – 10GHz">
                  <meta property="og:type" content="website">
                  <meta property="og:description" content="Interactive Earth-Moon-Earth (EME) 10GHz station map and sked QSO planner with moon tracking, moon footprint, moon azimuth and elevation, moonset and moonrise times, sublunar point, moon distance and declination, libration, doppler spread, spatial polarisation offset (Dpol), and signal degradation chart for amateur radio (hamradio) and moonbounce enthusiasts.">
                  <meta property="og:image" content="https://dxer.site/social/eme-observer.jpg">
                  <meta property="og:url" content="https://dxer.site/eme-observer/">
                      
                      <!-- Twitter Meta -->
                        <meta name="twitter:card" content="summary_large_image">
                        <meta name="twitter:title" content="EME Observer – 10GHz Moonbounce Planner" />
                        <meta name="twitter:description" content="Plan your Earth-Moon-Earth QSOs with interactive 10GHz moon tracking, moon charts and tools for ham radio EME." />
                        <meta name="twitter:image" content="https://dxer.site/social/eme-observer.jpg" />
                
                <link rel="canonical" href="https://dxer.site/eme-observer/" />
                <!-- Favicon and App Icons -->
                <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
                <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
                <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
                <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
                <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
                
                <script type="application/ld+json">
                {
                  "@context": "https://schema.org",
                  "@type": "WebApplication",
                  "name": "EME Observer",
                  "url": "https://dxer.site/eme-observer/",
                  "author": {
                    "@type": "Person",
                    "name": "SA5IKN"
                  },
                  "description": "Interactive Earth-Moon-Earth (EME) 10GHz station map and sked QSO planner with moon tracking, moon footprint, moon azimuth and elevation, moonset and moonrise times, sublunar point, moon distance and declination, libration, doppler spread, spatial polarisation offset (Dpol), and signal degradation chart for amateur radio (hamradio) and moonbounce enthusiasts.",
                  "applicationCategory": "Science",
                  "operatingSystem": "All",
                  "browserRequirements": "Requires JavaScript",
                  "inLanguage": "en",
                  "applicationSubCategory": "Amateur Radio Application",
                  "offers": {
                    "@type": "Offer",
                    "price": "0.00",
                    "priceCurrency": "USD"
                  }

                }
              </script>
                <link rel="stylesheet" href="/leaflet/leaflet.css" />
                    <script src="/leaflet/leaflet.js"></script>
                    <script src="/leaflet/Leaflet.greatCircle.js"></script>
  <script src="a.ob.js"></script>

  <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #chartWrapper, #dxChartWrapper, #relativeChartWrapper, #moonChartWrapper {
        width: 100%;
        max-width: 600px;
        height: 180px;
        margin-top: 6px;
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 6px;
        box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        position: relative;
        box-sizing: border-box;
        display: none;
      }

      #declinationChart, #dxDeclinationChart, #relativeDataChart, #moonDistanceChart {
        width: 100%;
        height: calc(100% - 20px);
        box-sizing: border-box;
      }

      #moonChartWrapper {
        display: block;
      }

      #moonDistanceChart {
        height: calc(100% - 40px);
        padding-bottom: 20px;
      }

      #chartLabel, #dxchartLabel, #relativeChartLabel, #moonChartLabel {
        text-align: center;
        margin-bottom: 0px;
        font-weight: normal;
        font-size: 11px;
        font-family: 'Arial, sans-serif';
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        padding: 2px 0;
      }

      #map {
        height: 100dvh;
        width: 100%;
        z-index: 0;
      }

      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 5;
        background-color: rgba(255, 255, 255, 0.95);
        padding: 12px;
        border-radius: 8px;
        max-width: 95vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        box-sizing: border-box;
        transition: transform 0.3s ease;
      }

      #fixed-controls {
        position: sticky;
        top: 0;
        z-index: 10;
        background-color: inherit;
        padding-bottom: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      #scrollable-controls {
        flex: 1;
        overflow-y: auto;
        max-height: calc(90vh - 180px); /* Adjusted for inline locators */
        padding-right: 5px;
      }

      #scrollable-controls::-webkit-scrollbar {
        width: 6px;
      }

      #scrollable-controls::-webkit-scrollbar-thumb {
        background-color: rgba(0, 123, 255, 0.5);
        border-radius: 3px;
      }

      #scrollable-controls::-webkit-scrollbar-track {
        background: transparent;
      }

      label {
        font-weight: bold;
        font-size: 14px;
      }

      #hour-value {
        margin-left: 10px;
        font-weight: normal;
      }

      #hour {
        width: 100%;
        margin-top: 5px;
        -webkit-appearance: none;
        appearance: none;
        height: 10px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 5px;
        outline: none;
        transition: background 0.3s ease;
        padding: 0;
      }

      #hour::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
      }

      #hour::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
      }

      #hour:active {
        background: rgba(0, 123, 255, 0.5);
      }

      #hour-container {
        position: relative;
        width: 100%;
        height: 40px;
        margin-top: 10px;
        padding: 5px 0;
      }

      #date-container {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
      }

      input[type="date"] {
        width: auto;
        max-width: 200px;
      }

      .app-name-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        position: relative;
      }

      .creator-label {
        font-size: 10px;
        color: #555;
        font-style: italic;
        margin-bottom: -4px;
      }

      .app-name {
        font-size: 1.0rem;
        font-weight: bold;
        color: #2c3e50;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      .ghz-label {
        font-size: 10px;
        font-weight: bold;
        color: #2c3e50;
        margin-top: -4px;
      }

      #toggleMoonChart {
        font-size: 12px;
        padding: 4px 8px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      #toggleMoonChart:hover {
        background-color: #0056b3;
      }

      #toggleMoonChart:focus {
        outline: none;
        box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
      }

      #toggleControlsPanel {
        padding: 2px 3px;
        background-color: rgba(255, 255, 255, 0.3);
        color: #2c3e50;
        border: 1px solid rgba(0, 123, 255, 0.4);
        border-radius: 2px;
        font-size: 10px;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
      }

      #toggleControlsPanel:hover {
        background-color: rgba(255, 255, 255, 0.5);
        color: #0056b3;
        border-color: rgba(0, 123, 255, 0.6);
      }

      #toggleControlsPanel:focus {
        outline: none;
        box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
      }

      .locator-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .locator-input {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .locator-input label {
        font-size: 12px;
        font-weight: normal;
      }

      .locator-input input {
        font-size: 12px;
        padding: 2px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      .metric-label {
        font-weight: bold;
      }

      .metric-distance {
        color: #800080;
      }

      .metric-declination {
        color: #FFA500;
      }

      .metric-pathloss {
        color: #800080;
      }

      .metric-separator {
        color: #666;
        margin: 0 4px;
      }

      .metric-elevation {
        color: rgba(0, 0, 255, 0.6);
      }

      .metric-azimuth {
        color: #444;
      }

      .metric-libration {
        color: #ff0000;
      }

      .metric-doppler {
        color: green;
      }

      .metric-locator {
        color: #000;
        font-weight: bold;
      }

      .button-group-infowindow {
          display: flex;
          gap: 3px;
          margin-top: 6px;
          flex-wrap: wrap;
          justify-content: flex-start;
      }
      
      .sked-button {
        font-size: 12px;
        padding: 2px 6px;
        margin-left: 5px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .sked-button:hover {
        background-color: #218838;
      }

      .sked-button:focus {
        outline: none;
        box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
      }
      
      .email-button {
          background-color: #27A9F5;
          color: white;
          border: none;
          padding: 2px 6px;
          cursor: pointer;
          font-size: 12px;
          border-radius: 3px;
          margin-left: 5px;
          text-decoration: none;
          transition: background-color 0.3s ease;
      }

      .email-button:hover {
          background-color: #279CF5;
      }

      .email-button:focus {
        outline: none;
        box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
      }
      
      .qrz-button {
          background-color: #fd7e14; /* Orange to distinguish from Sked and Email */
          color: white;
          border: none;
          padding: 2px 6px;
          cursor: pointer;
          font-size: 12px;
          border-radius: 3px;
          margin-left: 5px; /* Space if placed next to other buttons */
          text-decoration: none; /* For <a> tag to look like a button */
          transition: background-color 0.3s ease;
      }

      .qrz-button:hover {
          background-color: #e86c12; /* Darker orange on hover */
      }
      
      .qrz-button:focus {
        outline: none;
        box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
      }
      
      .button-group {
        display: flex;
        gap: 3px;
        margin-top: 6px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .nav-button {
        padding: 2px 3px;
        background-color: rgba(255, 255, 255, 0.3);
        color: #2c3e50;
        border: 1px solid rgba(0, 123, 255, 0.4);
        border-radius: 2px;
        font-size: 10px;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
      }

      .nav-button:hover {
        background-color: rgba(255, 255, 255, 0.5);
        color: #0056b3;
        border-color: rgba(0, 123, 255, 0.6);
      }

      .nav-button:focus {
        outline: none;
        box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
      }

      .nav-button.icon-button {
        padding: 2px;
        font-size: 12px;
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #controls.folded {
        transform: translateX(calc(-100% + 30px));
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
      }

      #showControlsPanel {
        position: fixed;
        top: 30%;
        left: 35px;
        transform: translateY(-50%) scale(1);
        width: 24px;
        height: 24px;
        padding: 2px;
        background-color: rgba(255, 255, 255, 0.95);
        color: #2c3e50;
        border: 1px solid rgba(0, 123, 255, 0.4);
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      #showControlsPanel.visible {
        display: flex;
      }

      #showControlsPanel:hover {
        background-color: rgba(255, 255, 255, 1);
        color: #0056b3;
        border-color: rgba(0, 123, 255, 0.6);
        transform: translateY(-50%) scale(1.1);
      }

      #showControlsPanel:focus {
        outline: none;
        box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
      }

      #showControlsPanel:not(.visible) {
        display: none !important;
      }

      @media (max-width: 600px) {
        #showControlsPanel {
          left: 32px;
          width: 20px;
          height: 20px;
          font-size: 10px;
          padding: 1px;
        }
        #controls {
          padding: 8px;
        }
        #fixed-controls {
          padding-bottom: 8px;
        }
        #scrollable-controls {
          max-height: calc(90vh - 160px); /* Adjusted for smaller screens */
        }
        .locator-input label {
          font-size: 10px;
        }
        .locator-input input {
          font-size: 10px;
          width: 80px;
        }
        .nav-button, #toggleControlsPanel {
          font-size: 8px;
          padding: 2px 3px;
        }
        .nav-button.icon-button {
          font-size: 10px;
          width: 16px;
          height: 16px;
        }
      }

      .metric-rel-libration {
        color: red;
        font-weight: bold;
      }

      .metric-rel-doppler {
        color: green;
        font-weight: bold;
      }

      .metric-poloffset {
        color: blue;
        font-weight: bold;
      }
      
  </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
      <div id="fixed-controls">
        <div id="date-container">
          <div class="app-name-wrapper">
            <div class="creator-label">by SA5IKN</div>
            <div class="app-name">EME Observer</div>
            <div class="ghz-label">10GHz</div>
          </div>
          <button id="prevDay">←</button>
          <input type="date" id="date" />
          <button id="nextDay">→</button>
          <span id="hour-value">Time (UTC): 00:00</span>
        </div>
        <div class="button-group">
          <a href="statistics.html" class="nav-button">Statistics</a>
          <a href="table.html" class="nav-button">Table</a>
          <a href="https://forms.gle/vLCqCySPEkH926AX8" class="nav-button">Add Station</a>
          <a href="/" class="nav-button icon-button">🏠</a>
          <a href="user-guide.html" class="nav-button icon-button">?</a>
          <button id="toggleControlsPanel" class="nav-button">Hide Panel</button>
        </div>
        <input type="range" id="hour" min="0" max="47" value="0" step="1" />
        <div class="locator-group">
          <div class="locator-input">
            <label for="qth">My Locator:</label>
            <input type="text" id="qth" maxlength="6" size="8" placeholder="eg JO89tt" />
          </div>
          <div class="locator-input">
            <label for="dx">DX Locator:</label>
            <input type="text" id="dx" maxlength="6" size="8" placeholder="eg IO91vm" />
          </div>
        </div>
      </div>
      <div id="scrollable-controls">
        <div id="chartWrapper" style="display: none;">
          <div id="chartLabel"></div>
          <canvas id="declinationChart"></canvas>
        </div>
        <div id="dxChartWrapper" style="display: none;">
          <div id="dxchartLabel"></div>
          <canvas id="dxDeclinationChart"></canvas>
        </div>
        <div id="relativeChartWrapper" style="display: none;">
          <div id="relativeChartLabel"></div>
          <canvas id="relativeDataChart"></canvas>
        </div>
        <div id="moonChartWrapper" style="display: block;">
          <div id="moonChartLabel"></div>
          <canvas id="moonDistanceChart"></canvas>
        </div>
      </div>
    </div>
    <button id="showControlsPanel" style="display: none;">→</button>
    
    <script src="chart.js"></script>
    <script src="chartjs-plugin-annotation@1.4.0"></script>
    <script src="l.ob.js"></script>
    <script>
        let chart;
            let dxChart;
            let relativeChart;
            let moonChart;
            let rawData = [];
            let dxRawData = [];
            let moonDataForMonth = [];
            let hourIndex = 0;
            let lat = 0;
            let lon = 0;
            let dxLat = 0;
            let dxLon = 0;
            let moonMarker;
            let footprintCircle;
            let currentPopup = null;
            let map;
            let markers = []; // Array to store station markers for easier management

            const MOON_RADIUS = 1.7374e6;
            const SPEED_OF_LIGHT = 299792458;
            const FREQUENCY_HZ = 10.368e9;

        function computeLibrationForDay(locator, dateStr, type) {
            if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                console.warn(`Invalid locator: ${locator}`);
                return [];
            }

            let lat, lon;
            try {
                ({ lat, lon } = qthToLatLon(locator));
            } catch (e) {
                console.error(`Error converting locator ${locator} to lat/lon: ${e.message}`);
                return [];
            }

            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
                console.error(`Invalid date string: ${dateStr}`);
                return [];
            }
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();

            const results = [];
            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minute = (i % 2) * 30;
                const dt = new Date(Date.UTC(year, month - 1, day, hour, minute));
                const isoDate = dt.toISOString().replace('.000Z', '');

                try {
                    const [libLat, libLon] = EMEastroLib.topocentricLibration(year, month, day, hour, minute, lat, lon);
                    if (isNaN(libLat) || isNaN(libLon) || libLat === null || libLon === null) {
                        throw new Error(`Invalid libration values: lat=${libLat}, lon=${libLon}`);
                    }
                    results.push({
                        date: isoDate,
                        lat: libLat,
                        lon: libLon
                    });
                } catch (e) {
                    console.warn(`Error computing libration for ${isoDate} at ${locator}: ${e.message}`);
                    results.push({
                        date: isoDate,
                        lat: null,
                        lon: null
                    });
                }
            }

            const librationRates = results.map((curr, i, arr) => {
                if (
                    i <= 0 ||
                    i >= arr.length - 1 ||
                    arr[i-1].lat === null ||
                    arr[i-1].lon === null ||
                    arr[i+1].lat === null ||
                    arr[i+1].lon === null ||
                    curr.lat === null ||
                    curr.lon === null
                ) {
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }

                try {
                    const dlat = (arr[i+1].lat - arr[i-1].lat) / 60;
                    const dlon = (arr[i+1].lon - arr[i-1].lon) / 60;
                    if (isNaN(dlat) || isNaN(dlon) || !isFinite(dlat) || !isFinite(dlon)) {
                        console.warn(`Invalid dlat/dlon for ${curr.date} at ${locator}: dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    const rate = Math.sqrt(dlat * dlat + dlon * dlon);
                    if (isNaN(rate) || !isFinite(rate)) {
                        console.warn(`Invalid rate for ${curr.date} at ${locator}: rate=${rate}, dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    return { date: curr.date, rate, dldt: dlat, dbdt: dlon };
                } catch (e) {
                    console.warn(`Error computing rate for ${curr.date} at ${locator}: ${e.message}`);
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }
            });

            const invalidRates = librationRates.filter(r => r.rate === undefined);
            if (invalidRates.length > 0) {
                console.warn(`Undefined rates detected for ${locator} on ${dateStr}:`, invalidRates);
            }

            if (type === 'qth') {
                rawData = librationRates.slice();
                document.getElementById("chartWrapper").style.display = rawData.some(r => r.rate != null) ? "block" : "none";
            } else {
                dxRawData = librationRates.slice();
                document.getElementById("dxChartWrapper").style.display = dxRawData.some(r => r.rate != null) ? "block" : "none";
            }
            return librationRates;
        }
        
        function decodeEmail(obfuscated) {
            try {
                const reversed = obfuscated.split('').reverse().join('');
                return atob(reversed);
            } catch (e) {
                return '';
            }
        }
        
        function initMap() {
                // Initialize Leaflet map
                map = L.map('map', {
                    zoom: 2,
                    center: [0, 0],
                    zoomControl: false,
                    scrollWheelZoom: true,
                    attributionControl: true,
                    worldCopyJump: true // Required for greatCircle wrapping
                });

                // Add OpenStreetMap tile layer (or another provider)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 18,
                    tileSize: 256
                }).addTo(map);

                // Fetch and add station markers
                fetch('stn_10GHz.json')
                    .then(response => response.json())
                    .then(data => {
                        data.forEach(station => {
                            const {
                                Call: callsign,
                                Locator: locator,
                                Antenna: antenna,
                                Power: power,
                                Website: website,
                                CK: obfuscatedEmail = '',
                                Coordinates,
                                Note = '',
                                Name = ''
                            } = station;

                            const email = decodeEmail(obfuscatedEmail);

                            const [latStr, lngStr] = Coordinates.split(',');
                            const lat = parseFloat(latStr);
                            const lng = parseFloat(lngStr);
                            if (isNaN(lat) || isNaN(lng)) return;

                            const offsetLat = 0.1;
                            const offsetLng = 0.1;
                            const markerPosition = [lat + (offsetLat / 10000), lng + (offsetLng / 10000)];

                            let iconUrl = "images/EME_home.png";
                            if (/Inactive/i.test(Note)) {
                                iconUrl = "images/EME_inactive.png";
                            } else if (/SK/i.test(Note)) {
                                iconUrl = "images/EME_SK.png";
                            } else if (/DXpedition|Portable/i.test(Note)) {
                                iconUrl = "images/EME_dxped2.png";
                            }

                            const markerIcon = L.icon({
                                iconUrl: iconUrl,
                                iconSize: [20, 20],
                                iconAnchor: [10, 10] // Center the icon
                            });

                            const marker = L.marker(markerPosition, {
                                icon: markerIcon,
                                title: callsign
                            }).addTo(map);

                            markers.push(marker); // Store marker for potential future use

                            const isLocatorValid = /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator);
                            const sanitizedCallsign = sanitizeCallsign(callsign);
                            const skedButton = isLocatorValid ?
                                `<button id="sked-${sanitizedCallsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>` :
                                '';
                            const emailButton = email ?
                                `<a id="email-${sanitizedCallsign}" class="email-button" href="mailto:${email}">Email</a>` :
                                '';
                            const qrzButton = `<a id="qrz-${sanitizedCallsign}" class="qrz-button" href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ</a>`;
                            const callsignDisplay = callsign +
                                (/SK/i.test(Note) ? ' (SK)' : '') +
                                (/Inactive/i.test(Note) ? ' (not active)' : '');
                            const nameLine = Name ? `<div><strong>${Name}</strong></div>` : '';
                            const displayWebsite = website.length > 30 ? website.slice(0, 30) + '...' : website;
                            const infoContent = `
                                <div>
                                    <div style="font-weight:bold; font-size: 16px;">${callsignDisplay}</div>
                                    ${nameLine}
                                    <div class="button-group-infowindow">
                                        ${skedButton}${emailButton}${qrzButton}
                                    </div>
                                    <div>Locator: ${locator}</div>
                                    <div>Antenna: ${antenna}</div>
                                    <div>Power: ${power}</div>
                                    <div>Website: <a href="${website}" target="_blank">${displayWebsite}</a></div>
                                    <div id="image-container-${sanitizedCallsign}">
                                        Station Picture (clickable):<br>
                                        <a href="db/${sanitizedCallsign}.jpg" target="_blank">
                                            <img id="station-image-${sanitizedCallsign}" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA" alt="${callsign} station"/>
                                        </a>
                                        <div id="image-placeholder-${sanitizedCallsign}" style="display:none;">
                                            <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                                        </div>
                                    </div>
                                </div>
                            `;

                            marker.bindPopup(infoContent, {
                                maxWidth: 300,
                                closeOnClick: false,
                                autoClose: false
                            });

                            marker.on('click', () => {
                                if (currentPopup) {
                                    currentPopup.closePopup();
                                }
                                marker.openPopup();
                                currentPopup = marker;

                                setTimeout(() => {
                                    const imageElement = document.getElementById(`station-image-${sanitizedCallsign}`);
                                    const placeholder = document.getElementById(`image-placeholder-${sanitizedCallsign}`);
                                    const imageUrl = `db/${sanitizedCallsign}_thumb.jpg`;

                                    fetch(imageUrl, { method: 'HEAD' })
                                        .then(response => {
                                            if (!response.ok) {
                                                imageElement.remove();
                                                placeholder.style.display = 'block';
                                            } else {
                                                imageElement.src = imageUrl;
                                                placeholder.style.display = 'none';
                                            }
                                        })
                                        .catch(() => {
                                            imageElement.remove();
                                            placeholder.style.display = 'block';
                                        });

                                    const skedButton = document.getElementById(`sked-${sanitizedCallsign}`);
                                    if (skedButton) {
                                        skedButton.addEventListener('click', () => {
                                            const locator = skedButton.getAttribute('data-locator');
                                            document.getElementById('dx').value = locator;
                                            const inputEvent = new Event('input', { bubbles: true });
                                            document.getElementById('dx').dispatchEvent(inputEvent);
                                        });
                                    }

                                    const emailButton = document.getElementById(`email-${sanitizedCallsign}`);
                                    if (emailButton) {
                                        emailButton.addEventListener('click', () => {
                                            console.log(`Email button clicked for ${callsign}: ${email}`);
                                        });
                                    }

                                    const qrzButton = document.getElementById(`qrz-${sanitizedCallsign}`);
                                    if (qrzButton) {
                                        qrzButton.addEventListener('click', () => {
                                            console.log(`QRZ button clicked for ${callsign}: https://www.qrz.com/db/${callsign}`);
                                        });
                                    }
                                }, 100);
                            });
                        });
                    })
                    .catch(() => { /* Handle error silently */ });
            }

        function updateMap() {
            const selectedDate = document.getElementById('date').value;
            const index = parseInt(document.getElementById('hour').value);
            const hour = Math.floor(index / 2).toString().padStart(2, '0');
            const minutes = index % 2 === 0 ? '00' : '30';
            const utcTimeString = `${selectedDate}T${hour}:${minutes}:00Z`;

            if (!selectedDate || !/^\d{4}-\d{2}-\d{2}$/.test(selectedDate)) {
                console.warn(`Invalid or missing date in updateMap: ${selectedDate}`);
                return;
            }

            const utcDate = new Date(utcTimeString);
            if (isNaN(utcDate.getTime())) {
                console.error(`Invalid date string in updateMap: ${utcTimeString}`);
                return;
            }

            try {
                const time = Astronomy.MakeTime(utcDate);
                const observer = new Astronomy.Observer(0, 0, 0);
                const moon = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
                const libration = Astronomy.Libration(time);

                if (!moon || !libration) {
                    console.warn(`Failed to compute Moon data for ${utcTimeString}`);
                    return;
                }

                const raHours = moon.ra;
                const decDeg = moon.dec;
                const raDeg = raHours * 15;
                let gastDeg = Astronomy.SiderealTime(time) * 15;
                gastDeg = ((gastDeg % 360) + 360) % 360;

                // Correct longitude calculation
                let lonDeg = raDeg - gastDeg;
                lonDeg = ((lonDeg + 180) % 360) - 180; // Normalize to [-180, 180]

                const lat = decDeg;
                const lon = lonDeg;

                const earthRadius = 6371; // km
                const D_moon = libration.dist_km; // Moon distance in km
                const cosTheta = earthRadius / (earthRadius + D_moon);
                const theta_rad = Math.acos(cosTheta); // Angular radius to horizon
                const footprintRadius = earthRadius * theta_rad * 1000; // Surface distance in meters

                if (isNaN(lat) || isNaN(lon) || isNaN(footprintRadius)) {
                    console.warn(`Invalid sublunar point data for ${utcTimeString}: lat=${lat}, lon=${lon}, radius=${footprintRadius}`);
                    return;
                }

                console.log(`Sublunar point: lat=${lat.toFixed(2)}, lon=${lon.toFixed(2)}, RA=${raHours.toFixed(2)}h, Dec=${decDeg.toFixed(2)}°, GAST=${(gastDeg/15).toFixed(2)}h`);
                console.log(`Moon distance: ${D_moon.toFixed(2)} km, theta_rad: ${theta_rad.toFixed(4)} radians, footprintRadius: ${footprintRadius.toFixed(2)} meters`);

                // Remove existing moon marker and circle
                if (moonMarker) {
                    moonMarker.remove();
                    moonMarker = null; // Reset to avoid stale references
                }
                if (footprintCircle) {
                    footprintCircle.remove();
                    footprintCircle = null; // Reset to avoid stale references
                }

                // Add new moon marker
                const moonIcon = L.icon({
                    iconUrl: 'images/moon-icon.png',
                    iconSize: [48, 48],
                    iconAnchor: [24, 24]
                });

                moonMarker = L.marker([lat, lon], {
                    icon: moonIcon,
                    title: `Moon Sublunar Point (${lat.toFixed(2)}°, ${lon.toFixed(2)}°)`
                }).addTo(map);

                // Use Leaflet.greatCircle to render the footprint
                footprintCircle = L.greatCircle([lat, lon], {
                    radius: footprintRadius, // Radius in meters
                    color: '#0000FF', // Blue stroke
                    fillColor: '#0088FF',
                    fillOpacity: 0.3,
                    weight: 2,
                    wrapElements: false, // Enable wrapping around the globe
                    clipLat: 65, // Render as polygon near poles
                    degStep: 0.5, // Smoothness of polygon rendering
                    maxCopies: -1 // Automatic number of wrapped copies
                }).addTo(map);

                // Ensure footprintCircle is valid before calling bringToFront
                if (footprintCircle) {
                    footprintCircle.bringToFront(); // Ensure circle is on top
                } else {
                    console.warn(`Failed to create footprintCircle for ${utcTimeString}`);
                }

                // Center map on sublunar point and set zoom
                map.panTo([lat, lon]);
                map.setZoom(2); // Global view to see full footprint

            } catch (error) {
                console.error(`Error calculating sublunar point for ${utcTimeString}: ${error.message}`);
                // Ensure footprintCircle and moonMarker are cleared on error
                if (moonMarker) {
                    moonMarker.remove();
                    moonMarker = null;
                }
                if (footprintCircle) {
                    footprintCircle.remove();
                    footprintCircle = null;
                }
            }
        }

        function calculateMoonDataForMonth(dateStr) {
            const startDate = new Date(dateStr);
            startDate.setUTCDate(1);
            const endDate = new Date(startDate);
            endDate.setUTCDate(endDate.getUTCDate() + 30);

            const data = [];
            const labels = [];

            const observer = new Astronomy.Observer(0, 0, 0);

            for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
                try {
                    const dateString = dt.toISOString().slice(0, 10);
                    const time = `${dateString}T00:00:00Z`;
                    const astroTime = Astronomy.MakeTime(new Date(time));
                    
                    const libration = Astronomy.Libration(astroTime);
                    const distanceKm = libration.dist_km;

                    const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, observer, true, true);
                    
                    if (!moonEq || distanceKm == null) {
                        throw new Error("Invalid Moon data");
                    }

                    const declination = moonEq.dec;

                    if (distanceKm != null && declination != null) {
                        data.push({
                            date: dateString,
                            distance: distanceKm,
                            declination: declination
                        });
                        const day = String(dt.getUTCDate()).padStart(2, '0');
                        const month = String(dt.getUTCMonth() + 1).padStart(2, '0');
                        labels.push(`${day}-${month}`);
                    } else {
                        console.warn(`Missing data for ${dateString}: distance=${distanceKm}, declination=${declination}`);
                    }
                } catch (e) {
                    console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
                }
            }

            return { data, labels };
        }

        function updateMoonChart() {
            const dateInput = document.getElementById("date").value;
            const index = parseInt(document.getElementById("hour").value);
            const hour = Math.floor(index / 2);
            const minutes = (index % 2) * 30;
            const selectedDateTime = new Date(`${dateInput}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
            const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

            const distances = moonData.map(d => d.distance);
            const declinations = moonData.map(d => d.declination);
            const selectedDay = selectedDateTime.getUTCDate() - 1;

            let currentDistance = null;
            let currentDeclination = null;
            let pathLoss = null;
            const minDist = 356352.93;

            try {
                const astroTime = Astronomy.MakeTime(selectedDateTime);
                const observer = new Astronomy.Observer(0, 0, 0);
                const libration = Astronomy.Libration(astroTime);
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, observer, true, true);
                
                if (libration && moonEq) {
                    currentDistance = libration.dist_km;
                    currentDeclination = moonEq.dec;
                    if (currentDistance != null) {
                        pathLoss = 40 * Math.log10(currentDistance / minDist);
                    }
                } else {
                    throw new Error("Invalid current Moon data");
                }
            } catch (e) {
                console.warn(`Error calculating current Moon data for ${selectedDateTime.toISOString()}: ${e.message}`);
            }

            const moonAnnotation = {
                timeMarker: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: selectedDay,
                    borderColor: 'black',
                    borderWidth: 2,
                    label: {
                        enabled: false
                    }
                }
            };

            document.getElementById('moonChartLabel').innerHTML =
                `<span class="metric-label metric-distance">Distance:</span> ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-declination">Declination:</span> ${currentDeclination != null ? currentDeclination.toFixed(1) + '°' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-pathloss">Extra Loss:</span> ${pathLoss != null ? pathLoss.toFixed(2) + ' dB' : 'N/A'}`;

            if (!moonChart) {
                moonChart = new Chart(document.getElementById("moonDistanceChart"), {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: "Moon Distance (km)",
                                data: distances,
                                borderColor: "#800080",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y1"
                            },
                            {
                                label: "Moon Declination (°)",
                                data: declinations,
                                borderColor: "#FFA500",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y2"
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: "Date (DD-MM)",
                                    font: { size: 10, family: 'Arial, sans-serif' }
                                },
                                ticks: { font: { size: 10 } }
                            },
                            y1: {
                                type: "linear",
                                display: true,
                                position: "left",
                                title: {
                                    display: true,
                                    text: "Distance (\u00D710³ km)",
                                    color: "#800080",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: 356400,
                                max: 406700,
                                ticks: {
                                    stepSize: 10000,
                                    color: "#800080",
                                    font: { size: 12 },
                                    callback: function(value) {
                                        return (value / 1000).toFixed(0);
                                    }
                                },
                                grid: { drawTicks: true, drawBorder: true }
                            },
                            y2: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: {
                                    display: true,
                                    text: "Declination (°)",
                                    color: "#FFA500",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: -30,
                                max: 30,
                                ticks: {
                                    stepSize: 10,
                                    callback: val => val + "°",
                                    color: "#FFA500",
                                    font: { size: 12 }
                                },
                                grid: { drawOnChartArea: false }
                            },
                            y3: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: {
                                    display: true,
                                    text: "Extra Path Loss (dB)",
                                    color: "#800080",
                                    font: { size: 12, family: 'Arial, sans-serif' }
                                },
                                min: 0,
                                max: 2.5,
                                ticks: {
                                    stepSize: 0.5,
                                    callback: val => val.toFixed(1),
                                    color: "#800080",
                                    font: { size: 12 }
                                },
                                grid: { drawOnChartArea: false },
                                offset: true
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            annotation: { annotations: moonAnnotation }
                        }
                    }
                });
            } else {
                moonChart.data.labels = labels;
                moonChart.data.datasets[0].data = distances;
                moonChart.data.datasets[1].data = declinations;
                moonChart.options.plugins.annotation.annotations = moonAnnotation;
                moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedDay;
                moonChart.options.scales.y1.min = 356400;
                moonChart.options.scales.y1.max = 406700;
                moonChart.options.scales.y2.min = -30;
                moonChart.options.scales.y2.max = 30;
                moonChart.options.scales.y3.min = 0;
                moonChart.options.scales.y3.max = 2.5;
                moonChart.update('none');
            }
        }

        function updateChart(hourIndex) {
            const qthInput = document.getElementById("qth").value.trim().toUpperCase();
            const dxInput = document.getElementById("dx").value.trim().toUpperCase();
            const dateInput = document.getElementById("date").value;
            const dateStr = new Date(dateInput).toISOString().slice(0, 10);

            let dataForDay = Array(48).fill(null);
            if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                const rawDataDate = rawData.length ? rawData[0]?.date.slice(0, 10) : null;
                if (rawDataDate !== dateStr || rawData.length !== 48) {
                    rawData = [];
                    computeLibrationForDay(qthInput, dateStr, 'qth');
                }
                rawData.forEach((r, idx) => {
                    const timeMatch = r.date.match(/T(\d{2}):(\d{2})/);
                    if (!timeMatch) {
                        console.warn(`Invalid date format in rawData[${idx}]: ${r.date}`);
                        return;
                    }
                    const hour = parseInt(timeMatch[1], 10);
                    const minute = parseInt(timeMatch[2], 10);
                    const index = hour * 2 + (minute === 30 ? 1 : 0);
                    if (index >= 0 && index < 48) {
                        dataForDay[index] = r;
                    } else {
                        console.warn(`Invalid index ${index} for date ${r.date} in rawData[${idx}]`);
                    }
                });
            }

            let moonElevations = [];
            let moonAzimuths = [];
            let visibleRates = [];
            let dopplerSpreads = [];

            if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && dataForDay.some(r => r != null)) {
                ({ lat, lon } = qthToLatLon(qthInput));
                for (let i = 0; i < 48; i++) {
                    const hour = Math.floor(i / 2);
                    const minutes = (i % 2) * 30;
                    const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
                    const observer = new Astronomy.Observer(lat, lon, 0);
                    const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                    const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                    const elevationDeg = hor.altitude;
                    const azimuthDeg = hor.azimuth;

                    if (elevationDeg > 0) {
                        moonElevations.push(elevationDeg);
                        moonAzimuths.push(azimuthDeg);
                        const rate = dataForDay[i]?.rate ?? null;
                        visibleRates.push(rate != null ? rate * 1000 : null);
                        const omegaRadSec = rate != null ? rate * (Math.PI / 180) / 60 : 0;
                        const dopplerHz = rate != null ? (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT : null;
                        dopplerSpreads.push(dopplerHz);
                    } else {
                        moonElevations.push(null);
                        moonAzimuths.push(null);
                        visibleRates.push(null);
                        dopplerSpreads.push(null);
                    }
                }
                document.getElementById("chartWrapper").style.display = "block";
            } else {
                moonElevations = Array(48).fill(null);
                moonAzimuths = Array(48).fill(null);
                visibleRates = Array(48).fill(null);
                dopplerSpreads = Array(48).fill(null);
                document.getElementById("chartWrapper").style.display = "none";
            }

            const qthAnnotation = {
                timeMarker: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: hourIndex,
                    borderColor: 'black',
                    borderWidth: 2,
                    label: { enabled: false }
                }
            };

            if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && dataForDay.some(r => r != null)) {
                try {
                    const { lat, lon } = qthToLatLon(qthInput);
                    const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
                    Object.assign(qthAnnotation, moonAnnotations);
                } catch (e) {
                    console.warn(`Error getting moon annotations for QTH: ${e.message}`);
                }

                const labels = Array(48).fill('').map((_, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`);

                if (!chart) {
                    chart = new Chart(document.getElementById("declinationChart"), {
                        type: 'line',
                        data: {
                            labels,
                            datasets: [
                                {
                                    label: "Libration Rate (×10⁻³ °/min)",
                                    data: visibleRates,
                                    borderColor: "#ff0000",
                                    pointRadius: 0,
                                    borderWidth: 1.5,
                                    tension: 0.2,
                                    yAxisID: "y1"
                                },
                                {
                                    label: "Moon Elevation (°)",
                                    data: moonElevations,
                                    borderColor: "rgba(0, 0, 255, 0.6)",
                                    backgroundColor: "rgba(0, 0, 255, 0.15)",
                                    fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                                    pointRadius: 0,
                                    borderWidth: 1,
                                    tension: 0.3,
                                    yAxisID: "y2"
                                },
                                {
                                    label: "Doppler Spread, Hz",
                                    data: dopplerSpreads,
                                    borderColor: "green",
                                    pointRadius: 0,
                                    borderWidth: 1.5,
                                    tension: 0.2,
                                    yAxisID: "y3"
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                                    ticks: { font: { size: 10 } }
                                },
                                y1: {
                                    type: "linear",
                                    display: true,
                                    position: "right",
                                    title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                                    min: 0,
                                    max: 5,
                                    ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                                    grid: { drawTicks: true, drawBorder: true }
                                },
                                y2: {
                                    position: "left",
                                    display: true,
                                    min: 0,
                                    max: 90,
                                    title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                                    grid: { drawOnChartArea: false },
                                    ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                                },
                                y3: {
                                    type: "linear",
                                    display: true,
                                    position: "right",
                                    offset: true,
                                    title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                                    min: 0,
                                    max: 300,
                                    grid: { drawOnChartArea: false },
                                    ticks: { stepSize: 50, color: "green", font: { size: 12 } }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                annotation: { annotations: qthAnnotation }
                            }
                        }
                    });
                } else {
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = visibleRates;
                    chart.data.datasets[1].data = moonElevations;
                    chart.data.datasets[2].data = dopplerSpreads;
                    chart.options.plugins.annotation.annotations = qthAnnotation;
                    chart.options.plugins.annotation.annotations.timeMarker.value = hourIndex;
                }

                const elev = moonElevations[hourIndex];
                const rate = visibleRates[hourIndex] != null ? (visibleRates[hourIndex] / 1000).toFixed(4) : null;
                const doppler = dopplerSpreads[hourIndex];
                const azimuth = moonAzimuths[hourIndex];
                document.getElementById('chartLabel').innerHTML =
                    qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && rawData.length > 0
                        ? `<span class="metric-locator">${qthInput}</span>` +
                          `<span class="metric-separator"></span>` +
                          `<span class="metric-label metric-elevation">El:</span> ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-azimuth">Az:</span> ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-libration">Libr:</span> ${rate != null ? rate + '°/min' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-doppler">Spread:</span> ${doppler != null ? doppler.toFixed(0) + ' Hz' : 'N/A'}`
                        : `<span class="metric-locator">${rawData.length ? 'Computing QTH data...' : 'Enter valid QTH'}</span>`;
                chart.update('none');
            } else {
                document.getElementById("chartWrapper").style.display = "none";
                if (chart) {
                    chart.destroy();
                    chart = null;
                }
                document.getElementById('chartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
            }

            let dxMoonElevations = [];
            let dxMoonAzimuths = [];
            let dxVisibleRates = [];
            let dxDopplerSpreads = [];
            let relativeLibrationRates = [];
            let relativeDopplerSpreads = [];
            let polOffsets = [];
            let dxDataForDay = Array(48).fill(null);

            if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                try {
                    ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
                } catch (e) {
                    console.error(`Error converting DX locator ${dxInput} to lat/lon: ${e.message}`);
                    dxLat = 0;
                    dxLon = 0;
                }

                const dxRawDataDate = dxRawData.length ? dxRawData[0]?.date.slice(0, 10) : null;
                if (dxRawDataDate !== dateStr || dxRawData.length !== 48) {
                    dxRawData = [];
                    computeLibrationForDay(dxInput, dateStr, 'dx');
                }
                dxRawData.forEach((r, idx) => {
                    const timeMatch = r.date.match(/T(\d{2}):(\d{2})/);
                    if (!timeMatch) {
                        console.warn(`Invalid date format in dxRawData[${idx}]: ${r.date}`);
                        return;
                    }
                    const hour = parseInt(timeMatch[1], 10);
                    const minute = parseInt(timeMatch[2], 10);
                    const index = hour * 2 + (minute === 30 ? 1 : 0);
                    if (index >= 0 && index < 48) {
                        dxDataForDay[index] = r;
                    } else {
                        console.warn(`Invalid DX index ${index} for date ${r.date} in dxRawData[${idx}]`);
                    }
                });

                for (let i = 0; i < 48; i++) {
                    const hour = Math.floor(i / 2);
                    const minutes = (i % 2) * 30;
                    const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);

                    const dxObserver = new Astronomy.Observer(dxLat, dxLon, 0);
                    const dxMoonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, dxObserver, true, false);
                    const dxHor = Astronomy.Horizon(dt, dxObserver, dxMoonEq.ra, dxMoonEq.dec, 'normal');
                    const dxElevationDeg = dxHor.altitude;
                    const dxAzimuthDeg = dxHor.azimuth;

                    let qthElevationDeg = null;
                    let qthAzimuthDeg = null;
                    if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                        const qthObserver = new Astronomy.Observer(lat, lon, 0);
                        const qthMoonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, qthObserver, true, false);
                        const qthHor = Astronomy.Horizon(dt, qthObserver, qthMoonEq.ra, qthMoonEq.dec, 'normal');
                        qthElevationDeg = qthHor.altitude;
                        qthAzimuthDeg = qthHor.azimuth;
                    }

                    let relLibrationRate = null;
                    let relDopplerSpread = null;
                    let polOffset = null;
                    let rate = dxDataForDay[i]?.rate ?? null;

                    if (
                        qthInput && dxInput &&
                        dataForDay[i]?.dldt != null && dataForDay[i]?.dbdt != null &&
                        dxDataForDay[i]?.dldt != null && dxDataForDay[i]?.dbdt != null &&
                        dxElevationDeg > 0 && qthElevationDeg > 0
                    ) {
                        const dldt_sum = dataForDay[i].dldt + dxDataForDay[i].dldt;
                        const dbdt_sum = dataForDay[i].dbdt + dxDataForDay[i].dbdt;
                        relLibrationRate = Math.sqrt(dldt_sum * dldt_sum + dbdt_sum * dbdt_sum) / 2 * 1000;
                        if (isNaN(relLibrationRate) || !isFinite(relLibrationRate)) {
                            console.warn(`Invalid relative libration rate for ${dt.toISOString()}: dldt_sum=${dldt_sum}, dbdt_sum=${dbdt_sum}`);
                            relLibrationRate = null;
                        } else {
                            const omegaRadSec = relLibrationRate * (Math.PI / 180) / 60 / 1000;
                            relDopplerSpread = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                            if (isNaN(relDopplerSpread) || !isFinite(relDopplerSpread)) {
                                console.warn(`Invalid relative Doppler spread for ${dt.toISOString()}: relLibrationRate=${relLibrationRate}`);
                                relDopplerSpread = null;
                            }
                        }

                        const polQth = calcPoloffset(lat, qthAzimuthDeg, qthElevationDeg);
                        const polDx = calcPoloffset(dxLat, dxAzimuthDeg, dxElevationDeg);
                        polOffset = calcPoloffsetDiff(polQth, polDx);
                        if (isNaN(polOffset) || !isFinite(polOffset)) {
                            console.warn(`Invalid polOffset for ${dt.toISOString()}: polQth=${polQth}, polDx=${polDx}`);
                            polOffset = null;
                        }
                    }

                    if (dxElevationDeg > 0 && rate != null && !isNaN(rate) && isFinite(rate)) {
                        dxMoonElevations.push(dxElevationDeg);
                        dxMoonAzimuths.push(dxAzimuthDeg);
                        dxVisibleRates.push(rate * 1000);
                        const omegaRadSec = rate * (Math.PI / 180) / 60;
                        const dopplerHz = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                        dxDopplerSpreads.push(isNaN(dopplerHz) || !isFinite(dopplerHz) ? null : dopplerHz);
                        relativeLibrationRates.push(relLibrationRate);
                        relativeDopplerSpreads.push(relDopplerSpread);
                        polOffsets.push(polOffset);
                    } else {
                        dxMoonElevations.push(null);
                        dxMoonAzimuths.push(null);
                        dxVisibleRates.push(null);
                        dxDopplerSpreads.push(null);
                        relativeLibrationRates.push(null);
                        relativeDopplerSpreads.push(null);
                        polOffsets.push(null);
                    }
                }
                document.getElementById("dxChartWrapper").style.display = dxDataForDay.some(r => r?.rate != null) ? "block" : "none";
            } else {
                document.getElementById("dxChartWrapper").style.display = "none";
            }

            const dxAnnotation = {
                timeMarker: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: hourIndex,
                    borderColor: 'black',
                    borderWidth: 2,
                    label: { enabled: false }
                }
            };

            if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                try {
                    const moonAnnotations = getMoonAnnotations(dateStr, dxLat, dxLon);
                    Object.assign(dxAnnotation, moonAnnotations);
                } catch (e) {
                    console.warn(`Error getting moon annotations for DX: ${e.message}`);
                }
            }

            const labels = Array(48).fill('').map((_, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`);

            if (!dxChart && dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && dxDataForDay.some(r => r != null)) {
                dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: "Libration Rate (×10⁻³ °/min)",
                                data: dxVisibleRates,
                                borderColor: "#ff0000",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y1"
                            },
                            {
                                label: "Moon Elevation (°)",
                                data: dxMoonElevations,
                                borderColor: "rgba(0, 0, 255, 0.6)",
                                backgroundColor: "rgba(0, 0, 255, 0.15)",
                                fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                                pointRadius: 0,
                                borderWidth: 1,
                                tension: 0.3,
                                yAxisID: "y2"
                            },
                            {
                                label: "Doppler Spread, Hz",
                                data: dxDopplerSpreads,
                                borderColor: "green",
                                pointRadius: 0,
                                borderWidth: 1.5,
                                tension: 0.2,
                                yAxisID: "y3"
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                                ticks: { font: { size: 10 } }
                            },
                            y1: {
                                type: "linear",
                                display: true,
                                position: "right",
                                title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                                grid: { drawTicks: true, drawBorder: true }
                            },
                            y2: {
                                position: "left",
                                display: true,
                                min: 0,
                                max: 90,
                                title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                                grid: { drawOnChartArea: false },
                                ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                            },
                            y3: {
                                type: "linear",
                                display: true,
                                position: "right",
                                offset: true,
                                title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                                min: 0,
                                max: 300,
                                grid: { drawOnChartArea: false },
                                ticks: { stepSize: 50, color: "green", font: { size: 12 } }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            annotation: { annotations: dxAnnotation }
                        }
                    }
                });
            }

            if (dxChart) {
                dxChart.data.labels = labels;
                dxChart.data.datasets[0].data = dxVisibleRates;
                dxChart.data.datasets[1].data = dxMoonElevations;
                dxChart.data.datasets[2].data = dxDopplerSpreads;
                const elev = dxMoonElevations[hourIndex];
                const rate = dxVisibleRates[hourIndex] != null ? (dxVisibleRates[hourIndex] / 1000).toFixed(4) : null;
                const doppler = dxDopplerSpreads[hourIndex];
                const azimuth = dxMoonAzimuths[hourIndex];
                document.getElementById('dxchartLabel').innerHTML =
                    dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && dxDataForDay[hourIndex]
                        ? `<span class="metric-locator">${dxInput}</span>` +
                          `<span class="metric-separator"></span>` +
                          `<span class="metric-label metric-elevation">El:</span> ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-azimuth">Az:</span> ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-libration">Libr:</span> ${rate != null ? rate + '°/min' : 'N/A'}` +
                          `<span class="metric-separator">|</span>` +
                          `<span class="metric-label metric-doppler">Spread:</span> ${doppler != null ? doppler.toFixed(0) + ' Hz' : 'N/A'}`
                        : '<span class="metric-locator">Enter valid DX</span>';
                dxChart.options.plugins.annotation.annotations = dxAnnotation;
                dxChart.options.plugins.annotation.annotations.timeMarker.value = hourIndex;
                dxChart.update('none');
            } else {
                document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
                if (dxChart) {
                    dxChart.destroy();
                    dxChart = null;
                }
            }

                                                    const relativeAnnotation = {
                                                        timeMarker: {
                                                            type: 'line',
                                                            mode: 'vertical',
                                                            scaleID: 'x',
                                                            value: hourIndex,
                                                            borderColor: 'black',
                                                            borderWidth: 2,
                                                            label: { enabled: false }
                                                        }
                                                    };

                                                    if (qthInput && dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && relativeLibrationRates.some(r => r != null)) {
                                                        document.getElementById("relativeChartWrapper").style.display = "block";
                                                        try {
                                                            const skedAnnotations = getSkedAnnotations(dateStr, lat, lon, dxLat, dxLon);
                                                            Object.assign(relativeAnnotation, skedAnnotations);
                                                        } catch (e) {
                                                            console.warn(`Error getting sked annotations: ${e.message}`);
                                                        }

                                                        if (!relativeChart) {
                                                            relativeChart = new Chart(document.getElementById("relativeDataChart"), {
                                                                type: 'line',
                                                                data: {
                                                                    labels,
                                                                    datasets: [
                                                                        {
                                                                            label: "Relative Libration (×10⁻³ °/min)",
                                                                            data: relativeLibrationRates,
                                                                            borderColor: "red",
                                                                            pointRadius: 0,
                                                                            borderWidth: 1.5,
                                                                            tension: 0.2,
                                                                            yAxisID: "y1"
                                                                        },
                                                                        {
                                                                            label: "Relative Spread, Hz",
                                                                            data: relativeDopplerSpreads,
                                                                            borderColor: "green",
                                                                            pointRadius: 0,
                                                                            borderWidth: 1.5,
                                                                            tension: 0.2,
                                                                            yAxisID: "y2"
                                                                        },
                                                                        {
                                                                            label: "Polarization Offset (°)",
                                                                            data: polOffsets,
                                                                            borderColor: "blue",
                                                                            pointRadius: 0,
                                                                            borderWidth: 1.5,
                                                                            tension: 0.2,
                                                                            yAxisID: "y3"
                                                                        }
                                                                    ]
                                                                },
                                                                options: {
                                                                    responsive: true,
                                                                    maintainAspectRatio: false,
                                                                    scales: {
                                                                        x: {
                                                                            title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                                                                            ticks: { font: { size: 10 } }
                                                                        },
                                                                        y1: {
                                                                            type: "linear",
                                                                            display: true,
                                                                            position: "right",
                                                                            title: { display: true, text: "Rel. Libration (×10⁻³ °/min)", color: "red", font: { size: 10, family: 'Arial, sans-serif' } },
                                                                            min: 0,
                                                                            max: 5,
                                                                            ticks: { stepSize: 1, color: "red", font: { size: 12 } },
                                                                            grid: { drawTicks: true, drawBorder: true }
                                                                        },
                                                                        y2: {
                                                                            type: "linear",
                                                                            display: true,
                                                                            position: "right",
                                                                            offset: true,
                                                                            title: { display: true, text: "Rel. Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                                                                            min: 0,
                                                                            max: 300,
                                                                            grid: { drawOnChartArea: false },
                                                                            ticks: { stepSize: 50, color: "green", font: { size: 12 } }
                                                                        },
                                                                        y3: {
                                                                            type: "linear",
                                                                            display: true,
                                                                            position: "left",
                                                                            title: { display: true, text: "Polarization Offset (°)", color: "blue", font: { size: 12, family: 'Arial, sans-serif' } },
                                                                            min: -90,
                                                                            max: 90,
                                                                            grid: { drawOnChartArea: false },
                                                                            ticks: { stepSize: 30, callback: val => val + "°", color: "blue", font: { size: 12 } }
                                                                        }
                                                                    },
                                                                    plugins: {
                                                                        legend: { display: false },
                                                                        annotation: { annotations: relativeAnnotation }
                                                                    }
                                                                }
                                                            });
                                                        } else {
                                                            relativeChart.data.labels = labels;
                                                            relativeChart.data.datasets[0].data = relativeLibrationRates;
                                                            relativeChart.data.datasets[1].data = relativeDopplerSpreads;
                                                            relativeChart.data.datasets[2].data = polOffsets;
                                                            relativeChart.options.plugins.annotation.annotations = relativeAnnotation;
                                                            relativeChart.options.plugins.annotation.annotations.timeMarker.value = hourIndex;
                                                            relativeChart.update('none');
                                                        }

                                                        const relRate = relativeLibrationRates[hourIndex] != null ? (relativeLibrationRates[hourIndex] / 1000).toFixed(4) : null;
                                                        const relDoppler = relativeDopplerSpreads[hourIndex];
                                                        const polOffset = polOffsets[hourIndex];
                                                        document.getElementById('relativeChartLabel').innerHTML =
                                                        qthInput && dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)
                                                          ? `<span class="metric-label metric-rel-libration">Rel LR:</span> ${relRate != null ? relRate + '°/min' : 'N/A'}` +
                                                            `<span class="metric-separator"> | </span>` +
                                                            `<span class="metric-label metric-rel-doppler">DX Width:</span> ${relDoppler != null ? relDoppler.toFixed(0) + ' Hz' : 'N/A'}` +
                                                            `<span class="metric-separator"> | </span>` +
                                                            `<span class="metric-label metric-poloffset">Dpol:</span> ${polOffset != null ? polOffset.toFixed(1) + '°' : 'N/A'}`
                                                          : '<span class="metric-locator">Enter valid QTH and DX</span>';

                                                    } else {
                                                        document.getElementById("relativeChartWrapper").style.display = "none";
                                                        if (relativeChart) {
                                                            relativeChart.destroy();
                                                            relativeChart = null;
                                                        }
                                                        document.getElementById('relativeChartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH and DX</span>';
                                                    }

            updateMap();
            updateMoonChart();
        }
                                        
                                                                    function getMoonAnnotations(dateStr, lat, lon) {
                                                                        const observer = new Astronomy.Observer(lat, lon, 0);
                                                                        const jsDate = new Date(`${dateStr}T00:00:00Z`);
                                                                        const astroTime = Astronomy.MakeTime(jsDate);

                                                                        let riseEvent = null, setEvent = null;
                                                                        try {
                                                                            riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
                                                                        } catch (e) {
                                                                            console.warn(`Error calculating moonrise for ${dateStr}: ${e.message}`);
                                                                        }

                                                                        try {
                                                                            setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
                                                                        } catch (e) {
                                                                            console.warn(`Error calculating moonset for ${dateStr}: ${e.message}`);
                                                                        }

                                                                        const annotations = {};

                                                                        function formatTimeUTC(date) {
                                                                            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
                                                                        }

                                                                        const targetDateStr = dateStr.slice(0, 10);

                                                                        if (riseEvent && riseEvent.date) {
                                                                            const riseDate = riseEvent.date;
                                                                            const riseDateStr = riseDate.toISOString().slice(0, 10);
                                                                            if (riseDateStr === targetDateStr) {
                                                                                let index = timeToChartIndex(riseDate);
                                                                                const isLate = riseDate.getUTCHours() >= 23 && riseDate.getUTCMinutes() >= 30;
                                                                                annotations['moonrise'] = {
                                                                                    type: 'line',
                                                                                    mode: 'vertical',
                                                                                    scaleID: 'x',
                                                                                    value: isLate ? 47 : index,
                                                                                    borderColor: 'blue',
                                                                                    borderWidth: 1,
                                                                                    label: {
                                                                                        content: ['Rise', formatTimeUTC(riseDate)],
                                                                                        enabled: true,
                                                                                        position: 'top',
                                                                                        yAdjust: isLate ? -50 : -40,
                                                                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                                                                        color: 'white',
                                                                                        backgroundColor: 'rgba(0, 0, 255, 0.85)',
                                                                                        padding: 2,
                                                                                        cornerRadius: 6,
                                                                                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                                                                        textAlign: 'center',
                                                                                        borderColor: 'rgba(255, 255, 255, 0.7)',
                                                                                        borderWidth: 1
                                                                                    }
                                                                                };
                                                                            }
                                                                        }

                                                                        if (setEvent && setEvent.date) {
                                                                            const setDate = setEvent.date;
                                                                            const setDateStr = setDate.toISOString().slice(0, 10);
                                                                            if (setDateStr === targetDateStr) {
                                                                                let index = timeToChartIndex(setDate);
                                                                                const isLate = setDate.getUTCHours() >= 23 && setDate.getUTCMinutes() >= 30;
                                                                                annotations['moonset'] = {
                                                                                    type: 'line',
                                                                                    mode: 'vertical',
                                                                                    scaleID: 'x',
                                                                                    value: isLate ? 47 : index,
                                                                                    borderColor: 'orange',
                                                                                    borderWidth: 1,
                                                                                    label: {
                                                                                        content: ['Set', formatTimeUTC(setDate)],
                                                                                        enabled: true,
                                                                                        position: 'top',
                                                                                        yAdjust: isLate ? -10 : -20,
                                                                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                                                                        color: 'white',
                                                                                        backgroundColor: 'rgba(255, 165, 0, 0.85)',
                                                                                        padding: 2,
                                                                                        cornerRadius: 6,
                                                                                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                                                                        textAlign: 'center',
                                                                                        borderColor: 'rgba(255, 255, 255, 0.7)',
                                                                                        borderWidth: 1
                                                                                    }
                                                                                };
                                                                            }
                                                                        }

                                                                        return annotations;
                                                                    }

                                                                    function timeToChartIndex(date) {
                                                                        if (!(date instanceof Date)) throw new Error("Expected a Date object");
                                                                        let hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
                                                                        if (hours >= 23.5) {
                                                                            hours = 23.5;
                                                                        }
                                                                        return hours * 2;
                                                                    }

                                                    function getSkedAnnotations(dateStr, qthLat, qthLon, dxLat, dxLon) {
                                                        const annotations = {};
                                                        const targetDateStr = dateStr.slice(0, 10);
                                                        const jsDate = new Date(`${dateStr}T00:00:00Z`);
                                                        const astroTime = Astronomy.MakeTime(jsDate);

                                                        const qthObserver = new Astronomy.Observer(qthLat, qthLon, 0);
                                                        const dxObserver = new Astronomy.Observer(dxLat, dxLon, 0);

                                                        let qthRiseEvent = null, qthSetEvent = null, dxRiseEvent = null, dxSetEvent = null;
                                                        try {
                                                            qthRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, +1, astroTime, 1.0);
                                                            qthSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, -1, astroTime, 1.0);
                                                            dxRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, +1, astroTime, 1.0);
                                                            dxSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, -1, astroTime, 1.0);
                                                        } catch (e) {
                                                            console.warn(`Error calculating moonrise/set: ${e.message}`);
                                                            return annotations;
                                                        }

                                                        function formatTimeUTC(date) {
                                                            if (!date) return 'N/A';
                                                            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
                                                        }

                                                        function timeToChartIndex(date) {
                                                            if (!(date instanceof Date)) return null;
                                                            const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
                                                            let index = Math.round(hours * 2);
                                                            if (index < 0) index = 0;
                                                            if (index > 47) index = 47;
                                                            return index;
                                                        }

                                                        let skedStartTime = null, skedEndTime = null;
                                                        if (qthRiseEvent && qthSetEvent && dxRiseEvent && dxSetEvent &&
                                                            qthRiseEvent.date && qthSetEvent.date && dxRiseEvent.date && dxSetEvent.date) {
                                                            const qthRise = qthRiseEvent.date;
                                                            const qthSet = qthSetEvent.date;
                                                            const dxRise = dxRiseEvent.date;
                                                            const dxSet = dxSetEvent.date;

                                                            const isSameDay = (date) => date.toISOString().slice(0, 10) === targetDateStr;

                                                            if (isSameDay(qthRise) && isSameDay(qthSet) && isSameDay(dxRise) && isSameDay(dxSet)) {
                                                                // Sked start is the later of the two rise times
                                                                //skedStartTime = qthRise > dxRise ? qthRise : dxRise;
                                                                // Sked end is the earlier of the two set times
                                                                //skedEndTime = qthSet < dxSet ? qthSet : dxSet;
                                                            }
                                                        }

                                                        if (skedStartTime && skedEndTime) {
                                                            const startIndex = timeToChartIndex(skedStartTime);
                                                            const endIndex = timeToChartIndex(skedEndTime);

                                                            annotations.skedStart = {
                                                                type: 'line',
                                                                mode: 'vertical',
                                                                scaleID: 'x',
                                                                value: startIndex,
                                                                borderColor: 'blue',
                                                                borderWidth: 1,
                                                                label: {
                                                                    enabled: true,
                                                                    content: `Sked Start ${formatTimeUTC(skedStartTime)}`,
                                                                    position: 'start',
                                                                    yAdjust: 10,
                                                                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                                                                    color: 'black',
                                                                    font: { size: 10, weight: 'bold', family: 'Arial, sans-serif' },
                                                                    padding: 2,
                                                                    cornerRadius: 6,
                                                                    borderColor: 'rgba(0, 0, 255, 0.7)',
                                                                    borderWidth: 1,
                                                                    boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                                                    textAlign: 'center'
                                                                }
                                                            };

                                                            annotations.skedEnd = {
                                                                type: 'line',
                                                                mode: 'vertical',
                                                                scaleID: 'x',
                                                                value: endIndex,
                                                                borderColor: 'green',
                                                                borderWidth: 1,
                                                                label: {
                                                                    enabled: true,
                                                                    content: `Sked End ${formatTimeUTC(skedEndTime)}`,
                                                                    position: 'end',
                                                                    yAdjust: -20,
                                                                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                                                                    color: 'black',
                                                                    font: { size: 10, weight: 'bold', family: 'Arial, sans-serif' },
                                                                    padding: 2,
                                                                    cornerRadius: 6,
                                                                    borderColor: 'rgba(0, 128, 0, 0.7)',
                                                                    borderWidth: 1,
                                                                    boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                                                    textAlign: 'center'
                                                                }
                                                            };
                                                        }

                                                        return annotations;
                                                    }

        document.getElementById("hour").addEventListener("input", () => {
            hourIndex = parseInt(document.getElementById("hour").value);
            const hour = Math.floor(hourIndex / 2);
            const minutes = (hourIndex % 2) * 30;
            document.getElementById("hour-value").textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}`;
            updateChart(hourIndex);
        });

        function adjustDate(days) {
            const dateInput = document.getElementById("date");
            const currentDate = new Date(dateInput.value);
            currentDate.setDate(currentDate.getDate() + days);
            dateInput.valueAsDate = currentDate;
            updateChart(hourIndex);
        }

        document.getElementById("prevDay").addEventListener("click", () => {
            adjustDate(-1);
        });

        document.getElementById("nextDay").addEventListener("click", () => {
            adjustDate(1);
        });

        document.getElementById("date").addEventListener("change", () => {
            const qthInput = document.getElementById("qth").value.trim().toUpperCase();
            const dxInput = document.getElementById("dx").value.trim().toUpperCase();
            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
            }
            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
            }
            updateChart(hourIndex);
        });

                                                    window.onload = () => {
                                                            const now = new Date();
                                                            const utcHours = now.getUTCHours();
                                                            const utcMinutes = now.getUTCMinutes();

                                                            const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                                            document.getElementById("date").valueAsDate = utcDate;

                                                            let roundedHour = utcHours;
                                                            let roundedMinutes = utcMinutes >= 15 && utcMinutes < 45 ? 30 : 0;
                                                            if (utcMinutes >= 45) {
                                                                roundedHour += 1;
                                                                roundedMinutes = 0;
                                                            }
                                                            if (roundedHour >= 24) {
                                                                roundedHour -= 24;
                                                                utcDate.setUTCDate(utcDate.getUTCDate() + 1);
                                                                document.getElementById("date").valueAsDate = utcDate;
                                                            }

                                                            hourIndex = roundedHour * 2 + (roundedMinutes === 30 ? 1 : 0);
                                                            document.getElementById("hour").value = hourIndex;
                                                            document.getElementById("hour-value").textContent =
                                                                `Time (UTC): ${String(roundedHour).padStart(2, '0')}:${roundedMinutes === 0 ? '00' : '30'}`;

                                                            document.getElementById("showControlsPanel").classList.remove("visible");

                                                            const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                                                            const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                                                            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                                                                computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
                                                            }
                                                            if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                                                                computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
                                                            }

                                                            initMap(); // Call Leaflet map initialization
                                                            updateMap();
                                                            updateMoonChart();
                                                            updateChart(hourIndex);
                                                        };


        const qthInput = document.getElementById("qth");
        const dxInput = document.getElementById("dx");

                                                                    qthInput.addEventListener("input", () => {
                                                                        const locator = qthInput.value.trim().toUpperCase();
                                                                        const chartLabel = document.getElementById('chartLabel');
                                                                        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                                            chartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                                            try {
                                                                                computeLibrationForDay(locator, document.getElementById("date").value, 'qth');
                                                                                if (rawData.length === 0) {
                                                                                    console.warn(`No data computed for QTH ${locator}`);
                                                                                    document.getElementById("chartWrapper").style.display = "none";
                                                                                    if (chart) {
                                                                                        chart.destroy();
                                                                                        chart = null;
                                                                                    }
                                                                                    chartLabel.innerHTML = '<span class="metric-locator">No data for QTH</span>';
                                                                                } else {
                                                                                    setTimeout(() => {
                                                                                        updateChart(hourIndex);
                                                                                    }, 0);
                                                                                }
                                                                            } catch (e) {
                                                                                console.error(`Error computing libration for QTH ${locator}: ${e.message}`);
                                                                                document.getElementById("chartWrapper").style.display = "none";
                                                                                if (chart) {
                                                                                    chart.destroy();
                                                                                    chart = null;
                                                                                }
                                                                                chartLabel.innerHTML = '<span class="metric-locator">Error computing QTH data</span>';
                                                                            }
                                                                        } else {
                                                                            document.getElementById("chartWrapper").style.display = "none";
                                                                            if (chart) {
                                                                                chart.destroy();
                                                                                chart = null;
                                                                            }
                                                                            chartLabel.innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
                                                                        }
                                                                    });

                                                                    dxInput.addEventListener("input", () => {
                                                                        const locator = dxInput.value.trim().toUpperCase();
                                                                        const dxChartLabel = document.getElementById('dxchartLabel');
                                                                        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                                            dxChartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                                            try {
                                                                                ({ lat: dxLat, lon: dxLon } = qthToLatLon(locator));
                                                                                computeLibrationForDay(locator, document.getElementById("date").value, 'dx');
                                                                                if (dxRawData.length === 0) {
                                                                                    console.warn(`No data computed for DX ${locator}`);
                                                                                    document.getElementById("dxChartWrapper").style.display = "none";
                                                                                    if (dxChart) {
                                                                                        dxChart.destroy();
                                                                                        dxChart = null;
                                                                                    }
                                                                                    dxChartLabel.innerHTML = '<span class="metric-locator">No data for DX</span>';
                                                                                } else {
                                                                                    updateChart(hourIndex);
                                                                                }
                                                                            } catch (e) {
                                                                                console.error(`Error computing libration for DX ${locator}: ${e.message}`);
                                                                                document.getElementById("dxChartWrapper").style.display = "none";
                                                                                if (dxChart) {
                                                                                    dxChart.destroy();
                                                                                    dxChart = null;
                                                                                }
                                                                                dxChartLabel.innerHTML = '<span class="metric-locator">Error computing DX data</span>';
                                                                            }
                                                                        } else {
                                                                            document.getElementById("dxChartWrapper").style.display = "none";
                                                                            if (dxChart) {
                                                                                dxChart.destroy();
                                                                                dxChart = null;
                                                                            }
                                                                            document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
                                                                        }
                                                                    });

        function qthToLatLon(locator) {
            if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
                throw new Error("Invalid QTH locator format (must be 6 characters)");
            }
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
            const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
            return { lat, lon };
        }

                                                                                                      function degToRad(deg) {
                                                                                                          return deg * Math.PI / 180;
                                                                                                      }

                                                                                                      function radToDeg(rad) {
                                                                                                          return rad * 180 / Math.PI;
                                                                                                      }
                                                                                                      function calcPoloffset(latDeg, azMoonDeg, elMoonDeg) {
                                                                                                          const lat = degToRad(latDeg);
                                                                                                          const az = degToRad(azMoonDeg);
                                                                                                          const el = degToRad(elMoonDeg);

                                                                                                          const xx = Math.sin(lat) * Math.cos(el) - Math.cos(lat) * Math.cos(az) * Math.sin(el);
                                                                                                          const yy = Math.cos(lat) * Math.sin(az);

                                                                                                          let angleRad = Math.atan2(yy, xx);
                                                                                                          return radToDeg(angleRad);
                                                                                                      }

                                                                                                      function calcPoloffsetDiff(pol1, pol2) {
                                                                                                          let diff = (pol2 - pol1 + 720) % 180;
                                                                                                          if (diff > 90) diff -= 180;
                                                                                                          return diff;
                                                                                                      }
                                                    function sanitizeCallsign(callsign) {
                                                        return callsign.replace(/\//g, '_');
                                                    }
                                                    
        document.getElementById("toggleControlsPanel").addEventListener("click", () => {
            const controls = document.getElementById("controls");
            const toggleButton = document.getElementById("toggleControlsPanel");
            const showButton = document.getElementById("showControlsPanel");

            if (!controls.classList.contains("folded")) {
                controls.classList.add("folded");
                toggleButton.style.display = "none";
                showButton.classList.add("visible");
                setTimeout(() => {
                    showButton.style.display = 'none';
                    showButton.offsetHeight;
                    showButton.style.display = 'flex';
                }, 0);
            }
        });

                                                    document.getElementById("showControlsPanel").addEventListener("click", () => {
                                                        const controls = document.getElementById("controls");
                                                        const toggleButton = document.getElementById("toggleControlsPanel");
                                                        const showButton = document.getElementById("showControlsPanel");

                                                        if (controls.classList.contains("folded")) {
                                                            controls.classList.remove("folded");
                                                            toggleButton.style.display = "block";
                                                            showButton.classList.remove("visible");
                                                            setTimeout(() => {
                                                                showButton.style.display = 'none';
                                                                showButton.offsetHeight;
                                                            }, 0);
                                                            if (chart) chart.resize();
                                                            if (dxChart) dxChart.resize();
                                                            if (relativeChart) relativeChart.resize();
                                                            if (moonChart) moonChart.resize();
                                                        }
                                                    });
    </script>
    <!-- Ko-Fi -->
    <script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
    <script src="/kofi.js"></script>
</body>
</html>
