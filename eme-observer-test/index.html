<!DOCTYPE html>
<html lang="en">
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-7YST3WTEH3"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-7YST3WTEH3');
        </script>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title id="pageTitle">EME Observer – Moonbounce Station Map & Sked Planner</title>
        <meta name="description" id="metaDescription" content="EME Observer is a Moonbounce station map and QSO planner with moon tracking, Dpol, libration, moonrise and moonset times, signal loss chart, and tools for ham radio EME." />
        <meta name="keywords" content="EME, Moonbounce, Ham Radio, Amateur Radio, 10GHz, DX Map, Moon Tracking, Doppler Spread, Polarization Offset, Sublunar Point, Moon Azimuth, Moon Declination, Signal Loss, Libration, Moon Footprint, Moon Elevation" />
        <meta name="author" content="SA5IKN">
        <meta name="robots" content="index, follow">
        <meta property="og:title" id="ogTitle" content="EME Observer – 10GHz">
        <meta property="og:type" content="website">
        <meta property="og:description" id="ogDescription" content="Interactive Earth-Moon-Earth (EME) 10GHz station map and sked QSO planner with moon tracking, moon footprint, moon azimuth and elevation, moonset and moonrise times, sublunar point, moon distance and declination, libration, doppler spread, spatial polarisation offset (Dpol), and signal degradation chart for amateur radio (hamradio) and moonbounce enthusiasts.">
        <meta property="og:image" content="https://dxer.site/social/eme-observer.jpg">
        <meta property="og:url" content="https://dxer.site/eme-observer/">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" id="twitterTitle" content="EME Observer – Moonbounce Planner" />
        <meta name="twitter:description" id="twitterDescription" content="Plan your Earth-Moon-Earth QSOs with interactive 10GHz moon tracking, moon charts and tools for ham radio EME." />
        <meta name="twitter:image" content="https://dxer.site/social/eme-observer.jpg" />
        <link rel="canonical" href="https://dxer.site/eme-observer/" />
        <!-- Favicon and App Icons -->
        <link rel="apple-touch-icon" sizes="180x180" href="https://dxer.site/assets/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://dxer.site/assets/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://dxer.site/assets/favicon-16x16.png">
        <link rel="manifest" href="https://dxer.site/assets/site.webmanifest">
        <link rel="shortcut icon" href="https://dxer.site/assets/favicon.ico">
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "WebApplication",
          "name": "EME Observer",
          "url": "https://dxer.site/eme-observer/",
          "author": {
            "@type": "Person",
            "name": "SA5IKN"
          },
          "description": "Interactive Earth-Moon-Earth (EME) station map and sked QSO planner with moon tracking, moon footprint, moon azimuth and elevation, moonset and moonrise times, sublunar point, moon distance and declination, libration, doppler spread, spatial polarisation offset (Dpol), and signal degradation chart for amateur radio (hamradio) and moonbounce enthusiasts.",
          "applicationCategory": "Science",
          "operatingSystem": "All",
          "browserRequirements": "Requires JavaScript",
          "inLanguage": "en",
          "applicationSubCategory": "Amateur Radio Application",
          "offers": {
            "@type": "Offer",
            "price": "0.00",
            "priceCurrency": "USD"
          }
        }
        </script>
        <script src="a.ob.js"></script>

        <style>
            html, body {
              margin: 0;
              padding: 0;
              height: 100%;
              overflow: hidden;
              font-family: Arial, sans-serif;
            }

            #chartWrapper, #dxChartWrapper, #relativeChartWrapper, #moonChartWrapper {
              width: 100%;
              max-width: 600px;
              height: 180px;
              margin-top: 6px;
              background-color: rgba(255, 255, 255, 0.85);
              border-radius: 6px;
              box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
              overflow: hidden;
              position: relative;
              box-sizing: border-box;
              display: none;
            }

            #declinationChart, #dxDeclinationChart, #relativeDataChart, #moonDistanceChart {
              width: 100%;
              height: calc(100% - 20px);
              box-sizing: border-box;
            }

            #moonChartWrapper {
              display: block;
            }

            #moonDistanceChart {
              height: calc(100% - 40px);
              padding-bottom: 20px;
            }

            #chartLabel, #dxchartLabel, #relativeChartLabel, #moonChartLabel {
              text-align: center;
              margin-bottom: 0px;
              font-weight: normal;
              font-size: 11px;
              font-family: 'Arial, sans-serif';
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
              max-width: 100%;
              padding: 2px 0;
            }

            #map {
              height: 100dvh;
              width: 100%;
              z-index: 0;
            }

            #controls {
              position: absolute;
              top: 10px;
              left: 10px;
              z-index: 5;
              background-color: rgba(255, 255, 255, 0.95);
              padding: 12px;
              border-radius: 8px;
              max-width: 95vw;
              max-height: 90vh;
              display: flex;
              flex-direction: column;
              box-sizing: border-box;
              transition: transform 0.3s ease;
            }

            #fixed-controls {
              position: sticky;
              top: 0;
              z-index: 10;
              background-color: inherit;
              padding-bottom: 10px;
              display: flex;
              flex-direction: column;
              gap: 10px;
            }

            #scrollable-controls {
              flex: 1;
              overflow-y: auto;
              max-height: calc(90vh - 180px); /* Adjusted for inline locators */
              padding-right: 5px;
            }

            #scrollable-controls::-webkit-scrollbar {
              width: 6px;
            }

            #scrollable-controls::-webkit-scrollbar-thumb {
              background-color: rgba(0, 123, 255, 0.5);
              border-radius: 3px;
            }

            #scrollable-controls::-webkit-scrollbar-track {
              background: transparent;
            }

            label {
              font-weight: bold;
              font-size: 14px;
            }

            #hour-value {
              margin-left: 10px;
              font-weight: normal;
            }

            #hour {
              width: 100%;
              margin-top: 5px;
              -webkit-appearance: none;
              appearance: none;
              height: 10px;
              background: rgba(0, 0, 0, 0.1);
              border-radius: 5px;
              outline: none;
              transition: background 0.3s ease;
              padding: 0;
            }

            #hour::-webkit-slider-thumb {
              -webkit-appearance: none;
              appearance: none;
              width: 20px;
              height: 20px;
              background: #007bff;
              border-radius: 50%;
              cursor: pointer;
            }

            #hour::-moz-range-thumb {
              width: 20px;
              height: 20px;
              background: #007bff;
              border-radius: 50%;
              cursor: pointer;
            }

            #hour:active {
              background: rgba(0, 123, 255, 0.5);
            }

            #hour-container {
              position: relative;
              width: 100%;
              height: 40px;
              margin-top: 10px;
              padding: 5px 0;
            }

            #date-container {
              display: flex;
              align-items: center;
              justify-content: center;
              flex-wrap: wrap;
              gap: 5px;
              margin-top: 10px;
            }

            input[type="date"] {
              width: auto;
              max-width: 200px;
            }

            .app-name-wrapper {
              display: flex;
              flex-direction: column;
              align-items: flex-end;
              position: relative;
            }

            .creator-label {
              font-size: 10px;
              color: #555;
              font-style: italic;
              margin-bottom: -4px;
            }

            .app-name {
              font-size: 1.0rem;
              font-weight: bold;
              color: #2c3e50;
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            }

            .ghz-label {
              font-size: 10px;
              font-weight: bold;
              color: #2c3e50;
              margin-top: -4px;
            }

            #toggleMoonChart {
              font-size: 12px;
              padding: 4px 8px;
              background-color: #007bff;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              transition: background-color 0.3s ease;
            }

            #toggleMoonChart:hover {
              background-color: #0056b3;
            }

            #toggleMoonChart:focus {
              outline: none;
              box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
            }

            #toggleControlsPanel {
              padding: 2px 3px;
              background-color: rgba(255, 255, 255, 0.3);
              color: #2c3e50;
              border: 1px solid rgba(0, 123, 255, 0.4);
              border-radius: 2px;
              font-size: 10px;
              cursor: pointer;
              transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
              text-decoration: none;
              display: flex;
              align-items: center;
              justify-content: center;
              line-height: 1;
            }

            #toggleControlsPanel:hover {
              background-color: rgba(255, 255, 255, 0.5);
              color: #0056b3;
              border-color: rgba(0, 123, 255, 0.6);
            }

            #toggleControlsPanel:focus {
              outline: none;
              box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
            }

            .locator-group {
              display: flex;
              gap: 10px;
              flex-wrap: wrap;
              align-items: center;
            }

            .locator-input {
              display: flex;
              align-items: center;
              gap: 5px;
            }

            .locator-input label {
              font-size: 12px;
              font-weight: normal;
            }

            .locator-input input {
              font-size: 12px;
              padding: 2px;
              border: 1px solid #ccc;
              border-radius: 3px;
            }

            .metric-label {
              font-weight: bold;
            }

            .metric-distance {
              color: #24a148;
            }

            .metric-declination {
              color: #ff832b;
            }

            .metric-pathloss {
              color: #24a148;
            }

            .metric-separator {
              color: #666;
              margin: 0 4px;
            }

            .metric-elevation {
              color: rgba(0, 0, 255, 0.6);
            }

            .metric-azimuth {
              color: #444;
            }

            .metric-libration {
              color: #ff0000;
            }

            .metric-doppler {
              color: green;
            }

            .metric-locator {
              color: #000;
              font-weight: bold;
            }

            .button-group-infowindow {
                display: flex;
                gap: 3px;
                margin-top: 6px;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            
            .sked-button {
              font-size: 12px;
              padding: 2px 6px;
              margin-left: 5px;
              background-color: #28a745;
              color: white;
              border: none;
              border-radius: 3px;
              cursor: pointer;
              transition: background-color 0.3s ease;
            }

            .sked-button:hover {
              background-color: #218838;
            }

            .sked-button:focus {
              outline: none;
              box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
            }
            
            .email-button {
                background-color: #27A9F5;
                color: white;
                border: none;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
                border-radius: 3px;
                margin-left: 5px;
                text-decoration: none;
                transition: background-color 0.3s ease;
            }

            .email-button:hover {
                background-color: #279CF5;
            }

            .email-button:focus {
              outline: none;
              box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
            }
            
            .qrz-button {
                background-color: #fd7e14; /* Orange to distinguish from Sked and Email */
                color: white;
                border: none;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
                border-radius: 3px;
                margin-left: 5px; /* Space if placed next to other buttons */
                text-decoration: none; /* For <a> tag to look like a button */
                transition: background-color 0.3s ease;
            }

            .qrz-button:hover {
                background-color: #e86c12; /* Darker orange on hover */
            }
            
            .qrz-button:focus {
              outline: none;
              box-shadow: 0 0 3px rgba(40, 167, 69, 0.5);
            }
            
            .button-group {
              display: flex;
              gap: 3px;
              margin-top: 6px;
              flex-wrap: wrap;
              justify-content: center;
            }

            .nav-button {
              padding: 2px 3px;
              width: 60px; /* Fixed width to accommodate "Active" and "Statistics" */
              text-align: center; /* Center text to prevent layout shift */
              background-color: rgba(255, 255, 255, 0.3);
              color: #2c3e50;
              border: 1px solid rgba(0, 123, 255, 0.4);
              border-radius: 2px;
              font-size: 10px;
              cursor: pointer;
              transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
              text-decoration: none;
              display: flex;
              align-items: center;
              justify-content: center;
              line-height: 1;
            }

            .nav-button:hover {
              background-color: rgba(255, 255, 255, 0.5);
              color: #0056b3;
              border-color: rgba(0, 123, 255, 0.6);
            }

            .nav-button:focus {
              outline: none;
              box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
            }

            .nav-button.active {
              background-color: rgba(0, 123, 255, 0.2);
              font-weight: bold;
              border-color: rgba(0, 123, 255, 0.8);
            }

            .nav-button.icon-button {
              padding: 2px;
              font-size: 12px;
              width: 18px; /* Smaller width for icon buttons */
              height: 18px;
              display: flex;
              align-items: center;
              justify-content: center;
            }

            #controls.folded {
              transform: translateX(calc(-100% + 30px));
              box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            }

            #showControlsPanel {
              position: fixed;
              top: 30%;
              left: 35px;
              transform: translateY(-50%) scale(1);
              width: 24px;
              height: 24px;
              padding: 2px;
              background-color: rgba(255, 255, 255, 0.95);
              color: #2c3e50;
              border: 1px solid rgba(0, 123, 255, 0.4);
              border-radius: 4px;
              font-size: 12px;
              font-weight: bold;
              cursor: pointer;
              transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
              display: none;
              align-items: center;
              justify-content: center;
              z-index: 1000;
              box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            }

            #showControlsPanel.visible {
              display: flex;
            }

            #showControlsPanel:hover {
              background-color: rgba(255, 255, 255, 1);
              color: #0056b3;
              border-color: rgba(0, 123, 255, 0.6);
              transform: translateY(-50%) scale(1.1);
            }

            #showControlsPanel:focus {
              outline: none;
              box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
            }

            #showControlsPanel:not(.visible) {
              display: none !important;
            }

            @media (max-width: 600px) {
              #showControlsPanel {
                left: 32px;
                width: 20px;
                height: 20px;
                font-size: 10px;
                padding: 1px;
              }
              #controls {
                padding: 8px;
              }
              #fixed-controls {
                padding-bottom: 8px;
              }
              #scrollable-controls {
                max-height: calc(90vh - 160px);
              }
              .locator-input label {
                font-size: 10px;
              }
              .locator-input input {
                font-size: 10px;
                width: 80px;
              }
              .nav-button, #toggleControlsPanel {
                font-size: 8px;
                padding: 2px 3px;
                width: 50px; /* Slightly smaller width for mobile */
              }
              .nav-button.icon-button {
                font-size: 10px;
                width: 16px;
                height: 16px;
              }
            }

            .gm-style > div {
              z-index: 50 !important;
            }

            .metric-rel-libration {
              color: red;
              font-weight: bold;
            }

            .metric-rel-doppler {
              color: green;
              font-weight: bold;
            }

            .metric-poloffset {
              color: blue;
              font-weight: bold;
            }
            .locator-input input[type="checkbox"] {
              margin-right: 5px;
              cursor: pointer;
            }

            .locator-input label[for="activeStations"] {
              font-size: 12px;
              font-weight: normal;
              cursor: pointer;
            }
            .band-select {
              font-size: 10px;
              font-weight: bold;
              color: #2c3e50;
              margin-top: -1px;
              padding: 2px;
              border: 1px solid #ccc;
              border-radius: 3px;
              background-color: #fff;
              cursor: pointer;
            }

            .band-select:focus {
              outline: none;
              border-color: #007bff;
              box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
            }

            /* Disabled styles for time slider and date controls */
            #hour:disabled {
              background: #ccc;
              cursor: not-allowed;
            }

            #hour:disabled::-webkit-slider-thumb {
              background: #999;
              cursor: not-allowed;
            }

            #hour:disabled::-moz-range-thumb {
              background: #999;
              cursor: not-allowed;
            }

            #date:disabled, #prevDay:disabled, #nextDay:disabled {
              background: #ccc;
              color: #999;
              cursor: not-allowed;
              opacity: 0.6;
            }
            .button-band-group {
              display: flex;
              align-items: center;
              gap: 5px;
              margin-top: -2px;
            }

            .auto-track-button {
              font-size: 10px; /* Smaller font size */
              padding: 1px 4px; /* Reduced padding */
              width: 40px; /* Fixed width to accommodate longest text */
              text-align: center; /* Center text to maintain alignment */
              background-color: #17a2b8;
              color: white;
              border: none;
              border-radius: 3px;
              cursor: pointer;
              transition: background-color 0.3s ease;
            }

            .auto-track-button:hover {
              background-color: #138496;
            }

            .auto-track-button:focus {
              outline: none;
              box-shadow: 0 0 3px rgba(23, 162, 184, 0.5);
            }

            .auto-track-button.active {
              background-color: #138496;
              font-weight: bold;
            }
            .metric-sun-sep {
                color: #ff832b; /* Yellow for Sun separation */
                font-weight: bold;
            }
            .metric-sgra-sep {
                color: #800080; /* Purple for Sgr A separation */
                font-weight: bold;
            }
        </style>
</head>
<body>
    <div id="map"></div>
    <div id="controls">
        <div id="fixed-controls">
          <div id="date-container">
              <div class="app-name-wrapper">
                <div class="creator-label">by SA5IKN</div>
                <div class="app-name">EME Observer</div>
                <div class="button-band-group">
                  <button id="realTimeButton" class="auto-track-button">Track</button>
                  <select id="bandSelect" class="band-select">
                    <option value="432MHz">432MHz</option>
                    <option value="1296MHz">1296MHz</option>
                    <option value="2320MHz">2320MHz</option>
                    <option value="3400MHz">3400MHz</option>
                    <option value="5760MHz">5760MHz</option>
                    <option value="10GHz" selected>10GHz</option>
                    <option value="24GHz">24GHz</option>
                    <option value="47GHz">47GHz</option>
                    <option value="76GHz">76GHz</option>
                  </select>
                </div>
              </div>
            <button id="prevDay">←</button>
            <input type="date" id="date" />
            <button id="nextDay">→</button>
            <span id="hour-value">Time (UTC): 00:00</span>
          </div>
          <div class="button-group">
            <button id="activeStationsButton" class="nav-button">All</button>
            <a href="statistics.html" class="nav-button">Statistics</a>
            <a href="table.html" class="nav-button">Table</a>
            <a href="datasubmission.html" class="nav-button">Add Station</a>
            <a href="/" class="nav-button icon-button">🏠</a>
            <a href="user-guide.html" class="nav-button icon-button">?</a>
            <button id="toggleControlsPanel" class="nav-button">←</button>
          </div>
          <input type="range" id="hour" min="0" max="47" value="0" step="1" />
          <div class="locator-group">
            <div class="locator-input">
              <label for="qth">My Locator:</label>
              <input type="text" id="qth" maxlength="6" size="8" placeholder="eg JO89tt" />
            </div>
            <div class="locator-input">
              <label for="dx">DX Locator:</label>
              <input type="text" id="dx" maxlength="6" size="8" placeholder="eg IO91vm" />
            </div>
          </div>
        </div>
      <div id="scrollable-controls">
        <div id="chartWrapper" style="display: none;">
          <div id="chartLabel"></div>
          <canvas id="declinationChart"></canvas>
        </div>
        <div id="dxChartWrapper" style="display: none;">
          <div id="dxchartLabel"></div>
          <canvas id="dxDeclinationChart"></canvas>
        </div>
        <div id="relativeChartWrapper" style="display: none;">
          <div id="relativeChartLabel"></div>
          <canvas id="relativeDataChart"></canvas>
        </div>
        <div id="moonChartWrapper" style="display: block;">
          <div id="moonChartLabel"></div>
          <canvas id="moonDistanceChart"></canvas>
        </div>
      </div>
    </div>
    <button id="showControlsPanel" style="display: none;">→</button>
    
    <script src="chart.js"></script>
    <script src="chartjs-plugin-annotation@1.4.0"></script>
    <script src="l.ob.js"></script>
    <script>
        let chart;
        let dxChart;
        let relativeChart;
        let moonChart;
        let rawData = [];
        let dxRawData = [];
        let moonDataForMonth = [];
        let hourIndex = 0;
        let lat = 0;
        let lon = 0;
        let dxLat = 0;
        let dxLon = 0;
        let moonMarker;
        let footprintCircle;
        let currentInfoWindow = null;
        let map;
        let realTimeInterval = null; // Store the interval ID for real-time updates
        let isRealTimeMode = false; // Track real-time mode state
        let moonDayData = { date: null, data: [], labels: [] };

        // NEW: Caches for day data to avoid recompute
        let qthDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
        let dxDayData = { date: null, libration: [], elevations: [], azimuths: [], dopplers: [], rates: [] };
        let relDayData = { date: null, libration: [], dopplers: [], polOffsets: [] };

        const MOON_RADIUS = 1.7374e6;
        const SPEED_OF_LIGHT = 299792458;
        
        // Define band frequencies and display names
        const bandConfig = {
        '432MHz': { frequency: 0.432e9, display: '432 MHz', jsonFile: 'stn_432MHz.json' },
          '1296MHz': { frequency: 1.296e9, display: '1296 MHz', jsonFile: 'stn_1296MHz.json' },
          '2320MHz': { frequency: 2.320e9, display: '2320 MHz', jsonFile: 'stn_2320MHz.json' },
          '3400MHz': { frequency: 3.400e9, display: '3400 MHz', jsonFile: 'stn_3400MHz.json' },
          '5760MHz': { frequency: 5.760e9, display: '5760 MHz', jsonFile: 'stn_5760MHz.json' },
          '10GHz': { frequency: 10.368e9, display: '10 GHz', jsonFile: 'stn_10GHz.json' },
          '24GHz': { frequency: 24.000e9, display: '24 GHz', jsonFile: 'stn_24GHz.json' },
          '47GHz': { frequency: 47.000e9, display: '47 GHz', jsonFile: 'stn_47GHz.json' },
          '76GHz': { frequency: 76.000e9, display: '76 GHz', jsonFile: 'stn_76GHz.json' }
        };

        // Default to 10GHz
        let FREQUENCY_HZ = bandConfig['10GHz'].frequency;

        // Helper function to update hour-value display
        function updateHourDisplay() {
            const hour = Math.floor(hourIndex / 2);
            const minutes = (hourIndex % 2) * 30;
            document.getElementById('hour-value').textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function updateBand(band) {
            // Stop real-time updates and disable real-time mode
            stopRealTimeUpdates();
            isRealTimeMode = false;
            console.log('updateBand: Real-time mode disabled, realTimeInterval cleared'); // Debug log

            // Update UI to reflect real-time mode is off
            const autoTrackButton = document.getElementById('realTimeButton');
            autoTrackButton.classList.remove('active');
            autoTrackButton.textContent = 'Track';
            document.getElementById('hour').disabled = false;
            document.getElementById('date').disabled = false;
            document.getElementById('prevDay').disabled = false;
            document.getElementById('nextDay').disabled = false;

            // Update hour-value to match slider position
            updateHourDisplay();

            // Update frequency
            FREQUENCY_HZ = bandConfig[band].frequency;

            // Update page title and meta tags
            const bandDisplay = bandConfig[band].display;
            document.getElementById('pageTitle').textContent = `EME Observer – ${bandDisplay} Moonbounce Station Map, Moon Data & Sked Planner`;
            document.getElementById('metaDescription').content = `EME Observer is a ${bandDisplay} Moonbounce station map and QSO planner with moon tracking, Dpol, libration, moonrise and moonset times, signal loss chart, and tools for ham radio EME.`;
            document.getElementById('ogTitle').content = `EME Observer – ${bandDisplay}`;
            document.getElementById('ogDescription').content = `Interactive Earth-Moon-Earth (EME) ${bandDisplay} station map and sked QSO planner with moon tracking, moon footprint, moon azimuth and elevation, moonset and moonrise times, sublunar point, moon distance and declination, libration, doppler spread, spatial polarisation offset (Dpol), and signal degradation chart for amateur radio (hamradio) and moonbounce enthusiasts.`;
            document.getElementById('twitterTitle').content = `EME Observer – ${bandDisplay} Moonbounce Planner`;
            document.getElementById('twitterDescription').content = `Plan your Earth-Moon-Earth QSOs with interactive ${bandDisplay} moon tracking, moon charts and tools for ham radio EME.`;

            // Invalidate caches
            qthDayData.date = null;
            dxDayData.date = null;
            relDayData.date = null;

            // Update JSON file and markers
            const jsonFile = bandConfig[band].jsonFile;
            const showActiveOnly = isActiveStationsOnly;
            markers.forEach(marker => marker.setMap(null));
            markers = [];
            fetch(jsonFile)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    updateMarkers(data, showActiveOnly);
                    // Recompute data for current locators
                    const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                    const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                    const dateStr = document.getElementById("date").value;
                    if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                        computeLibrationForDay(qthInput, dateStr, 'qth');
                        computeFullDayData(qthDayData, qthInput, dateStr, true);
                    }
                    if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                        computeLibrationForDay(dxInput, dateStr, 'dx');
                        computeFullDayData(dxDayData, dxInput, dateStr, false);
                    }
                    // Update charts with new data, ensuring real-time mode is off
                    if (!isRealTimeMode) {
                        console.log(`updateBand: Updating chart with hourIndex=${hourIndex}, isRealTimeMode=${isRealTimeMode}`); // Debug log
                        updateChart(hourIndex, false);
                    } else {
                        console.warn('updateBand: Skipped chart update due to unexpected real-time mode'); // Debug log
                    }
                })
                .catch(error => {
                    console.error(`Error fetching ${jsonFile}:`, error);
                });
        }

        function computeLibrationForDay(locator, dateStr, type) {
            if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                console.warn(`Invalid locator: ${locator}`);
                return [];
            }

            let lat, lon;
            try {
                ({ lat, lon } = qthToLatLon(locator));
            } catch (e) {
                console.error(`Error converting locator ${locator} to lat/lon: ${e.message}`);
                return [];
            }

            const date = new Date(dateStr);
            if (isNaN(date.getTime())) {
                console.error(`Invalid date string: ${dateStr}`);
                return [];
            }
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();

            const results = [];
            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minute = (i % 2) * 30;
                const dt = new Date(Date.UTC(year, month - 1, day, hour, minute));
                const isoDate = dt.toISOString().replace('.000Z', '');

                try {
                    const [libLat, libLon] = EMEastroLib.topocentricLibration(year, month, day, hour, minute, lat, lon);
                    if (isNaN(libLat) || isNaN(libLon) || libLat === null || libLon === null) {
                        throw new Error(`Invalid libration values: lat=${libLat}, lon=${libLon}`);
                    }
                    results.push({
                        date: isoDate,
                        lat: libLat,
                        lon: libLon
                    });
                } catch (e) {
                    console.warn(`Error computing libration for ${isoDate} at ${locator}: ${e.message}`);
                    results.push({
                        date: isoDate,
                        lat: null,
                        lon: null
                    });
                }
            }

            const librationRates = results.map((curr, i, arr) => {
                if (
                    i <= 0 ||
                    i >= arr.length - 1 ||
                    arr[i-1].lat === null ||
                    arr[i-1].lon === null ||
                    arr[i+1].lat === null ||
                    arr[i+1].lon === null ||
                    curr.lat === null ||
                    curr.lon === null
                ) {
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }

                try {
                    const dlat = (arr[i+1].lat - arr[i-1].lat) / 60;
                    const dlon = (arr[i+1].lon - arr[i-1].lon) / 60;
                    if (isNaN(dlat) || isNaN(dlon) || !isFinite(dlat) || !isFinite(dlon)) {
                        console.warn(`Invalid dlat/dlon for ${curr.date} at ${locator}: dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    const rate = Math.sqrt(dlat * dlat + dlon * dlon);
                    if (isNaN(rate) || !isFinite(rate)) {
                        console.warn(`Invalid rate for ${curr.date} at ${locator}: rate=${rate}, dlat=${dlat}, dlon=${dlon}`);
                        return { date: curr.date, rate: null, dldt: null, dbdt: null };
                    }
                    return { date: curr.date, rate, dldt: dlat, dbdt: dlon };
                } catch (e) {
                    console.warn(`Error computing rate for ${curr.date} at ${locator}: ${e.message}`);
                    return { date: curr.date, rate: null, dldt: null, dbdt: null };
                }
            });

            // Update cache
            const cache = type === 'qth' ? qthDayData : dxDayData;
            cache.date = dateStr;
            cache.libration = librationRates;

            if (type === 'qth') {
                rawData = librationRates.slice();
                document.getElementById("chartWrapper").style.display = rawData.some(r => r.rate != null) ? "block" : "none";
            } else {
                dxRawData = librationRates.slice();
                document.getElementById("dxChartWrapper").style.display = dxRawData.some(r => r.rate != null) ? "block" : "none";
            }
            return librationRates;
        }

        function computeFullDayData(cache, locator, dateStr, isQth) {
            const { lat: obsLat, lon: obsLon } = qthToLatLon(locator);
            const libData = cache.libration;
            const elevations = [];
            const azimuths = [];
            const dopplers = [];
            const rates = [];

            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minutes = (i % 2) * 30;
                const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00Z`);
                const observer = new Astronomy.Observer(obsLat, obsLon, 0);
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                const elevationDeg = hor.altitude;
                const azimuthDeg = hor.azimuth;

                let rate = libData[i]?.rate ?? null;
                let doppler = null;
                if (elevationDeg > 0 && rate != null) {
                    rates.push(rate * 1000);
                    const omegaRadSec = rate * (Math.PI / 180) / 60;
                    doppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                } else {
                    rates.push(null);
                    doppler = null;
                }

                elevations.push(elevationDeg > 0 ? elevationDeg : null);
                azimuths.push(elevationDeg > 0 ? azimuthDeg : null);
                dopplers.push(doppler);
            }

            cache.elevations = elevations;
            cache.azimuths = azimuths;
            cache.dopplers = dopplers;
            cache.rates = rates;
        }

        function interpolate(a, b, frac) {
            if (a === null || b === null) return null;
            return a + (b - a) * frac;
        }

        function getValueAtIndex(data, index) {
            if (index < 0 || index > 47) return null;
            const floorIdx = Math.floor(index);
            const ceilIdx = Math.ceil(index);
            const frac = index - floorIdx;
            if (floorIdx === ceilIdx) return data[floorIdx];
            return interpolate(data[floorIdx], data[ceilIdx], frac);
        }

        function computeRelativeAtIndex(idx, qthData, dxData) {
            const qthL = qthData.libration[idx];
            const dxL = dxData.libration[idx];
            if (!qthL || !dxL || qthL.dldt == null || dxL.dldt == null) {
                return { libration: null, doppler: null, pol: null };
            }

            const qthElev = qthData.elevations[idx];
            const dxElev = dxData.elevations[idx];
            if (qthElev <= 0 || dxElev <= 0) {
                return { libration: null, doppler: null, pol: null };
            }

            const dldt_sum = qthL.dldt + dxL.dldt;
            const dbdt_sum = qthL.dbdt + dxL.dbdt;
            const relLibration = Math.sqrt(dldt_sum * dldt_sum + dbdt_sum * dbdt_sum) / 2;

            const omegaRadSec = relLibration * (Math.PI / 180) / 60;
            const relDoppler = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;

            // Pol offset
            const qthAz = qthData.azimuths[idx];
            const dxAz = dxData.azimuths[idx];
            let pol = null;
            if (qthAz != null && dxAz != null) {
                const polQth = calcPoloffset(lat, qthAz, qthElev);
                const polDx = calcPoloffset(dxLat, dxAz, dxElev);
                pol = calcPoloffsetDiff(polQth, polDx);
            }

            return { libration: relLibration, doppler: relDoppler, pol };
        }
                                                
                                                function angularSeparation(ra1, dec1, ra2, dec2) {
                                                    const d1 = degToRad(dec1);
                                                    const d2 = degToRad(dec2);
                                                    const r1 = degToRad(ra1 * 15); // Convert RA from hours to degrees
                                                    const r2 = degToRad(ra2 * 15);
                                                    const cosSep = Math.sin(d1) * Math.sin(d2) + Math.cos(d1) * Math.cos(d2) * Math.cos(r1 - r2);
                                                    // Handle floating-point errors
                                                    const sep = Math.acos(Math.max(-1, Math.min(1, cosSep)));
                                                    return radToDeg(sep);
                                                }
                                                
                                                function vectorToEquatorial(vector, ofdate) {
                                                    try {
                                                        const moonEq = Astronomy.EquatorFromVector(vector);
                                                        if (!moonEq || isNaN(moonEq.ra) || isNaN(moonEq.dec)) {
                                                            throw new Error('Invalid equatorial coordinates');
                                                        }
                                                        // Use Astronomy.Libration for distance instead of vector.length()
                                                        const astroTime = Astronomy.MakeTime(vector.t);
                                                        const libration = Astronomy.Libration(astroTime);
                                                        if (!libration || isNaN(libration.dist_km)) {
                                                            throw new Error('Invalid libration data');
                                                        }
                                                        return {
                                                            ra: moonEq.ra, // Right ascension in hours
                                                            dec: moonEq.dec, // Declination in degrees
                                                            dist: libration.dist_km // Distance in kilometers
                                                        };
                                                    } catch (e) {
                                                        console.error(`Error in vectorToEquatorial: ${e.message}`);
                                                        return null;
                                                    }
                                                }
                                                
                                                function updateMap(currentTime) {
                                                    const utcTimeString = currentTime.toISOString();

                                                    if (!currentTime || isNaN(currentTime.getTime())) {
                                                        console.warn(`Invalid currentTime in updateMap: ${currentTime}`);
                                                        return;
                                                    }

                                                    try {
                                                        const time = Astronomy.MakeTime(currentTime);
                                                        const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, time, true); // Geocentric vector
                                                        if (!moonVector) {
                                                            throw new Error('GeoVector returned null or undefined');
                                                        }
                                                        const moon = vectorToEquatorial(moonVector, false); // No EQD transformation
                                                        const libration = Astronomy.Libration(time);

                                                        if (!moon || !libration) {
                                                            console.warn(`Failed to compute Moon data for ${utcTimeString}: moon=${JSON.stringify(moon)}, libration=${JSON.stringify(libration)}`);
                                                            return;
                                                        }

                                                        const raHours = moon.ra;
                                                        const decDeg = moon.dec;
                                                        const raDeg = raHours * 15;

                                                        let gastDeg = Astronomy.SiderealTime(time) * 15;
                                                        gastDeg = ((gastDeg % 360) + 360) % 360;

                                                        let lonDeg = raDeg - gastDeg;
                                                        if (lonDeg > 180) lonDeg -= 360;
                                                        if (lonDeg < -180) lonDeg += 360;

                                                        const lat = decDeg;
                                                        const lon = lonDeg;

                                                        const earthRadius = 6371;
                                                        const D_moon = libration.dist_km;
                                                        const theta_rad = Math.acos(earthRadius / (earthRadius + D_moon));
                                                        const footprintRadius = earthRadius * theta_rad * 1000;

                                                        if (isNaN(lat) || isNaN(lon) || isNaN(footprintRadius)) {
                                                            console.warn(`Invalid sublunar point data for ${utcTimeString}: lat=${lat}, lon=${lon}, radius=${footprintRadius}`);
                                                            return;
                                                        }

                                                        if (moonMarker) moonMarker.setMap(null);
                                                        if (footprintCircle) footprintCircle.setMap(null);

                                                        moonMarker = new google.maps.Marker({
                                                            position: { lat, lng: lon },
                                                            map: map,
                                                            icon: {
                                                                url: 'images/moon-icon.png',
                                                                scaledSize: new google.maps.Size(48, 48)
                                                            },
                                                            title: `Moon Sublunar Point (${lat.toFixed(2)}°, ${lon.toFixed(2)}°)`
                                                        });

                                                        footprintCircle = new google.maps.Circle({
                                                            map: map,
                                                            center: { lat, lng: lon },
                                                            radius: footprintRadius,
                                                            fillColor: '#0088FF',
                                                            fillOpacity: 0.3,
                                                            strokeColor: '#0000FF',
                                                            strokeOpacity: 0.6,
                                                            strokeWeight: 2
                                                        });
                                                    } catch (error) {
                                                        console.error(`Error calculating sublunar point for ${utcTimeString}: ${error.message}`);
                                                    }
                                                }

                                                function calculateMoonDataForMonth(dateStr) {
                                                    // Check cache
                                                    if (moonDayData.date === dateStr) {
                                                        return moonDayData;
                                                    }

                                                    const startDate = new Date(dateStr);
                                                    startDate.setUTCDate(1);
                                                    startDate.setUTCHours(0, 0, 0, 0);
                                                    const endDate = new Date(startDate);
                                                    endDate.setUTCDate(endDate.getUTCDate() + 31); // Slightly over a month to ensure coverage

                                                    const data = [];
                                                    const labels = [];

                                                    // Sgr A coordinates (J2000): RA = 17h45m40.0409s = 17.76112247h, Dec = -29°00'28.118" = -29.00781056°
                                                    const sgrA = { ra: 17.76112247, dec: -29.00781056 };

                                                    // Generate daily labels for the chart (DD-MM)
                                                    for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
                                                        const day = String(dt.getUTCDate()).padStart(2, '0');
                                                        const month = String(dt.getUTCMonth() + 1).padStart(2, '0');
                                                        labels.push(`${day}-${month}`);
                                                    }

                                                    // Compute hourly data
                                                    for (let dt = new Date(startDate); dt <= endDate; dt.setUTCHours(dt.getUTCHours() + 1)) {
                                                        try {
                                                            const dateString = dt.toISOString().slice(0, 10);
                                                            const time = dt.toISOString();
                                                            const astroTime = Astronomy.MakeTime(new Date(time));
                                                            
                                                            const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                                                            if (!moonVector) {
                                                                throw new Error('GeoVector returned null or undefined');
                                                            }
                                                            const moon = vectorToEquatorial(moonVector, false);
                                                            if (!moon) {
                                                                throw new Error('vectorToEquatorial returned null');
                                                            }
                                                            const libration = Astronomy.Libration(astroTime);
                                                            if (!libration) {
                                                                throw new Error('Libration returned null or undefined');
                                                            }
                                                            const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                                                            if (!sunVector) {
                                                                throw new Error('Sun GeoVector returned null or undefined');
                                                            }
                                                            const sun = Astronomy.EquatorFromVector(sunVector);
                                                            if (!sun || isNaN(sun.ra) || isNaN(sun.dec)) {
                                                                throw new Error('Invalid Sun equatorial coordinates');
                                                            }

                                                            const distanceKm = libration.dist_km;
                                                            const declination = moon.dec;
                                                            const sunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                                                            const sgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);

                                                            if (distanceKm != null && declination != null && !isNaN(declination) && !isNaN(sunSep) && !isNaN(sgrASep)) {
                                                                data.push({
                                                                    date: dateString,
                                                                    time: time,
                                                                    index: (dt - startDate) / (1000 * 60 * 60), // Hours since start
                                                                    distance: distanceKm,
                                                                    declination: declination,
                                                                    sunSep: sunSep,
                                                                    sgrASep: sgrASep
                                                                });
                                                            } else {
                                                                console.warn(`Missing data for ${time}: distance=${distanceKm}, declination=${declination}, sunSep=${sunSep}, sgrASep=${sgrASep}`);
                                                            }
                                                        } catch (e) {
                                                            console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
                                                        }
                                                    }

                                                    // Update cache
                                                    moonDayData.date = dateStr;
                                                    moonDayData.data = data;
                                                    moonDayData.labels = labels;

                                                    return { data, labels };
                                                }

                                                function updateMoonChart(currentTime) {
                                                    const dateInput = document.getElementById("date").value;
                                                    const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

                                                    // Aggregate hourly data to daily for plotting (average per day)
                                                    const dailyData = [];
                                                    for (let day = 0; day < labels.length; day++) {
                                                        const dayStart = day * 24;
                                                        const dayEnd = Math.min((day + 1) * 24, moonData.length);
                                                        let distanceSum = 0, declinationSum = 0, count = 0;
                                                        for (let i = dayStart; i < dayEnd; i++) {
                                                            if (moonData[i]) {
                                                                distanceSum += moonData[i].distance;
                                                                declinationSum += moonData[i].declination;
                                                                count++;
                                                            }
                                                        }
                                                        dailyData.push({
                                                            distance: count > 0 ? distanceSum / count : null,
                                                            declination: count > 0 ? declinationSum / count : null
                                                        });
                                                    }

                                                    const distances = dailyData.map(d => d.distance);
                                                    const declinations = dailyData.map(d => d.declination);

                                                    // Calculate selected day index with hourly precision
                                                    const startDate = new Date(dateInput);
                                                    startDate.setUTCDate(1);
                                                    startDate.setUTCHours(0, 0, 0, 0);
                                                    const selectedIndex = (currentTime - startDate) / (1000 * 60 * 60); // Hours since start

                                                    let currentDistance = null;
                                                    let currentDeclination = null;
                                                    let pathLoss = null;
                                                    let currentSunSep = null;
                                                    let currentSgrASep = null;
                                                    const minDist = 356352.93;
                                                    const sgrA = { ra: 17.76112247, dec: -29.00781056 };

                                                    try {
                                                        const astroTime = Astronomy.MakeTime(currentTime);
                                                        const moonVector = Astronomy.GeoVector(Astronomy.Body.Moon, astroTime, true);
                                                        if (!moonVector) {
                                                            throw new Error('GeoVector returned null or undefined');
                                                        }
                                                        const moon = vectorToEquatorial(moonVector, false);
                                                        const libration = Astronomy.Libration(astroTime);
                                                        const sunVector = Astronomy.GeoVector(Astronomy.Body.Sun, astroTime, true);
                                                        if (!sunVector) {
                                                            throw new Error('Sun GeoVector returned null or undefined');
                                                        }
                                                        const sun = Astronomy.EquatorFromVector(sunVector);

                                                        if (moon && libration && sun && !isNaN(sun.ra) && !isNaN(sun.dec)) {
                                                            currentDistance = libration.dist_km;
                                                            currentDeclination = moon.dec;
                                                            currentSunSep = angularSeparation(moon.ra, moon.dec, sun.ra, sun.dec);
                                                            currentSgrASep = angularSeparation(moon.ra, moon.dec, sgrA.ra, sgrA.dec);
                                                            if (currentDistance != null) {
                                                                pathLoss = 40 * Math.log10(currentDistance / minDist);
                                                            }
                                                        } else {
                                                            throw new Error("Invalid current Moon or Sun data");
                                                        }
                                                    } catch (e) {
                                                        console.warn(`Error calculating current Moon data for ${currentTime.toISOString()}: ${e.message}`);
                                                    }

                                                    // Determine the selected band and whether to show M-SgrA-related data
                                                    const band = document.getElementById('bandSelect').value;
                                                    const showSgrASep = band === '432MHz';

                                                    // Find intervals where sunSep < 10 degrees with hourly precision
                                                    const annotations = {
                                                        timeMarker: {
                                                            type: 'line',
                                                            mode: 'vertical',
                                                            scaleID: 'x',
                                                            value: selectedIndex / 24, // Map to daily scale
                                                            borderColor: 'black',
                                                            borderWidth: 2,
                                                            label: { enabled: false }
                                                        }
                                                    };

                                                    let sunSepInterval = null;
                                                    let sgrASepInterval = null;

                                                    for (let i = 0; i < moonData.length; i++) {
                                                        const dayData = moonData[i];
                                                        if (dayData.sunSep < 10) {
                                                            if (!sunSepInterval) {
                                                                sunSepInterval = { start: dayData.index, end: dayData.index };
                                                            } else {
                                                                sunSepInterval.end = dayData.index;
                                                            }
                                                        } else if (sunSepInterval) {
                                                            annotations[`sunSep${sunSepInterval.start}`] = {
                                                                type: 'box',
                                                                xScaleID: 'x',
                                                                xMin: sunSepInterval.start / 24, // Map to daily scale
                                                                xMax: (sunSepInterval.end + 1) / 24,
                                                                yMin: -30, // Span full declination range
                                                                yMax: 30,
                                                                backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                                                                borderWidth: 0, // No border
                                                                label: { enabled: false } // No label
                                                            };
                                                            sunSepInterval = null;
                                                        }

                                                        // Only process sgrASep annotations if 144MHz or 432MHz is selected
                                                        if (showSgrASep && dayData.sgrASep < 10) {
                                                            if (!sgrASepInterval) {
                                                                sgrASepInterval = { start: dayData.index, end: dayData.index };
                                                            } else {
                                                                sgrASepInterval.end = dayData.index;
                                                            }
                                                        } else if (sgrASepInterval) {
                                                            annotations[`sgrASep${sgrASepInterval.start}`] = {
                                                                type: 'box',
                                                                xScaleID: 'x',
                                                                xMin: sgrASepInterval.start / 24, // Map to daily scale
                                                                xMax: (sgrASepInterval.end + 1) / 24,
                                                                yMin: -30, // Span full declination range
                                                                yMax: 30,
                                                                backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                                                                borderWidth: 0, // No border
                                                                label: { enabled: false } // No label
                                                            };
                                                            sgrASepInterval = null;
                                                        }
                                                    }

                                                    // Handle intervals that extend to the last data point
                                                    if (sunSepInterval) {
                                                        annotations[`sunSep${sunSepInterval.start}`] = {
                                                            type: 'box',
                                                            xScaleID: 'x',
                                                            xMin: sunSepInterval.start / 24,
                                                            xMax: (sunSepInterval.end + 1) / 24,
                                                            yMin: -30,
                                                            yMax: 30,
                                                            backgroundColor: 'rgba(255, 131, 43, 0.5)', // 50% transparent
                                                            borderWidth: 0, // No border
                                                            label: { enabled: false } // No label
                                                        };
                                                    }

                                                    if (showSgrASep && sgrASepInterval) {
                                                        annotations[`sgrASep${sgrASepInterval.start}`] = {
                                                            type: 'box',
                                                            xScaleID: 'x',
                                                            xMin: sgrASepInterval.start / 24,
                                                            xMax: (sgrASepInterval.end + 1) / 24,
                                                            yMin: -30,
                                                            yMax: 30,
                                                            backgroundColor: 'rgba(128, 0, 128, 0.5)', // Purple, half-transparent
                                                            borderWidth: 0, // No border
                                                            label: { enabled: false } // No label
                                                        };
                                                    }

                                                    // Construct the moonChartLabel content
                                                    let labelContent =
                                                        `<span class="metric-label metric-distance">Dist:</span> ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}` +
                                                        `<span class="metric-separator">|</span>` +
                                                        `<span class="metric-label metric-declination">Decl:</span> ${currentDeclination != null ? currentDeclination.toFixed(1) + '°' : 'N/A'}` +
                                                        `<span class="metric-separator">|</span>` +
                                                        `<span class="metric-label metric-pathloss">Extra Loss:</span> ${pathLoss != null ? pathLoss.toFixed(2) + ' dB' : 'N/A'}` +
                                                        `<span class="metric-separator">|</span>` +
                                                        `<span class="metric-label metric-sun-sep">M-Sun:</span> ${currentSunSep != null ? currentSunSep.toFixed(1) + '°' : 'N/A'}`;

                                                    // Conditionally add M-SgrA separation for 144MHz or 432MHz
                                                    if (showSgrASep) {
                                                        labelContent +=
                                                            `<span class="metric-separator">|</span>` +
                                                            `<span class="metric-label metric-sgra-sep">M-SgrA:</span> ${currentSgrASep != null ? currentSgrASep.toFixed(1) + '°' : 'N/A'}`;
                                                    }

                                                    document.getElementById('moonChartLabel').innerHTML = labelContent;

                                                    if (!moonChart) {
                                                        moonChart = new Chart(document.getElementById("moonDistanceChart"), {
                                                            type: 'line',
                                                            data: {
                                                                labels,
                                                                datasets: [
                                                                    {
                                                                        label: "Moon Distance (km)",
                                                                        data: distances,
                                                                        borderColor: "#24a148",
                                                                        pointRadius: 0,
                                                                        borderWidth: 1.5,
                                                                        tension: 0.2,
                                                                        yAxisID: "y1"
                                                                    },
                                                                    {
                                                                        label: "Moon Declination (°)",
                                                                        data: declinations,
                                                                        borderColor: "#ff832b",
                                                                        pointRadius: 0,
                                                                        borderWidth: 1.5,
                                                                        tension: 0.2,
                                                                        yAxisID: "y2"
                                                                    }
                                                                ]
                                                            },
                                                            options: {
                                                                responsive: true,
                                                                maintainAspectRatio: false,
                                                                scales: {
                                                                    x: {
                                                                        title: {
                                                                            display: true,
                                                                            text: "Date (DD-MM)",
                                                                            font: { size: 10, family: 'Arial, sans-serif' }
                                                                        },
                                                                        ticks: { font: { size: 10 } }
                                                                    },
                                                                    y1: {
                                                                        type: "linear",
                                                                        display: true,
                                                                        position: "left",
                                                                        title: {
                                                                            display: true,
                                                                            text: "Distance (\u00D710³ km)",
                                                                            color: "#24a148",
                                                                            font: { size: 12, family: 'Arial, sans-serif' }
                                                                        },
                                                                        min: 356400,
                                                                        max: 406700,
                                                                        ticks: {
                                                                            stepSize: 10000,
                                                                            color: "#24a148",
                                                                            font: { size: 12 },
                                                                            callback: function(value) {
                                                                                return (value / 1000).toFixed(0);
                                                                            }
                                                                        },
                                                                        grid: { drawTicks: true, drawBorder: true }
                                                                    },
                                                                    y2: {
                                                                        type: "linear",
                                                                        display: true,
                                                                        position: "right",
                                                                        title: {
                                                                            display: true,
                                                                            text: "Declination (°)",
                                                                            color: "#ff832b",
                                                                            font: { size: 12, family: 'Arial, sans-serif' }
                                                                        },
                                                                        min: -30,
                                                                        max: 30,
                                                                        ticks: {
                                                                            stepSize: 10,
                                                                            callback: val => val + "°",
                                                                            color: "#ff832b",
                                                                            font: { size: 12 }
                                                                        },
                                                                        grid: { drawOnChartArea: false }
                                                                    },
                                                                    y3: {
                                                                        type: "linear",
                                                                        display: true,
                                                                        position: "right",
                                                                        title: {
                                                                            display: true,
                                                                            text: "Extra Path Loss (dB)",
                                                                            color: "#24a148",
                                                                            font: { size: 12, family: 'Arial, sans-serif' }
                                                                        },
                                                                        min: 0,
                                                                        max: 2.5,
                                                                        ticks: {
                                                                            stepSize: 0.5,
                                                                            callback: val => val.toFixed(1),
                                                                            color: "#24a148",
                                                                            font: { size: 12 }
                                                                        },
                                                                        grid: { drawOnChartArea: false },
                                                                        offset: true
                                                                    }
                                                                },
                                                                plugins: {
                                                                    legend: { display: false },
                                                                    annotation: { annotations }
                                                                }
                                                            }
                                                        });
                                                    } else {
                                                        moonChart.data.labels = labels;
                                                        moonChart.data.datasets[0].data = distances;
                                                        moonChart.data.datasets[1].data = declinations;
                                                        moonChart.options.plugins.annotation.annotations = annotations;
                                                        moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedIndex / 24;
                                                        moonChart.options.scales.y1.min = 356400;
                                                        moonChart.options.scales.y1.max = 406700;
                                                        moonChart.options.scales.y2.min = -30;
                                                        moonChart.options.scales.y2.max = 30;
                                                        moonChart.options.scales.y3.min = 0;
                                                        moonChart.options.scales.y3.max = 2.5;
                                                        moonChart.update('none');
                                                    }
                                                }

        function updateChart(index, isRealtime = false) {
          const qthInput = document.getElementById("qth").value.trim().toUpperCase();
          const dxInput = document.getElementById("dx").value.trim().toUpperCase();
          const dateInput = document.getElementById("date").value;
          let dateStr;
          try {
            dateStr = new Date(dateInput).toISOString().slice(0, 10);
          } catch (e) {
            console.error('Invalid date input, using current date');
            dateStr = new Date().toISOString().slice(0, 10);
          }
          const band = document.getElementById('bandSelect').value;
          const maxDoppler = (FREQUENCY_HZ / bandConfig['10GHz'].frequency) * 300;

          let qthValid = false;
          if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
            if (qthDayData.date !== dateStr) {
              rawData = computeLibrationForDay(qthInput, dateStr, 'qth');
              computeFullDayData(qthDayData, qthInput, dateStr, true);
            }
            qthValid = qthDayData.libration.length === 48;
            try {
              ({ lat, lon } = qthToLatLon(qthInput));
            } catch (e) {
              console.error(`Error converting QTH locator ${qthInput} to lat/lon: ${e.message}`);
              lat = 0;
              lon = 0;
            }
          }

          let dxValid = false;
          if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
            if (dxDayData.date !== dateStr) {
              dxRawData = computeLibrationForDay(dxInput, dateStr, 'dx');
              computeFullDayData(dxDayData, dxInput, dateStr, false);
            }
            dxValid = dxDayData.libration.length === 48;
            try {
              ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
            } catch (e) {
              console.error(`Error converting DX locator ${dxInput} to lat/lon: ${e.message}`);
              dxLat = 0;
              dxLon = 0;
            }
          }

          // Get current values (interpolated if real-time)
          let currentElevQth = null, currentAzQth = null, currentRateQth = null, currentDopplerQth = null;
          if (qthValid) {
            currentElevQth = getValueAtIndex(qthDayData.elevations, index);
            currentAzQth = getValueAtIndex(qthDayData.azimuths, index);
            currentRateQth = getValueAtIndex(qthDayData.rates, index);
            currentDopplerQth = getValueAtIndex(qthDayData.dopplers, index);
          }

          let currentElevDx = null, currentAzDx = null, currentRateDx = null, currentDopplerDx = null;
          if (dxValid) {
            currentElevDx = getValueAtIndex(dxDayData.elevations, index);
            currentAzDx = getValueAtIndex(dxDayData.azimuths, index);
            currentRateDx = getValueAtIndex(dxDayData.rates, index);
            currentDopplerDx = getValueAtIndex(dxDayData.dopplers, index);
          }

          // Relative current
          let currentRelRate = null, currentRelDoppler = null, currentPolOffset = null;
          if (qthValid && dxValid) {
            const floorIdx = Math.floor(index);
            const ceilIdx = Math.ceil(index);
            const frac = index - floorIdx;
            const relFloor = computeRelativeAtIndex(floorIdx, qthDayData, dxDayData);
            const relCeil = computeRelativeAtIndex(ceilIdx, qthDayData, dxDayData);
            currentRelRate = interpolate(relFloor.libration * 1000, relCeil.libration * 1000, frac);
            currentRelDoppler = interpolate(relFloor.doppler, relCeil.doppler, frac);
            currentPolOffset = interpolate(relFloor.pol, relCeil.pol, frac);
          }

          // Chart data from caches
          const qthRates = qthDayData.rates || Array(48).fill(null);
          const qthElevs = qthDayData.elevations || Array(48).fill(null);
          const qthDopps = qthDayData.dopplers || Array(48).fill(null);

          const dxRates = dxDayData.rates || Array(48).fill(null);
          const dxElevs = dxDayData.elevations || Array(48).fill(null);
          const dxDopps = dxDayData.dopplers || Array(48).fill(null);

          let relLibrations = Array(48).fill(null);
          let relDopplers = Array(48).fill(null);
          let polOffsets = Array(48).fill(null);
          if (qthValid && dxValid && relDayData.date !== dateStr) {
            for (let i = 0; i < 48; i++) {
              const rel = computeRelativeAtIndex(i, qthDayData, dxDayData);
              relLibrations[i] = rel.libration ? rel.libration * 1000 : null;
              relDopplers[i] = rel.doppler;
              polOffsets[i] = rel.pol;
            }
            relDayData.date = dateStr;
            relDayData.libration = relLibrations;
            relDayData.dopplers = relDopplers;
            relDayData.polOffsets = polOffsets;
          } else if (qthValid && dxValid) {
            relLibrations = relDayData.libration;
            relDopplers = relDayData.dopplers;
            polOffsets = relDayData.polOffsets;
          }

          const labels = Array(48).fill('').map((_, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`);

          const qthAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (qthValid) {
            try {
              const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
              Object.assign(qthAnnotation, moonAnnotations);
            } catch (e) {
              console.warn(`Error getting moon annotations for QTH: ${e.message}`);
            }
          }

          if (qthValid) {
            document.getElementById("chartWrapper").style.display = "block";

            if (!chart) {
              chart = new Chart(document.getElementById("declinationChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Libration Rate (×10⁻³ °/min)",
                      data: qthRates,
                      borderColor: "#ff0000",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Moon Elevation (°)",
                      data: qthElevs,
                      borderColor: "rgba(0, 0, 255, 0.6)",
                      backgroundColor: "rgba(0, 0, 255, 0.15)",
                      fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                      pointRadius: 0,
                      borderWidth: 1,
                      tension: 0.3,
                      yAxisID: "y2"
                    },
                    {
                      label: "Doppler Spread, Hz",
                      data: qthDopps,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      position: "left",
                      display: true,
                      min: 0,
                      max: 90,
                      title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: qthAnnotation }
                  }
                }
              });
            } else {
              chart.data.labels = labels;
              chart.data.datasets[0].data = qthRates;
              chart.data.datasets[1].data = qthElevs;
              chart.data.datasets[2].data = qthDopps;
              chart.options.plugins.annotation.annotations = qthAnnotation;
              chart.options.plugins.annotation.annotations.timeMarker.value = index;
              chart.options.scales.y3.max = maxDoppler;
              chart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
              chart.update('none');
            }

            const rateStr = currentRateQth != null ? (currentRateQth / 1000).toFixed(4) : null;
            document.getElementById('chartLabel').innerHTML =
              `<span class="metric-locator">${qthInput}</span>` +
              `<span class="metric-separator"></span>` +
              `<span class="metric-label metric-elevation">El:</span> ${currentElevQth != null ? currentElevQth.toFixed(1) + '°' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-azimuth">Az:</span> ${currentAzQth != null ? currentAzQth.toFixed(1) + '°' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '°/min' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerQth != null ? currentDopplerQth.toFixed(0) + ' Hz' : 'N/A'}`;
          } else {
            document.getElementById("chartWrapper").style.display = "none";
            if (chart) {
              chart.destroy();
              chart = null;
            }
            document.getElementById('chartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
          }

          const dxAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (dxValid) {
            try {
              const moonAnnotations = getMoonAnnotations(dateStr, dxLat, dxLon);
              Object.assign(dxAnnotation, moonAnnotations);
            } catch (e) {
              console.warn(`Error getting moon annotations for DX: ${e.message}`);
            }
          }

          if (dxValid) {
            document.getElementById("dxChartWrapper").style.display = "block";

            if (!dxChart) {
              dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Libration Rate (×10⁻³ °/min)",
                      data: dxRates,
                      borderColor: "#ff0000",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Moon Elevation (°)",
                      data: dxElevs,
                      borderColor: "rgba(0, 0, 255, 0.6)",
                      backgroundColor: "rgba(0, 0, 255, 0.15)",
                      fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                      pointRadius: 0,
                      borderWidth: 1,
                      tension: 0.3,
                      yAxisID: "y2"
                    },
                    {
                      label: "Doppler Spread, Hz",
                      data: dxDopps,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Libration Rate (×10⁻³ °/min)", color: "#ff0000", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "#ff0000", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      position: "left",
                      display: true,
                      min: 0,
                      max: 90,
                      title: { display: true, text: "Moon Elevation (°)", color: "rgba(0, 0, 255, 0.6)", font: { size: 12, family: 'Arial, sans-serif' } },
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)", font: { size: 12 } }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Doppler Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: dxAnnotation }
                  }
                }
              });
            } else {
              dxChart.data.labels = labels;
              dxChart.data.datasets[0].data = dxRates;
              dxChart.data.datasets[1].data = dxElevs;
              dxChart.data.datasets[2].data = dxDopps;
              dxChart.options.plugins.annotation.annotations = dxAnnotation;
              dxChart.options.plugins.annotation.annotations.timeMarker.value = index;
              dxChart.options.scales.y3.max = maxDoppler;
              dxChart.options.scales.y3.ticks.stepSize = Math.ceil(maxDoppler / 6);
              dxChart.update('none');
            }

            const rateStr = currentRateDx != null ? (currentRateDx / 1000).toFixed(4) : null;
            document.getElementById('dxchartLabel').innerHTML =
              `<span class="metric-locator">${dxInput}</span>` +
              `<span class="metric-separator"></span>` +
              `<span class="metric-label metric-elevation">El:</span> ${currentElevDx != null ? currentElevDx.toFixed(1) + '°' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-azimuth">Az:</span> ${currentAzDx != null ? currentAzDx.toFixed(1) + '°' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-libration">Libr:</span> ${rateStr != null ? rateStr + '°/min' : 'N/A'}` +
              `<span class="metric-separator">|</span>` +
              `<span class="metric-label metric-doppler">Spread:</span> ${currentDopplerDx != null ? currentDopplerDx.toFixed(0) + ' Hz' : 'N/A'}`;
          } else {
            document.getElementById("dxChartWrapper").style.display = "none";
            if (dxChart) {
              dxChart.destroy();
              dxChart = null;
            }
            document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
          }

          const relativeAnnotation = {
            timeMarker: {
              type: 'line',
              mode: 'vertical',
              scaleID: 'x',
              value: index,
              borderColor: 'black',
              borderWidth: 2,
              label: { enabled: false }
            }
          };

          if (qthValid && dxValid) {
            try {
              const skedAnnotations = getSkedAnnotations(dateStr, lat, lon, dxLat, dxLon);
              Object.assign(relativeAnnotation, skedAnnotations);
            } catch (e) {
              console.warn(`Error getting sked annotations: ${e.message}`);
            }
          }

          if (qthValid && dxValid && relLibrations.some(r => r != null)) {
            document.getElementById("relativeChartWrapper").style.display = "block";

            if (!relativeChart) {
              relativeChart = new Chart(document.getElementById("relativeDataChart"), {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Relative Libration (×10⁻³ °/min)",
                      data: relLibrations,
                      borderColor: "red",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y1"
                    },
                    {
                      label: "Relative Spread, Hz",
                      data: relDopplers,
                      borderColor: "green",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y2"
                    },
                    {
                      label: "Polarization Offset (°)",
                      data: polOffsets,
                      borderColor: "blue",
                      pointRadius: 0,
                      borderWidth: 1.5,
                      tension: 0.2,
                      yAxisID: "y3"
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      title: { display: true, text: "Time (UTC)", font: { size: 10, family: 'Arial, sans-serif' } },
                      ticks: { font: { size: 10 } }
                    },
                    y1: {
                      type: "linear",
                      display: true,
                      position: "right",
                      title: { display: true, text: "Rel. Libration (×10⁻³ °/min)", color: "red", font: { size: 10, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: 5,
                      ticks: { stepSize: 1, color: "red", font: { size: 12 } },
                      grid: { drawTicks: true, drawBorder: true }
                    },
                    y2: {
                      type: "linear",
                      display: true,
                      position: "right",
                      offset: true,
                      title: { display: true, text: "Rel. Spread (Hz)", color: "green", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: 0,
                      max: maxDoppler,
                      grid: { drawOnChartArea: false },
                      ticks: {
                        stepSize: Math.ceil(maxDoppler / 6),
                        color: "green",
                        font: { size: 12 },
                        callback: function(value) {
                          return Math.round(value); // Format as integer
                        }
                      }
                    },
                    y3: {
                      type: "linear",
                      display: true,
                      position: "left",
                      title: { display: true, text: "Polarization Offset (°)", color: "blue", font: { size: 12, family: 'Arial, sans-serif' } },
                      min: -90,
                      max: 90,
                      grid: { drawOnChartArea: false },
                      ticks: { stepSize: 30, callback: val => val + "°", color: "blue", font: { size: 12 } }
                    }
                  },
                  plugins: {
                    legend: { display: false },
                    annotation: { annotations: relativeAnnotation }
                  }
                }
              });
            } else {
              relativeChart.data.labels = labels;
              relativeChart.data.datasets[0].data = relLibrations;
              relativeChart.data.datasets[1].data = relDopplers;
              relativeChart.data.datasets[2].data = polOffsets;
              relativeChart.options.plugins.annotation.annotations = relativeAnnotation;
              relativeChart.options.plugins.annotation.annotations.timeMarker.value = index;
              relativeChart.options.scales.y2.max = maxDoppler;
              relativeChart.options.scales.y2.ticks.stepSize = Math.ceil(maxDoppler / 6);
              relativeChart.update('none');
            }

            const relRateStr = currentRelRate != null ? (currentRelRate / 1000).toFixed(4) : null;
            document.getElementById('relativeChartLabel').innerHTML =
              `<span class="metric-label metric-rel-libration">Rel LR:</span> ${relRateStr != null ? relRateStr + '°/min' : 'N/A'}` +
              `<span class="metric-separator"> | </span>` +
              `<span class="metric-label metric-rel-doppler">DX Width:</span> ${currentRelDoppler != null ? currentRelDoppler.toFixed(0) + ' Hz' : 'N/A'}` +
              `<span class="metric-separator"> | </span>` +
              `<span class="metric-label metric-poloffset">Dpol:</span> ${currentPolOffset != null ? currentPolOffset.toFixed(1) + '°' : 'N/A'}`;
          } else {
            document.getElementById("relativeChartWrapper").style.display = "none";
            if (relativeChart) {
              relativeChart.destroy();
              relativeChart = null;
            }
            document.getElementById('relativeChartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH and DX</span>';
          }

          // Update map and moon chart with exact time
          const exactTime = isRealtime ? new Date() : new Date(`${dateStr}T${Math.floor(index / 2).toString().padStart(2, '0')}:${String((index % 2) * 30).padStart(2, '0')}:00Z`);
          updateMap(exactTime);
          updateMoonChart(exactTime);
        }

                                                function startRealTimeUpdates() {
                                                    if (isRealTimeMode) {
                                                        console.log('startRealTimeUpdates: Starting real-time updates'); // Debug log
                                                        stopRealTimeUpdates(); // Clear any existing interval
                                                        updateRealTime(); // Perform immediate update
                                                        const now = new Date();
                                                        const secondsUntilNextMinute = 60 - now.getUTCSeconds();
                                                        const millisecondsUntilNextMinute = secondsUntilNextMinute * 1000 - now.getUTCMilliseconds();
                                                        setTimeout(() => {
                                                            if (isRealTimeMode) { // Double-check mode
                                                                updateRealTime();
                                                                realTimeInterval = setInterval(updateRealTime, 60000);
                                                            } else {
                                                                console.log('startRealTimeUpdates: Aborted interval start due to real-time mode off'); // Debug log
                                                            }
                                                        }, millisecondsUntilNextMinute);
                                                    } else {
                                                        console.log('startRealTimeUpdates: Skipped because real-time mode is off'); // Debug log
                                                    }
                                                }

        function stopRealTimeUpdates() {
          if (realTimeInterval) {
            clearInterval(realTimeInterval);
            realTimeInterval = null;
          }
        }

                                                function updateRealTime() {
                                                    if (!isRealTimeMode) {
                                                        console.log('updateRealTime: Skipped because real-time mode is off');
                                                        return;
                                                    }
                                                    console.log('updateRealTime: Running real-time update');
                                                    const now = new Date();
                                                    const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                                    document.getElementById('date').valueAsDate = utcDate;
                                                    document.getElementById('date').value = utcDate.toISOString().slice(0, 10);

                                                    const hour = now.getUTCHours();
                                                    const minute = now.getUTCMinutes();
                                                    const fractionalIndex = hour * 2 + (minute / 30);
                                                    const displayHour = String(hour).padStart(2, '0');
                                                    const displayMin = String(minute).padStart(2, '0');
                                                    document.getElementById('hour-value').textContent = `Time (UTC): ${displayHour}:${displayMin}`;

                                                    const dateStr = utcDate.toISOString().slice(0, 10);
                                                    const qthInput = document.getElementById('qth').value.trim().toUpperCase();
                                                    const dxInput = document.getElementById('dx').value.trim().toUpperCase();
                                                    if (qthInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput) && qthDayData.date !== dateStr) {
                                                        computeLibrationForDay(qthInput, dateStr, 'qth');
                                                        computeFullDayData(qthDayData, qthInput, dateStr, true);
                                                    }
                                                    if (dxInput && /^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput) && dxDayData.date !== dateStr) {
                                                        computeLibrationForDay(dxInput, dateStr, 'dx');
                                                        computeFullDayData(dxDayData, dxInput, dateStr, false);
                                                    }
                                                    if (moonDayData.date !== dateStr) {
                                                        moonDayData.date = null; // Invalidate Moon data cache
                                                        calculateMoonDataForMonth(dateStr);
                                                    }
                                                    updateChart(fractionalIndex, true);
                                                }
        
        function decodeEmail(obfuscated) {
            try {
                const reversed = obfuscated.split('').reverse().join('');
                return atob(reversed);
            } catch (e) {
                return '';
            }
        }
        
        let markers = []; // Store markers globally for filtering

                                                function updateMarkers(data, showActiveOnly) {
                                                    // Clear existing markers
                                                    markers.forEach(marker => marker.setMap(null));
                                                    markers = [];

                                                    const coordinateMap = new Map();

                                                    // First pass: Count stations per coordinate
                                                    data.forEach(station => {
                                                        const { Coordinates, Note = '' } = station;
                                                        if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                                                            return; // Skip stations with DXpedition or SK in Note
                                                        }
                                                        const [latStr, lngStr] = Coordinates.split(',');
                                                        const lat = parseFloat(latStr);
                                                        const lng = parseFloat(lngStr);
                                                        if (isNaN(lat) || isNaN(lng)) {
                                                            console.warn(`Invalid coordinates for station ${station.Call}: ${Coordinates}`);
                                                            return;
                                                        }
                                                        const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                                                        coordinateMap.set(coordKey, (coordinateMap.get(coordKey) || 0) + 1);
                                                    });

                                                    // Get the current band
                                                    const band = document.getElementById('bandSelect').value;

                                                    // Second pass: Create markers with conditional offsets
                                                    data.forEach(station => {
                                                        const {
                                                            Call: callsign,
                                                            Locator: locator,
                                                            Antenna: antenna,
                                                            Power: power,
                                                            Website: website,
                                                            CK: obfuscatedEmail = '',
                                                            Coordinates,
                                                            Note = '',
                                                            Name = ''
                                                        } = station;

                                                        if (showActiveOnly && (Note.includes('DXpedition') || Note.includes('SK') || Note.includes('Inactive'))) {
                                                            return; // Skip stations with DXpedition or SK in Note
                                                        }

                                                        const email = decodeEmail(obfuscatedEmail);
                                                        const [latStr, lngStr] = Coordinates.split(',');
                                                        const lat = parseFloat(latStr);
                                                        const lng = parseFloat(lngStr);
                                                        if (isNaN(lat) || isNaN(lng)) {
                                                            console.warn(`Skipping station ${callsign} due to invalid coordinates: ${Coordinates}`);
                                                            return;
                                                        }

                                                        const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                                                        let offsetIndex = coordinateMap.get(coordKey + '_index') || 0;
                                                        coordinateMap.set(coordKey + '_index', offsetIndex + 1);

                                                        let markerPosition = { lat, lng };
                                                        const count = coordinateMap.get(coordKey);
                                                        if (count > 1) {
                                                            const offset = 0.01;
                                                            const angle = (offsetIndex * 2 * Math.PI) / count;
                                                            markerPosition = {
                                                                lat: lat + offset * Math.cos(angle),
                                                                lng: lng + offset * Math.sin(angle)
                                                            };
                                                        }

                                                        let iconUrl = "images/EME_home.png";
                                                        if (/Inactive/i.test(Note)) {
                                                            iconUrl = "images/EME_inactive.png";
                                                        } else if (/SK/i.test(Note)) {
                                                            iconUrl = "images/EME_SK.png";
                                                        } else if (/DXpedition|Portable/i.test(Note)) {
                                                            iconUrl = "images/EME_dxped2.png";
                                                        }

                                                        const marker = new google.maps.Marker({
                                                            position: markerPosition,
                                                            map: map,
                                                            icon: {
                                                                url: iconUrl,
                                                                scaledSize: new google.maps.Size(20, 20)
                                                            },
                                                            title: callsign
                                                        });

                                                        markers.push(marker);

                                                        const isLocatorValid = /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator);
                                                        const sanitizedCallsign = sanitizeCallsign(callsign);
                                                        const skedButton = isLocatorValid ?
                                                            `<button id="sked-${sanitizedCallsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>` :
                                                            '';
                                                        const emailButton = email ?
                                                            `<a id="email-${sanitizedCallsign}" class="email-button" href="mailto:${email}">Email</a>` :
                                                            '';
                                                        const qrzButton = `<a id="qrz-${sanitizedCallsign}" class="qrz-button" href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ</a>`;
                                                        const callsignDisplay = callsign +
                                                            (/SK/i.test(Note) ? ' (SK)' : '') +
                                                            (/Inactive/i.test(Note) ? ' (not active)' : '');
                                                        const displayWebsite = website.length > 30 ? website.slice(0, 30) + '...' : website;
                                                        const nameLine = Name ? `<div><strong>${Name}</strong></div>` : '';

                                                        // Construct band-specific and generic image URLs
                                                        const bandSpecificImageUrl = `db/${sanitizedCallsign}-${band}.jpg`;
                                                        const bandSpecificThumbUrl = `db/${sanitizedCallsign}_thumb-${band}.jpg`;
                                                        const genericImageUrl = `db/${sanitizedCallsign}.jpg`;
                                                        const genericThumbUrl = `db/${sanitizedCallsign}_thumb.jpg`;

                                                        const infoContent = `
                                                            <div>
                                                                <div style="font-weight:bold; font-size: 16px;">${callsignDisplay}</div>
                                                                ${nameLine}
                                                                <div class="button-group-infowindow">
                                                                    ${skedButton}${emailButton}${qrzButton}
                                                                </div>
                                                                <div>Locator: ${locator}</div>
                                                                <div>Antenna: ${antenna}</div>
                                                                <div>Power: ${power}</div>
                                                                <div>Website: <a href="${website}" target="_blank">${displayWebsite}</a></div>
                                                                <div id="image-container-${sanitizedCallsign}">
                                                                    Station Picture (clickable):<br>
                                                                    <a id="image-link-${sanitizedCallsign}" href="${bandSpecificImageUrl}" target="_blank">
                                                                        <img id="station-image-${sanitizedCallsign}" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA" alt="${callsign} station"/>
                                                                    </a>
                                                                    <div id="image-placeholder-${sanitizedCallsign}" style="display:none;">
                                                                        <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        `;

                                                        const infoWindow = new google.maps.InfoWindow({ content: infoContent });

                                                        marker.addListener('click', () => {
                                                            if (currentInfoWindow) currentInfoWindow.close();
                                                            infoWindow.open(map, marker);
                                                            currentInfoWindow = infoWindow;

                                                            setTimeout(() => {
                                                                const imageElement = document.getElementById(`station-image-${sanitizedCallsign}`);
                                                                const imageLink = document.getElementById(`image-link-${sanitizedCallsign}`);
                                                                const placeholder = document.getElementById(`image-placeholder-${sanitizedCallsign}`);

                                                                // Check for band-specific thumbnail
                                                                fetch(bandSpecificThumbUrl, { method: 'HEAD' })
                                                                    .then(response => {
                                                                        if (response.ok) {
                                                                            // Band-specific image exists
                                                                            imageElement.src = bandSpecificThumbUrl;
                                                                            imageLink.href = bandSpecificImageUrl;
                                                                            placeholder.style.display = 'none';
                                                                        } else {
                                                                            // Fall back to generic thumbnail
                                                                            return fetch(genericThumbUrl, { method: 'HEAD' })
                                                                                .then(genericResponse => {
                                                                                    if (genericResponse.ok) {
                                                                                        imageElement.src = genericThumbUrl;
                                                                                        imageLink.href = genericImageUrl;
                                                                                        placeholder.style.display = 'none';
                                                                                    } else {
                                                                                        // No image available
                                                                                        imageElement.remove();
                                                                                        placeholder.style.display = 'block';
                                                                                    }
                                                                                });
                                                                        }
                                                                    })
                                                                    .catch(() => {
                                                                        // Error fetching band-specific image, try generic
                                                                        return fetch(genericThumbUrl, { method: 'HEAD' })
                                                                            .then(genericResponse => {
                                                                                if (genericResponse.ok) {
                                                                                    imageElement.src = genericThumbUrl;
                                                                                    imageLink.href = genericImageUrl;
                                                                                    placeholder.style.display = 'none';
                                                                                } else {
                                                                                    imageElement.remove();
                                                                                    placeholder.style.display = 'block';
                                                                                }
                                                                            })
                                                                            .catch(() => {
                                                                                imageElement.remove();
                                                                                placeholder.style.display = 'block';
                                                                            });
                                                                    });

                                                                const skedButton = document.getElementById(`sked-${sanitizedCallsign}`);
                                                                if (skedButton) {
                                                                    skedButton.addEventListener('click', () => {
                                                                        const locator = skedButton.getAttribute('data-locator');
                                                                        document.getElementById('dx').value = locator;
                                                                        const inputEvent = new Event('input', { bubbles: true });
                                                                        document.getElementById('dx').dispatchEvent(inputEvent);
                                                                    });
                                                                }

                                                                const emailButton = document.getElementById(`email-${sanitizedCallsign}`);
                                                                if (emailButton) {
                                                                    emailButton.addEventListener('click', () => {
                                                                    });
                                                                }

                                                                const qrzButton = document.getElementById(`qrz-${sanitizedCallsign}`);
                                                                if (qrzButton) {
                                                                    qrzButton.addEventListener('click', () => {
                                                                    });
                                                                }
                                                            }, 100);
                                                        });
                                                    });
                                                }

        function initMap() {
          map = new google.maps.Map(document.getElementById('map'), {
            zoom: 2,
            center: { lat: 0, lng: 0 },
            mapTypeId: 'terrain',
            gestureHandling: 'greedy',
            mapTypeControl: false,
            streetViewControl: false,
            fullscreenControl: false
          });

          const band = document.getElementById('bandSelect').value;
          const jsonFile = bandConfig[band].jsonFile;
          const showActiveOnly = isActiveStationsOnly;
          fetch(jsonFile)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }
              return response.json();
            })
            .then(data => {
              updateMarkers(data, showActiveOnly);
            })
            .catch(error => {
              console.error(`Error fetching ${jsonFile} in initMap:`, error);
            });
        }
        
        let isActiveStationsOnly = false; // Default state (equivalent to checkbox checked)

        document.getElementById('activeStationsButton').addEventListener('click', () => {
          isActiveStationsOnly = !isActiveStationsOnly;
          const activeButton = document.getElementById('activeStationsButton');
          activeButton.textContent = isActiveStationsOnly ? 'Active' : 'All';
          if (isActiveStationsOnly) {
            activeButton.classList.add('active');
          } else {
            activeButton.classList.remove('active');
          }
          const band = document.getElementById('bandSelect').value;
          const jsonFile = bandConfig[band].jsonFile;
          fetch(jsonFile)
            .then(response => response.json())
            .then(data => {
              updateMarkers(data, isActiveStationsOnly);
            })
            .catch(error => {
              console.error(`Error fetching ${jsonFile}:`, error);
            });
        });
        
                                                document.getElementById('realTimeButton').addEventListener('click', () => {
                                                    isRealTimeMode = !isRealTimeMode;
                                                    const autoTrackButton = document.getElementById('realTimeButton');
                                                    const hourSlider = document.getElementById('hour');
                                                    const dateInput = document.getElementById('date');
                                                    const prevDayButton = document.getElementById('prevDay');
                                                    const nextDayButton = document.getElementById('nextDay');

                                                    if (isRealTimeMode) {
                                                        console.log('realTimeButton: Enabling real-time mode'); // Debug log
                                                        autoTrackButton.classList.add('active');
                                                        autoTrackButton.textContent = 'Stop';
                                                        hourSlider.disabled = true;
                                                        dateInput.disabled = true;
                                                        prevDayButton.disabled = true;
                                                        nextDayButton.disabled = true;
                                                        startRealTimeUpdates();
                                                    } else {
                                                        console.log('realTimeButton: Disabling real-time mode'); // Debug log
                                                        autoTrackButton.classList.remove('active');
                                                        autoTrackButton.textContent = 'Track';
                                                        hourSlider.disabled = false;
                                                        dateInput.disabled = false;
                                                        prevDayButton.disabled = false;
                                                        nextDayButton.disabled = false;
                                                        stopRealTimeUpdates();
                                                        updateHourDisplay();
                                                        updateChart(hourIndex, false);
                                                    }
                                                });
        
        document.getElementById('bandSelect').addEventListener('change', () => {
          const band = document.getElementById('bandSelect').value;
          updateBand(band);
        });

        function parseCoordinates(coordinates) {
            const [latStr, lngStr] = coordinates.split(',');
            return {
                lat: parseFloat(latStr),
                lng: parseFloat(lngStr)
            };
        }

        function getMoonAnnotations(dateStr, lat, lon) {
            const observer = new Astronomy.Observer(lat, lon, 0);
            const jsDate = new Date(`${dateStr}T00:00:00Z`);
            const astroTime = Astronomy.MakeTime(jsDate);

            let riseEvent = null, setEvent = null;
            try {
                riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
            } catch (e) {
                console.warn(`Error calculating moonrise for ${dateStr}: ${e.message}`);
            }

            try {
                setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
            } catch (e) {
                console.warn(`Error calculating moonset for ${dateStr}: ${e.message}`);
            }

            const annotations = {};

            function formatTimeUTC(date) {
                return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
            }

            const targetDateStr = dateStr.slice(0, 10);

            if (riseEvent && riseEvent.date) {
                const riseDate = riseEvent.date;
                const riseDateStr = riseDate.toISOString().slice(0, 10);
                if (riseDateStr === targetDateStr) {
                    let index = timeToChartIndex(riseDate);
                    const isLate = riseDate.getUTCHours() >= 23 && riseDate.getUTCMinutes() >= 30;
                    annotations['moonrise'] = {
                        type: 'line',
                        mode: 'vertical',
                        scaleID: 'x',
                        value: isLate ? 47 : index,
                        borderColor: 'blue',
                        borderWidth: 1,
                        label: {
                            content: ['Rise', formatTimeUTC(riseDate)],
                            enabled: true,
                            position: 'top',
                            yAdjust: isLate ? -50 : -40,
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            color: 'white',
                            backgroundColor: 'rgba(0, 0, 255, 0.85)',
                            padding: 2,
                            cornerRadius: 6,
                            boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                            textAlign: 'center',
                            borderColor: 'rgba(255, 255, 255, 0.7)',
                            borderWidth: 1
                        }
                    };
                }
            }

            if (setEvent && setEvent.date) {
                const setDate = setEvent.date;
                const setDateStr = setDate.toISOString().slice(0, 10);
                if (setDateStr === targetDateStr) {
                    let index = timeToChartIndex(setDate);
                    const isLate = setDate.getUTCHours() >= 23 && setDate.getUTCMinutes() >= 30;
                    annotations['moonset'] = {
                        type: 'line',
                        mode: 'vertical',
                        scaleID: 'x',
                        value: isLate ? 47 : index,
                        borderColor: 'orange',
                        borderWidth: 1,
                        label: {
                            content: ['Set', formatTimeUTC(setDate)],
                            enabled: true,
                            position: 'top',
                            yAdjust: isLate ? -10 : -20,
                            font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                            color: 'white',
                            backgroundColor: 'rgba(255, 165, 0, 0.85)',
                            padding: 2,
                            cornerRadius: 6,
                            boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                            textAlign: 'center',
                            borderColor: 'rgba(255, 255, 255, 0.7)',
                            borderWidth: 1
                        }
                    };
                }
            }

            return annotations;
        }

        function timeToChartIndex(date) {
            if (!(date instanceof Date)) throw new Error("Expected a Date object");
            let hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
            if (hours >= 23.5) {
                hours = 23.5;
            }
            return hours * 2;
        }

        function getSkedAnnotations(dateStr, qthLat, qthLon, dxLat, dxLon) {
            const annotations = {};
            const targetDateStr = dateStr.slice(0, 10);
            const jsDate = new Date(`${dateStr}T00:00:00Z`);
            const astroTime = Astronomy.MakeTime(jsDate);

            const qthObserver = new Astronomy.Observer(qthLat, qthLon, 0);
            const dxObserver = new Astronomy.Observer(dxLat, dxLon, 0);

            let qthRiseEvent = null, qthSetEvent = null, dxRiseEvent = null, dxSetEvent = null;
            try {
                qthRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, +1, astroTime, 1.0);
                qthSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, qthObserver, -1, astroTime, 1.0);
                dxRiseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, +1, astroTime, 1.0);
                dxSetEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, dxObserver, -1, astroTime, 1.0);
            } catch (e) {
                console.warn(`Error calculating moonrise/set: ${e.message}`);
                return annotations;
            }

            function formatTimeUTC(date) {
                if (!date) return 'N/A';
                return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
            }

            function timeToChartIndex(date) {
                if (!(date instanceof Date)) return null;
                const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;
                let index = Math.round(hours * 2);
                if (index < 0) index = 0;
                if (index > 47) index = 47;
                return index;
            }

            let skedStartTime = null, skedEndTime = null;
            if (qthRiseEvent && qthSetEvent && dxRiseEvent && dxSetEvent &&
                qthRiseEvent.date && qthSetEvent.date && dxRiseEvent.date && dxSetEvent.date) {
                const qthRise = qthRiseEvent.date;
                const qthSet = qthSetEvent.date;
                const dxRise = dxRiseEvent.date;
                const dxSet = dxSetEvent.date;

                const isSameDay = (date) => date.toISOString().slice(0, 10) === targetDateStr;

                if (isSameDay(qthRise) && isSameDay(qthSet) && isSameDay(dxRise) && isSameDay(dxSet)) {
                    // Sked start is the later of the two rise times
                    skedStartTime = qthRise > dxRise ? qthRise : dxRise;
                    // Sked end is the earlier of the two set times
                    skedEndTime = qthSet < dxSet ? qthSet : dxSet;
                }
            }

            // No annotations for sked start/end as per user request
            return annotations;
        }

        document.getElementById("hour").addEventListener("input", () => {
            hourIndex = parseInt(document.getElementById("hour").value);
            const hour = Math.floor(hourIndex / 2);
            const minutes = (hourIndex % 2) * 30;
            document.getElementById("hour-value").textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            updateChart(hourIndex, false);
        });

        function adjustDate(days) {
            const dateInput = document.getElementById("date");
            const currentDate = new Date(dateInput.value);
            currentDate.setDate(currentDate.getDate() + days);
            dateInput.valueAsDate = currentDate;
            dateInput.value = currentDate.toISOString().slice(0,10);
            updateChart(hourIndex, false);
        }

        document.getElementById("prevDay").addEventListener("click", () => {
            adjustDate(-1);
        });

        document.getElementById("nextDay").addEventListener("click", () => {
            adjustDate(1);
        });

                                                document.getElementById("date").addEventListener("change", () => {
                                                    const qthInput = document.getElementById("qth").value.trim().toUpperCase();
                                                    const dxInput = document.getElementById("dx").value.trim().toUpperCase();
                                                    moonDayData.date = null; // Invalidate Moon data cache
                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
                                                        computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
                                                        computeFullDayData(qthDayData, qthInput, document.getElementById("date").value, true);
                                                    }
                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
                                                        computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
                                                        computeFullDayData(dxDayData, dxInput, document.getElementById("date").value, false);
                                                    }
                                                    updateChart(hourIndex, false);
                                                });

        window.onload = () => {
          const now = new Date();
          const utcHours = now.getUTCHours();
          const utcMinutes = now.getUTCMinutes();

          const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
          document.getElementById('date').valueAsDate = utcDate;
          document.getElementById('date').value = utcDate.toISOString().slice(0,10);

          let roundedHour = utcHours;
          let roundedMinutes = utcMinutes >= 15 && utcMinutes < 45 ? 30 : 0;
          if (utcMinutes >= 45) {
            roundedHour += 1;
            roundedMinutes = 0;
          }
          if (roundedHour >= 24) {
            roundedHour -= 24;
            utcDate.setUTCDate(utcDate.getUTCDate() + 1);
            document.getElementById('date').valueAsDate = utcDate;
            document.getElementById('date').value = utcDate.toISOString().slice(0,10);
          }

          hourIndex = roundedHour * 2 + (roundedMinutes === 30 ? 1 : 0);
          document.getElementById('hour').value = hourIndex;
          document.getElementById('hour-value').textContent =
            `Time (UTC): ${String(roundedHour).padStart(2, '0')}:${String(roundedMinutes).padStart(2, '0')}`;

          document.getElementById('showControlsPanel').classList.remove('visible');

          // Ensure real-time mode is off initially
          isRealTimeMode = false;
          document.getElementById('realTimeButton').classList.remove('active');
          document.getElementById('realTimeButton').textContent = 'Track';

          const qthInput = document.getElementById('qth').value.trim().toUpperCase();
          const dxInput = document.getElementById('dx').value.trim().toUpperCase();
          if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
            computeLibrationForDay(qthInput, document.getElementById('date').value, 'qth');
            computeFullDayData(qthDayData, qthInput, document.getElementById('date').value, true);
          }
          if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
            computeLibrationForDay(dxInput, document.getElementById('date').value, 'dx');
            computeFullDayData(dxDayData, dxInput, document.getElementById('date').value, false);
          }

          // Initialize band
          updateBand(document.getElementById('bandSelect').value);

          const currentNow = new Date();
          updateMap(currentNow);
          updateMoonChart(currentNow);
          updateChart(hourIndex, false);
        };
                                                    
        window.addEventListener('unload', () => {
          stopRealTimeUpdates();
        });

        const qthInputElem = document.getElementById("qth");
        const dxInputElem = document.getElementById("dx");

                                                qthInputElem.addEventListener("input", () => {
                                                    const locator = qthInputElem.value.trim().toUpperCase();
                                                    const chartLabel = document.getElementById('chartLabel');
                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                        chartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                        try {
                                                            computeLibrationForDay(locator, document.getElementById("date").value, 'qth');
                                                            computeFullDayData(qthDayData, locator, document.getElementById("date").value, true);
                                                            // Invalidate relDayData to force recompute
                                                            relDayData.date = null;
                                                            if (qthDayData.libration.length === 0) {
                                                                console.warn(`No data computed for QTH ${locator}`);
                                                                document.getElementById("chartWrapper").style.display = "none";
                                                                if (chart) {
                                                                    chart.destroy();
                                                                    chart = null;
                                                                }
                                                                chartLabel.innerHTML = '<span class="metric-locator">No data for QTH</span>';
                                                            } else {
                                                                setTimeout(() => {
                                                                    updateChart(hourIndex, isRealTimeMode);
                                                                }, 0);
                                                            }
                                                        } catch (e) {
                                                            console.error(`Error computing libration for QTH ${locator}: ${e.message}`);
                                                            document.getElementById("chartWrapper").style.display = "none";
                                                            if (chart) {
                                                                chart.destroy();
                                                                chart = null;
                                                            }
                                                            chartLabel.innerHTML = '<span class="metric-locator">Error computing QTH data</span>';
                                                        }
                                                    } else {
                                                        document.getElementById("chartWrapper").style.display = "none";
                                                        if (chart) {
                                                            chart.destroy();
                                                            chart = null;
                                                        }
                                                        // Invalidate relDayData when QTH is invalid
                                                        relDayData.date = null;
                                                        chartLabel.innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
                                                    }
                                                });

                                                dxInputElem.addEventListener("input", () => {
                                                    const locator = dxInputElem.value.trim().toUpperCase();
                                                    const dxChartLabel = document.getElementById('dxchartLabel');
                                                    if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                                        dxChartLabel.innerHTML = '<span class="metric-locator">Computing...</span>';
                                                        try {
                                                            computeLibrationForDay(locator, document.getElementById("date").value, 'dx');
                                                            computeFullDayData(dxDayData, locator, document.getElementById("date").value, false);
                                                            // Invalidate relDayData to force recompute
                                                            relDayData.date = null;
                                                            if (dxDayData.libration.length === 0) {
                                                                console.warn(`No data computed for DX ${locator}`);
                                                                document.getElementById("dxChartWrapper").style.display = "none";
                                                                if (dxChart) {
                                                                    dxChart.destroy();
                                                                    dxChart = null;
                                                                }
                                                                dxChartLabel.innerHTML = '<span class="metric-locator">No data for DX</span>';
                                                            } else {
                                                                setTimeout(() => {
                                                                    updateChart(hourIndex, isRealTimeMode);
                                                                }, 0);
                                                            }
                                                        } catch (e) {
                                                            console.error(`Error computing libration for DX ${locator}: ${e.message}`);
                                                            document.getElementById("dxChartWrapper").style.display = "none";
                                                            if (dxChart) {
                                                                dxChart.destroy();
                                                                dxChart = null;
                                                            }
                                                            dxChartLabel.innerHTML = '<span class="metric-locator">Error computing DX data</span>';
                                                        }
                                                    } else {
                                                        document.getElementById("dxChartWrapper").style.display = "none";
                                                        if (dxChart) {
                                                            dxChart.destroy();
                                                            dxChart = null;
                                                        }
                                                        // Invalidate relDayData when DX is invalid
                                                        relDayData.date = null;
                                                        document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
                                                    }
                                                });

        function qthToLatLon(locator) {
            if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
                throw new Error("Invalid QTH locator format (must be 6 characters)");
            }
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
            const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
            return { lat, lon };
        }

        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }
        function calcPoloffset(latDeg, azMoonDeg, elMoonDeg) {
            const lat = degToRad(latDeg);
            const az = degToRad(azMoonDeg);
            const el = degToRad(elMoonDeg);

            const xx = Math.sin(lat) * Math.cos(el) - Math.cos(lat) * Math.cos(az) * Math.sin(el);
            const yy = Math.cos(lat) * Math.sin(az);

            let angleRad = Math.atan2(yy, xx);
            return radToDeg(angleRad);
        }

        function calcPoloffsetDiff(pol1, pol2) {
            let diff = (pol2 - pol1 + 720) % 180;
            if (diff > 90) diff -= 180;
            return diff;
        }
        function sanitizeCallsign(callsign) {
            return callsign.replace(/\//g, '_');
        }
        
        document.getElementById("toggleControlsPanel").addEventListener("click", () => {
            const controls = document.getElementById("controls");
            const toggleButton = document.getElementById("toggleControlsPanel");
            const showButton = document.getElementById("showControlsPanel");

            if (!controls.classList.contains("folded")) {
                controls.classList.add("folded");
                toggleButton.style.display = "none";
                showButton.classList.add("visible");
                setTimeout(() => {
                    showButton.style.display = 'none';
                    showButton.offsetHeight;
                    showButton.style.display = 'flex';
                }, 0);
            }
        });

        document.getElementById("showControlsPanel").addEventListener("click", () => {
            const controls = document.getElementById("controls");
            const toggleButton = document.getElementById("toggleControlsPanel");
            const showButton = document.getElementById("showControlsPanel");

            if (controls.classList.contains("folded")) {
                controls.classList.remove("folded");
                toggleButton.style.display = "block";
                showButton.classList.remove("visible");
                setTimeout(() => {
                    showButton.style.display = 'none';
                    showButton.offsetHeight;
                }, 0);
                if (chart) chart.resize();
                if (dxChart) dxChart.resize();
                if (relativeChart) relativeChart.resize();
                if (moonChart) moonChart.resize();
            }
        });
    </script>
    <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAPRWRoTRhE5TddxBITIhBcKjdQpz2CXRs&callback=initMap"></script>
    <!-- Ko-Fi -->
    <script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
    <script src="/kofi.js"></script>
</body>
</html>
