<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EME Observer – Moon Footprint (fixed)</title>
  <link rel="stylesheet" href="/leaflet/leaflet.css" />
  <script src="/leaflet/leaflet.js"></script>
  <script src="/leaflet/Leaflet.greatCircle.js"></script>
  <script src="a.ob.js"></script>
  <style>
    html,body { margin:0; padding:0; height:100%; font-family:Arial,Helvetica,sans-serif; }
    #map { height:100dvh; width:100%; }
    #controls {
      position:absolute; left:10px; top:10px; z-index:1000;
      background:rgba(255,255,255,0.95); padding:12px; border-radius:8px;
    }
    #hour { width:320px; }
    button{padding:5px 10px; border-radius:4px; background:#007bff; color:white; border:none}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <div>
      <button id="prevDay">←</button>
      <input type="date" id="date" />
      <button id="nextDay">→</button>
    </div>
    <div style="margin-top:8px;">
      <input id="hour" type="range" min="0" max="47" step="1" value="0" />
      <div id="hour-value">Time (UTC): 00:00</div>
    </div>
  </div>

  <script>
    // Globals
    let map, moonLayer;
    let hourIndex = 0;

    function initMap() {
      map = L.map('map', {
        center: [0, 0],
        zoom: 2,
        worldCopyJump: true,   // recommended by plugin docs for wrapping behavior
        scrollWheelZoom: true,
        zoomControl: false
      });

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // LayerGroup to contain all moon-related overlays (marker + footprint)
      moonLayer = L.layerGroup().addTo(map);

      updateMap();
    }

    function updateMap() {
      // Clear previous moon overlays (marker + footprint)
      if (moonLayer) moonLayer.clearLayers();

      const selectedDate = document.getElementById('date').value;
      const index = parseInt(document.getElementById('hour').value, 10);
      const hour = Math.floor(index / 2).toString().padStart(2, '0');
      const minutes = (index % 2 === 0) ? '00' : '30';
      const utcTimeString = `${selectedDate}T${hour}:${minutes}:00Z`;

      if (!selectedDate || !/^\d{4}-\d{2}-\d{2}$/.test(selectedDate)) {
        console.warn('Invalid date input:', selectedDate);
        return;
      }

      const utcDate = new Date(utcTimeString);
      if (isNaN(utcDate.getTime())) {
        console.error('Invalid UTC date string:', utcTimeString);
        return;
      }

      try {
        // compute moon data (your astronomy lib)
        const time = Astronomy.MakeTime(utcDate);
        const observer = new Astronomy.Observer(0, 0, 0);
        const moon = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
        const libration = Astronomy.Libration(time);

        if (!moon || !libration) {
          console.warn('Astronomy results missing for', utcTimeString);
          return;
        }

        const raHours = moon.ra;
        const decDeg = moon.dec;
        const raDeg = raHours * 15;
        let gastDeg = Astronomy.SiderealTime(time) * 15;
        gastDeg = ((gastDeg % 360) + 360) % 360;

        let lonDeg = raDeg - gastDeg;
        lonDeg = ((lonDeg + 180) % 360) - 180;

        const lat = Number(decDeg);
        const lon = Number(lonDeg);

        // --- safe geometry/radius computation ---
        const earthRadiusKm = 6371; // km
        const D_moon_km = Number(libration.dist_km);
        if (!isFinite(D_moon_km) || D_moon_km <= 0) {
          console.error('Bad moon distance:', libration);
          return;
        }

        // clamp the ratio to [-1,1] to avoid NaN in acos due to FP issues
        const ratio = earthRadiusKm / (earthRadiusKm + D_moon_km);
        const safeRatio = Math.min(1, Math.max(-1, ratio));
        const theta_rad = Math.acos(safeRatio);

        const footprintRadius_m = earthRadiusKm * theta_rad * 1000; // meters

        if (!isFinite(lat) || !isFinite(lon) || !isFinite(footprintRadius_m)) {
          console.warn('Invalid sublunar point or radius', { lat, lon, footprintRadius_m });
          return;
        }

        console.log(`Sublunar: lat=${lat.toFixed(4)} lon=${lon.toFixed(4)} radius_m=${Math.round(footprintRadius_m)}`);

        // create marker and great-circle (use L.latLng to be explicit)
        const center = L.latLng(lat, lon);
        const moonIcon = L.icon({
          iconUrl: 'images/moon-icon.png',
          iconSize: [48, 48],
          iconAnchor: [24, 24]
        });

        const marker = L.marker(center, {
          icon: moonIcon,
          title: `Moon Sublunar (${lat.toFixed(2)}°, ${lon.toFixed(2)}°)`
        });

        // IMPORTANT: disable wrapElements (or set maxCopies: 0) if you want
        // a single polygon that is straightforward to remove.
        const footprint = L.greatCircle(center, {
          radius: footprintRadius_m,
          color: '#0000FF',
          fillColor: '#0088FF',
          fillOpacity: 0.28,
          weight: 2,
          // toggle wrapping behavior:
          wrapElements: false,   // <-- set false to avoid plugin creating duplicate copy layers
          maxCopies: 0,          // another way to force zero copies
          clipLat: 65,
          degStep: 0.5
        });

        // Add both to our group (so clearLayers() removes them reliably)
        moonLayer.addLayer(footprint);
        moonLayer.addLayer(marker);

        try { footprint.bringToFront(); } catch (e) { /* ignore if not available */ }

        // center (do not zoom in too far every update)
        map.panTo(center);
        map.setZoom(2);

      } catch (err) {
        console.error('Error calculating sublunar point:', err);
        if (moonLayer) moonLayer.clearLayers();
      }
    }

    // UI wiring
    document.getElementById('hour').addEventListener('input', () => {
      hourIndex = parseInt(document.getElementById('hour').value, 10);
      const hh = Math.floor(hourIndex / 2);
      const mm = (hourIndex % 2) ? 30 : 0;
      document.getElementById('hour-value').textContent = `Time (UTC): ${String(hh).padStart(2,'0')}:${mm===0?'00':'30'}`;
      updateMap();
    });

    function adjustDate(days) {
      const dateInput = document.getElementById('date');
      const cur = new Date(dateInput.value);
      cur.setDate(cur.getDate() + days);
      dateInput.valueAsDate = cur;
      updateMap();
    }

    document.getElementById('prevDay').addEventListener('click', () => adjustDate(-1));
    document.getElementById('nextDay').addEventListener('click', () => adjustDate(1));
    document.getElementById('date').addEventListener('change', updateMap);

    // init date/time to nearest 30m UTC
    window.onload = () => {
      const now = new Date();
      const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      document.getElementById('date').valueAsDate = utcDate;

      const utcHours = now.getUTCHours();
      const utcMinutes = now.getUTCMinutes();
      let roundedHour = utcHours;
      let roundedMinutes = (utcMinutes >= 15 && utcMinutes < 45) ? 30 : 0;
      if (utcMinutes >= 45) { roundedHour += 1; roundedMinutes = 0; }
      if (roundedHour >= 24) {
        roundedHour -= 24;
        utcDate.setUTCDate(utcDate.getUTCDate() + 1);
        document.getElementById('date').valueAsDate = utcDate;
      }
      hourIndex = roundedHour * 2 + (roundedMinutes === 30 ? 1 : 0);
      document.getElementById('hour').value = hourIndex;
      document.getElementById('hour-value').textContent =
        `Time (UTC): ${String(roundedHour).padStart(2,'0')}:${roundedMinutes === 0 ? '00':'30'}`;

      initMap();
    };
  </script>
</body>
</html>
