<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Sky Observer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    
    html, body {
      touch-action: none; /* Disable browser default gestures */
    }

      button {
        min-width: 44px;
        min-height: 44px;
      }

      #infoBox {
        position: absolute;
        top: 10px;
        right: 10px;           /* Move it to the right */
        left: auto;            /* Clear left positioning */
        padding: 10px;
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-family: monospace;
        font-size: 14px;
        display: none;
        max-width: 80vw;
        z-index: 10;
        text-align: right;     /* Align text to the right */
        width: fit-content;    /* Prevent full-page stretching */
      }


      @media (max-width: 600px), (orientation: portrait) {
        #infoBox {
          font-size: 20px;
          padding: 16px;
          top: 15px;
          right: 15px;
          left: auto;
          text-align: right;
          width: fit-content;
          max-width: 90vw;
          line-height: 1.4;
        }
      }


      
      #moonTimeControls button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        color: white;
        font-size: 24px;
        font-family: sans-serif;
        padding: 10px 20px;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      }

      #moonTimeControls button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }

      #moonTimeControls button:active {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(0.97);
      }

      #moonTimeDisplay {
        color: white;
        font-family: 'Courier New', monospace;
        font-size: 20px;
        padding: 8px 12px;
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      /* Style for date picker buttons */
      #prevDate, #nextDate {
          padding: 1px 6px; /* Reduced padding to make buttons less tall */
          font-size: 10px; /* Slightly smaller font */
          line-height: 1.2; /* Reduced line-height for compactness */
          min-height: 20px; /* Smaller height, still touch-friendly */
          width: 24px; /* Fixed width for consistency */
          border-radius: 4px;
          background: #444;
          color: white;
          border: none;
          cursor: pointer;
          transition: background 0.2s, transform 0.2s;
      }
      #prevDate:hover, #nextDate:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
      }
      #prevDate:active, #nextDate:active {
          background: rgba(255, 255, 255, 0.3);
          transform: scale(0.97);
      }

      /* Style for time slider */
      #timeSlider {
          -webkit-appearance: none;
          appearance: none;
          background: rgba(255, 255, 255, 0.2);
          height: 6px;
          border-radius: 3px;
          outline: none;
      }
      #timeSlider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
      }
      #timeSlider::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
      }
      #timeSlider:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }
      
  </style>

</head>
<body>
    <!-- App Title + Author + Buttons -->
    <div style="position: absolute; top: 8px; left: 8px; z-index: 30; font-family: 'Segoe UI', sans-serif;">
      <div style="display: flex; flex-direction: row; align-items: flex-end; gap: 8px;">
        <!-- Left side: Author + App Name -->
        <div style="display: flex; flex-direction: column; align-items: flex-end; line-height: 1;">
          <div style="font-size: 10px; color: #aaa; padding-right: 2px;">
            by SA5IKN
          </div>
          <div style="font-size: 16px; color: white; font-weight: 600; background: rgba(0, 0, 0, 0.6); padding: 2px 4px; border-radius: 2px;">
            Sky Observer
          </div>
        </div>
        <!-- Right side: Buttons -->
        <div style="display: flex; flex-direction: row; gap: 4px;">
          <a href="https://dxer.site" target="_blank" title="Go to homepage"
             style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
            üè†
          </a>
          <a href="https://dxer.site/sky-observer-faq.html" target="_blank" title="Open FAQ"
             style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
            ‚ùì
          </a>
        </div>
      </div>
    </div>

    <!-- Ultra-Compact Control Panel -->
    <div id="controlPanel" style="
      position: absolute;
      top: 36px;
      left: 8px;
      z-index: 20;
      background: rgba(0,0,0,0.6);
      padding: 6px 8px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-family: 'Segoe UI', sans-serif;
      font-size: 12px;
      color: white;
      max-width: 160px;
    ">
      <!-- Grid -->
      <div style="display: flex; align-items: center; gap: 4px;">
        <label for="gridInput">Grid:</label>
        <input type="text" id="gridInput" maxlength="6" placeholder="e.g. JO89tt"
               style="width: 60px; font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none;">
      </div>
      <!-- CSV -->
      <div style="display: flex; flex-direction: column; gap: 2px;">
        <label for="csvUpload">
          CSV <span style="font-size: 9px; color: #ccc;">(e.g. from SkyScanner)</span>:
        </label>
        <input type="file" id="csvUpload" accept=".csv"
               style="font-size: 10px; padding: 2px 0px; color: white;">
      </div>
      <!-- Date with Previous/Next Buttons -->
      <div style="display: flex; align-items: center; gap: 4px;">
        <button id="prevDate">&lt;</button>
        <input type="date" id="datePicker"
               style="font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none; width: 100px;">
        <button id="nextDate">&gt;</button>
      </div>
      <!-- Show Sun Checkbox -->
      <div style="display: flex; align-items: center; gap: 4px;">
        <input type="checkbox" id="showSun" style="width: 14px; height: 14px;">
        <label for="showSun">Show sun</label>
      </div>
      <div id="demoStatus" style="color: red; font-weight: bold; margin-top: 10px;">
        Demo loaded!
      </div>
    </div>

    <!-- Time Slider -->
    <div id="moonTimeControls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 10px;">
      <span id="moonTimeDisplay" style="color: white; font-family: 'Courier New', monospace; font-size: 18px; padding: 8px 12px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.2);">
        --:-- UTC
      </span>
      <input type="range" id="timeSlider" min="0" max="0" value="0" aria-label="Time selection"
             style="width: 200px; accent-color: #fff; cursor: pointer;">
    </div>

    <script src="a.ob.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
      // Note: This code uses localStorage to persist user-uploaded CSV data and grid locator across sessions.
      // The data is stored locally on the user's device and not sent to any server.
      // No privacy disclaimers are required unless the CSV contains personal data or your app
      // is subject to GDPR/CCPA. If needed, add a note to your FAQ page (e.g., at https://dxer.site/sky-observer-faq.html)
      // stating: "Sky Observer stores user-uploaded CSV files and grid locator locally in your browser to restore them on future visits."

      const scene = new THREE.Scene();
      const moonTrajectoryGroup = new THREE.Group();
      const sunTrajectoryGroup = new THREE.Group();
      
      let moonPositions = [];
      let sunPositions = [];
      let currentTimeIndex = 0;
      let moonMarker = null;
      let sunMarker = null;
      
      const moonTimeDisplay = document.getElementById('moonTimeDisplay');
      const timeSlider = document.getElementById('timeSlider');
      const datePicker = document.getElementById('datePicker');
      const prevDateBtn = document.getElementById('prevDate');
      const nextDateBtn = document.getElementById('nextDate');
      const gridInput = document.getElementById('gridInput');
      const showSunCheckbox = document.getElementById('showSun');
      const demoStatus = document.getElementById('demoStatus');

      function updateMoonMarker() {
        if (!moonPositions.length || !moonPositions[currentTimeIndex] || moonPositions[currentTimeIndex].elevation <= 0) {
          moonTimeDisplay.textContent = '--:-- UTC';
          if (moonMarker) moonMarker.visible = false;
          return;
        }

        const pos = moonPositions[currentTimeIndex];
        if (!moonMarker) {
          const geom = new THREE.SphereGeometry(0.03);
          const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          moonMarker = new THREE.Mesh(geom, mat);
          scene.add(moonMarker);
        }

        moonMarker.visible = true;
        moonMarker.position.copy(pos.position);

        const time = pos.time;
        const hours = String(time.getUTCHours()).padStart(2, '0');
        const minutes = String(time.getUTCMinutes()).padStart(2, '0');
        moonTimeDisplay.textContent = `${hours}:${minutes} UTC`;
      }

      function updateSunMarker() {
        if (!sunPositions.length || !showSunCheckbox.checked || !sunPositions[currentTimeIndex] || sunPositions[currentTimeIndex].elevation <= 0) {
          if (sunMarker) sunMarker.visible = false;
          return;
        }

        if (!sunMarker) {
          const geom = new THREE.SphereGeometry(0.02);
          const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
          sunMarker = new THREE.Mesh(geom, mat);
          scene.add(sunMarker);
        }

        sunMarker.visible = true;
        const pos = sunPositions[currentTimeIndex];
        sunMarker.position.copy(pos.position);
      }

      function updateTimeSlider() {
        timeSlider.min = 0;
        timeSlider.max = moonPositions.length - 1 || 0;
        timeSlider.value = currentTimeIndex;
        timeSlider.disabled = moonPositions.length === 0;
        if (moonPositions.length && moonPositions[currentTimeIndex]) {
          updateMoonMarker();
          updateSunMarker();
        }
      }

      function changeTime(index) {
        if (!moonPositions.length) return;
        currentTimeIndex = Math.max(0, Math.min(index, moonPositions.length - 1));
        updateMoonMarker();
        updateSunMarker();
      }

      function changeDate(days) {
        let currentDate = datePicker.value ? new Date(datePicker.value) : new Date();
        currentDate.setUTCDate(currentDate.getUTCDate() + days);
        const year = currentDate.getUTCFullYear();
        const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getUTCDate()).padStart(2, '0');
        datePicker.value = `${year}-${month}-${day}`;
        addTrajectories(datePicker.value);
      }

      timeSlider.addEventListener('input', (e) => {
        changeTime(parseInt(e.target.value));
      });

      datePicker.addEventListener('change', (e) => {
        const selectedDate = e.target.value;
        if (selectedDate) {
          addTrajectories(selectedDate);
        }
      });

      prevDateBtn.addEventListener('click', () => changeDate(-1));
      nextDateBtn.addEventListener('click', () => changeDate(1));

      showSunCheckbox.addEventListener('change', () => {
        sunTrajectoryGroup.visible = showSunCheckbox.checked;
        updateSunMarker();
      });

      function isValidGrid(locator) {
        if (!locator || locator.length < 4 || locator.length > 6) return false;
        locator = locator.toUpperCase();
        const regex = /^[A-R]{2}[0-9]{2}([A-X]{2})?$/;
        return regex.test(locator);
      }

      gridInput.addEventListener('input', () => {
        const grid = gridInput.value;
        if (isValidGrid(grid)) {
          gridInput.style.borderColor = '#fff';
          localStorage.setItem('skyObserverGrid', grid);
          const dateVal = datePicker.value || new Date().toISOString().split('T')[0];
          addTrajectories(dateVal);
        } else {
          gridInput.style.borderColor = 'red';
        }
      });

      function maidenheadToLatLon(locator) {
        if (!locator || locator.length < 4) return null;

        locator = locator.toUpperCase();
        const A = 'A'.charCodeAt(0);

        let lon = (locator.charCodeAt(0) - A) * 20 - 180;
        let lat = (locator.charCodeAt(1) - A) * 10 - 90;

        lon += parseInt(locator[2]) * 2;
        lat += parseInt(locator[3]) * 1;

        if (locator.length >= 6) {
          lon += (locator.charCodeAt(4) - A) * 5 / 60;
          lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
        }

        lon += 2.5 / 60;
        lat += 1.25 / 60;

        return { lat, lon };
      }

      scene.add(moonTrajectoryGroup);
      scene.add(sunTrajectoryGroup);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 2);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let spheres = [];

      let minNoise = Infinity, maxNoise = -Infinity;
      const rawPoints = [];

      function getColor(noise) {
        const range = maxNoise - minNoise;
        const norm = range === 0 ? 0.5 : (noise - minNoise) / range;
        return new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
      }

      const infoBox = document.createElement('div');
      infoBox.id = 'infoBox';
      infoBox.style.position = 'absolute';
      infoBox.style.top = '10px';
      infoBox.style.right = '10px';
      infoBox.style.padding = '10px';
      infoBox.style.background = 'rgba(0,0,0,0.7)';
      infoBox.style.color = '#fff';
      infoBox.style.fontFamily = 'monospace';
      infoBox.style.display = 'none';
      document.body.appendChild(infoBox);

      function addAzimuthCompass() {
        const compassRadius = 1.05;
        const labelDistance = 1.2;
        const compassGroup = new THREE.Group();

        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
          const directions = [
            { label: 'N', az: 0, color: 0xff0000 },
            { label: 'E', az: 90, color: 0xffffff },
            { label: 'S', az: 180, color: 0xffffff },
            { label: 'W', az: 270, color: 0xffffff }
          ];

          directions.forEach(dir => {
            const azRad = THREE.MathUtils.degToRad(360 - dir.az);
            const x = labelDistance * Math.sin(azRad);
            const z = labelDistance * Math.cos(azRad);
            const y = 0;

            const textGeom = new THREE.TextGeometry(dir.label, {
              font: font,
              size: 0.1,
              height: 0.001
            });

            const textMat = new THREE.MeshBasicMaterial({ color: dir.color });
            const text = new THREE.Mesh(textGeom, textMat);
            text.position.set(x, y, z);
            text.lookAt(0, 0, 0);
            compassGroup.add(text);
          });

          const ringGeom = new THREE.RingGeometry(compassRadius - 0.002, compassRadius + 0.002, 256);
          const ringMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
          });
          const ring = new THREE.Mesh(ringGeom, ringMat);
          ring.rotation.x = -Math.PI / 2;
          ring.position.y = 0;
          compassGroup.add(ring);

          for (let i = 0; i < 360; i += 10) {
            const angle = THREE.MathUtils.degToRad(360 - i);
            const isMajor = i % 30 === 0;
            const outer = compassRadius + 0.02;
            const inner = compassRadius - (isMajor ? 0.05 : 0.02);

            const x1 = inner * Math.cos(angle);
            const z1 = inner * Math.sin(angle);
            const x2 = outer * Math.cos(angle);
            const z2 = outer * Math.sin(angle);

            const tickGeom = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x1, 0, z1),
              new THREE.Vector3(x2, 0, z2)
            ]);
            const tickMat = new THREE.LineBasicMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: isMajor ? 1.0 : 0.5
            });
            const tick = new THREE.Line(tickGeom, tickMat);
            compassGroup.add(tick);

            if (isMajor && ![0, 90, 180, 270].includes(i)) {
              const labelDist = compassRadius + 0.1;
              const lx = labelDist * Math.sin(angle);
              const lz = labelDist * Math.cos(angle);

              const degGeom = new THREE.TextGeometry(i.toString(), {
                font: font,
                size: 0.045,
                height: 0.001
              });

              const degMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
              const label = new THREE.Mesh(degGeom, degMat);
              label.position.set(lx, 0, lz);
              label.lookAt(0, 0, 0);
              label.rotation.y += Math.PI;
              compassGroup.add(label);
            }
          }

          for (let i = 0; i < 360; i += 10) {
            const angle = THREE.MathUtils.degToRad(i);
            const isMajor = i % 30 === 0;
            const outer = compassRadius + 0.02;
            const inner = compassRadius - (isMajor ? 0.05 : 0.02);

            const x1 = inner * Math.sin(angle);
            const z1 = inner * Math.cos(angle);
            const x2 = outer * Math.sin(angle);
            const z2 = outer * Math.cos(angle);

            const tickGeom = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(x1, 0, z1),
              new THREE.Vector3(x2, 0, z2)
            ]);
            const tickMat = new THREE.LineBasicMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: isMajor ? 1.0 : 0.5
            });
            const tick = new THREE.Line(tickGeom, tickMat);
            compassGroup.add(tick);
          }

          scene.add(compassGroup);
        });
      }

      function addTrajectories(selectedDate) {
        const grid = gridInput.value || 'JO89tt';
        const coords = maidenheadToLatLon(grid);
        if (!coords) {
          gridInput.style.borderColor = 'red';
          gridInput.value = 'JO89tt';
          localStorage.setItem('skyObserverGrid', 'JO89tt');
          return addTrajectories(selectedDate);
        }
        const lat = coords.lat;
        const lon = coords.lon;

        const observer = new Astronomy.Observer(lat, lon, 0);

        const date = selectedDate ? new Date(selectedDate) : new Date();
        const startOfDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
        const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

        moonTrajectoryGroup.clear();
        sunTrajectoryGroup.clear();
        moonPositions = [];
        sunPositions = [];
        currentTimeIndex = 0;

        let moonSegment = [];
        let sunSegment = [];
        const moonSegments = [];
        const sunSegments = [];

        let firstMoonVisibleIndex = -1;

        for (let minutes = 0; minutes < 1440; minutes += 10) {
          const time = new Date(startOfDay.getTime() + minutes * 60 * 1000);

          if (time >= endOfDay) break;

          // Moon calculations
          const moonEq = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, false);
          const moonHor = Astronomy.Horizon(time, observer, moonEq.ra, moonEq.dec, 'normal');
          const moonElevationDeg = moonHor.altitude;
          const moonAzimuthDeg = moonHor.azimuth;

          let moonPos = null;
          if (moonElevationDeg > 0) {
            const azRad = THREE.MathUtils.degToRad(360 - moonAzimuthDeg);
            const elRad = THREE.MathUtils.degToRad(moonElevationDeg);
            const r = 1;

            const x = r * Math.cos(elRad) * Math.sin(azRad);
            const y = r * Math.sin(elRad);
            const z = r * Math.cos(elRad) * Math.cos(azRad);

            const point = new THREE.Vector3(x, y, z);
            moonSegment.push(point);
            moonPos = { time, position: point, azimuth: moonAzimuthDeg, elevation: moonElevationDeg };
            if (firstMoonVisibleIndex === -1) firstMoonVisibleIndex = minutes / 10;
          } else {
            if (moonSegment.length > 1) moonSegments.push(moonSegment);
            moonSegment = [];
          }
          moonPositions.push(moonPos);

          // Sun calculations
          const sunEq = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, false);
          const sunHor = Astronomy.Horizon(time, observer, sunEq.ra, sunEq.dec, 'normal');
          const sunElevationDeg = sunHor.altitude;
          const sunAzimuthDeg = sunHor.azimuth;

          let sunPos = null;
          if (sunElevationDeg > 0) {
            const azRad = THREE.MathUtils.degToRad(360 - sunAzimuthDeg);
            const elRad = THREE.MathUtils.degToRad(sunElevationDeg);
            const r = 1;

            const x = r * Math.cos(elRad) * Math.sin(azRad);
            const y = r * Math.sin(elRad);
            const z = r * Math.cos(elRad) * Math.cos(azRad);

            const point = new THREE.Vector3(x, y, z);
            sunSegment.push(point);
            sunPos = { time, position: point, azimuth: sunAzimuthDeg, elevation: sunElevationDeg };
          } else {
            if (sunSegment.length > 1) sunSegments.push(sunSegment);
            sunSegment = [];
          }
          sunPositions.push(sunPos);

          // Debug logging for 17:10 UTC (1030 minutes) and 19:00 UTC (1140 minutes)
          if (minutes === 1030 || minutes === 1140) {
            console.log(`At ${time.toUTCString()}:`);
            console.log(`  Moon: Azimuth = ${moonAzimuthDeg.toFixed(1)}¬∞, Elevation = ${moonElevationDeg.toFixed(1)}¬∞`);
            console.log(`  Sun: Azimuth = ${sunAzimuthDeg.toFixed(1)}¬∞, Elevation = ${sunElevationDeg.toFixed(1)}¬∞`);
          }
        }

        if (moonSegment.length > 1) moonSegments.push(moonSegment);
        if (sunSegment.length > 1) sunSegments.push(sunSegment);

        moonSegments.forEach(seg => {
          const geom = new THREE.BufferGeometry().setFromPoints(seg);
          const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
          const line = new THREE.Line(geom, mat);
          line.userData = { isMoonTrajectory: true };
          moonTrajectoryGroup.add(line);
        });

        sunSegments.forEach(seg => {
          const geom = new THREE.BufferGeometry().setFromPoints(seg);
          const mat = new THREE.LineBasicMaterial({ color: 0xffa500 });
          const line = new THREE.Line(geom, mat);
          line.userData = { isSunTrajectory: true };
          sunTrajectoryGroup.add(line);
        });

        sunTrajectoryGroup.visible = showSunCheckbox.checked;

        // Set initial time to first moon visible or noon (720 minutes = 12:00 UTC)
        currentTimeIndex = firstMoonVisibleIndex !== -1 ? firstMoonVisibleIndex : 72;
        console.log(`Initial currentTimeIndex: ${currentTimeIndex} (Time: ${moonPositions[currentTimeIndex]?.time.toUTCString() || 'N/A'})`);
        console.log(`moonPositions length: ${moonPositions.length}, sunPositions length: ${sunPositions.length}`);

        updateTimeSlider();
      }

      window.addTrajectories = addTrajectories;

      function parseCsvData(csvText, csvSource) {
        Papa.parse(csvText, {
          header: true,
          delimiter: ";",
          complete: function (results) {
            rawPoints.length = 0;
            spheres.forEach(s => scene.remove(s));
            spheres.length = 0;
            minNoise = Infinity;
            maxNoise = -Infinity;

            results.data.forEach(row => {
              if (!row.Valid || row.Valid !== "True") return;

              const az = parseFloat(row.Azimuth?.replace(",", "."));
              const el = parseFloat(row.Elevation?.replace(",", "."));
              const noise = parseFloat(row.Noise?.replace(",", "."));

              if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

              minNoise = Math.min(minNoise, noise);
              maxNoise = Math.max(maxNoise, noise);

              rawPoints.push({ az, el, noise });
            });

            rawPoints.forEach(point => {
              const azRad = THREE.MathUtils.degToRad(360 - point.az);
              const elRad = THREE.MathUtils.degToRad(point.el);
              const r = 1;

              const x = r * Math.cos(elRad) * Math.sin(azRad);
              const y = r * Math.sin(elRad);
              const z = r * Math.cos(elRad) * Math.cos(azRad);

              const geometry = new THREE.SphereGeometry(0.015, 8, 8);
              const material = new THREE.MeshBasicMaterial({ color: getColor(point.noise) });

              const sphere = new THREE.Mesh(geometry, material);
              sphere.position.set(x, y, z);

              sphere.userData = {
                azimuth: point.az,
                elevation: point.el,
                noise: point.noise
              };

              spheres.push(sphere);
              scene.add(sphere);
            });

            const boundingBox = new THREE.Box3();
            spheres.forEach(s => boundingBox.expandByPoint(s.position));

            const center = new THREE.Vector3();
            boundingBox.getCenter(center);

            const size = new THREE.Vector3();
            boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);

            let avgPosition = new THREE.Vector3();
            spheres.forEach(s => avgPosition.add(s.position));
            avgPosition.divideScalar(spheres.length);

            const directionToData = avgPosition.clone().normalize();
            const distance = maxDim * 2;
            const cameraPos = directionToData.clone().multiplyScalar(distance);

            camera.position.copy(cameraPos);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
            addAzimuthCompass();

            if (csvSource === 'demo') {
              demoStatus.textContent = 'Demo loaded!';
              demoStatus.style.display = 'block';
            } else if (csvSource === 'stored') {
              demoStatus.textContent = 'Stored CSV loaded';
              demoStatus.style.display = 'block';
            } else {
              demoStatus.style.display = 'none';
            }
          }
        });
      }

      // Initialize grid locator from localStorage
      const storedGrid = localStorage.getItem('skyObserverGrid');
      if (storedGrid && isValidGrid(storedGrid)) {
        gridInput.value = storedGrid;
        gridInput.style.borderColor = '#fff';
      } else {
        gridInput.value = 'JO89tt';
        localStorage.setItem('skyObserverGrid', 'JO89tt');
      }

      // Initialize CSV from localStorage or demo
      const storedCsv = localStorage.getItem('skyObserverCsv');
      if (storedCsv) {
        parseCsvData(storedCsv, 'stored');
      } else {
        fetch('2025-05-29_20.44.04.csv')
          .then(response => response.text())
          .then(csv => parseCsvData(csv, 'demo'))
          .catch(error => {
            console.error('Error loading demo CSV:', error);
            addAzimuthCompass();
            addTrajectories();
          });
      }

      document.getElementById('csvUpload').addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
          const csvText = event.target.result;
          localStorage.setItem('skyObserverCsv', csvText);
          parseCsvData(csvText, 'uploaded');
        };
        reader.readAsText(file);
      });

      window.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
            const moonData = moonPositions[currentTimeIndex];
            infoBox.innerHTML = `
              <b>Moon Position</b><br>
              <b>Azimuth:</b> ${moonData.azimuth.toFixed(1)}¬∞<br>
              <b>Elevation:</b> ${moonData.elevation.toFixed(1)}¬∞<br>
              <b>Time:</b> ${moonTimeDisplay.textContent}
            `;
            infoBox.style.display = 'block';
            return;
          }

          if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
            const sunData = sunPositions[currentTimeIndex];
            infoBox.innerHTML = `
              <b>Sun Position</b><br>
              <b>Azimuth:</b> ${sunData.azimuth.toFixed(1)}¬∞<br>
              <b>Elevation:</b> ${sunData.elevation.toFixed(1)}¬∞<br>
              <b>Time:</b> ${moonTimeDisplay.textContent}
            `;
            infoBox.style.display = 'block';
            return;
          }

          const sphere = intersects[0].object;
          const { azimuth, elevation, noise } = sphere.userData;

          infoBox.innerHTML = `
            <b>Azimuth:</b> ${azimuth.toFixed(1)}¬∞<br>
            <b>Elevation:</b> ${elevation.toFixed(1)}¬∞<br>
            <b>Noise:</b> ${noise.toFixed(2)} dB
          `;
          infoBox.style.display = 'block';
        } else {
          infoBox.style.display = 'none';
        }
      });

      window.addEventListener('touchend', (event) => {
        const touch = event.changedTouches[0];
        if (!touch) return;

        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;

          if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
            const moonData = moonPositions[currentTimeIndex];
            infoBox.innerHTML = `
              <b>Moon Data</b><br>
              Time: ${moonData.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false })} UTC<br>
              Azimuth: ${moonData.azimuth.toFixed(2)}¬∞<br>
              Elevation: ${moonData.elevation.toFixed(2)}¬∞
            `;
            infoBox.style.display = 'block';
          } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
            const sunData = sunPositions[currentTimeIndex];
            infoBox.innerHTML = `
              <b>Sun Data</b><br>
              Time: ${sunData.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false })} UTC<br>
              Azimuth: ${sunData.azimuth.toFixed(2)}¬∞<br>
              Elevation: ${sunData.elevation.toFixed(2)}¬∞
            `;
            infoBox.style.display = 'block';
          } else if (clickedObject.userData.noise !== undefined) {
            const { azimuth, elevation, noise } = clickedObject.userData;
            infoBox.innerHTML = `
              <b>Measurement</b><br>
              Azimuth: ${azimuth.toFixed(2)}¬∞<br>
              Elevation: ${elevation.toFixed(2)}¬∞<br>
              Noise: ${noise.toFixed(2)} dB
            `;
            infoBox.style.display = 'block';
          }
        } else {
          infoBox.style.display = 'none';
        }
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      const today = new Date();
      const year = today.getUTCFullYear();
      const month = String(today.getUTCMonth() + 1).padStart(2, '0');
      const day = String(today.getUTCDate()).padStart(2, '0');
      datePicker.value = `${year}-${month}-${day}`;
      addTrajectories();
    </script>
</body>
</html>
