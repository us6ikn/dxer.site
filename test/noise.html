<!DOCTYPE html>
<html>
<head>
  <title>Sky Noise Dome</title>
  <style> body { margin: 0; } canvas { display: block; } </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    let minNoise = Infinity, maxNoise = -Infinity;

    function getColor(noise) {
      let norm = (noise - minNoise) / (maxNoise - minNoise);
      let color = new THREE.Color();
      color.setHSL(0.7 - norm * 0.7, 1.0, 0.5);
      return color;
    }

    fetch('2025-05-29_20.44.04.csv')
      .then(response => response.text())
      .then(csv => {
        Papa.parse(csv, {
          header: true,
          delimiter: ";",
          complete: function(results) {
            const points = [];

            results.data.forEach(row => {
              if (!row.Valid || row.Valid !== "True") return;

              let az = parseFloat(row.Azimuth.replace(",", "."));
              let el = parseFloat(row.Elevation.replace(",", "."));
              let noise = parseFloat(row.Noise.replace(",", "."));
              if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

              minNoise = Math.min(minNoise, noise);
              maxNoise = Math.max(maxNoise, noise);

              let azRad = THREE.MathUtils.degToRad(az);
              let elRad = THREE.MathUtils.degToRad(el);

              let r = 1.0;
              let x = r * Math.cos(elRad) * Math.sin(azRad);
              let y = r * Math.sin(elRad);
              let z = r * Math.cos(elRad) * Math.cos(azRad);

              points.push({ x, y, z, noise });
            });

            points.forEach(p => {
              let geom = new THREE.SphereGeometry(0.015);
              let mat = new THREE.MeshBasicMaterial({ color: getColor(p.noise) });
              let sphere = new THREE.Mesh(geom, mat);
              sphere.position.set(p.x, p.y, p.z);
              scene.add(sphere);
            });
          }
        });
      });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
