<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <title>Sky Observer</title>
      <style>
          #colorBarContainer {
            position: absolute;
            bottom: 120px; /* Reduced to ensure the color bar fits on desktop */
            right: 10px;
            z-index: 30;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            color: white;
            width: 40px;
            height: auto;
            top: auto;
            left: auto;
          }

          #colorBar {
            width: 20px !important;
            height: 200px !important;
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 30;
          }

          #maxNoiseLabel {
            position: absolute;
            top: -20px; /* Adjusted to ensure no overlap with color bar */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 100%;
            z-index: 31;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 2px;
            line-height: 1.2;
          }

          #minNoiseLabel {
            position: absolute;
            bottom: -20px; /* Adjusted to ensure no overlap with color bar */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 100%;
            z-index: 31;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 2px;
            line-height: 1.2;
          }

          @media (max-width: 600px), (orientation: portrait) {
            #colorBarContainer {
              bottom: 80px; /* Adjusted for mobile to avoid overlap with other controls */
              right: 10px;
              font-size: 10px;
              width: 40px;
              height: auto;
              top: auto;
              left: auto;
            }
            #colorBar {
              width: 20px !important;
              height: 120px !important;
            }
            #maxNoiseLabel {
              top: -18px; /* Slightly adjusted for mobile */
              font-size: 10px;
              padding: 1px 3px;
            }
            #minNoiseLabel {
              bottom: -18px; /* Slightly adjusted for mobile */
              font-size: 10px;
              padding: 1px 3px;
            }
          }

          @media (max-height: 500px) {
            #colorBarContainer {
              bottom: 60px; /* Further reduced for very short screens */
              right: 10px;
              width: 40px;
              height: auto;
              top: auto;
              left: auto;
            }
            #colorBar {
              height: 100px !important;
            }
            #maxNoiseLabel {
              top: -16px;
              font-size: 10px;
              padding: 1px 3px;
            }
            #minNoiseLabel {
              bottom: -16px;
              font-size: 10px;
              padding: 1px 3px;
            }
          }
      </style>
    </head>
    <body>
        <div style="position: absolute; top: 8px; left: 8px; z-index: 30; font-family: 'Segoe UI', sans-serif;">
          <div style="display: flex; flex-direction: row; align-items: flex-end; gap: 8px;">
            <div style="display: flex; flex-direction: column; align-items: flex-end; line-height: 1;">
              <div style="font-size: 10px; color: #aaa; padding-right: 2px;">
                by SA5IKN
              </div>
              <div style="font-size: 16px; color: white; font-weight: 600; background: rgba(0, 0, 0, 0.6); padding: 2px 4px; border-radius: 2px;">
                Sky Observer
              </div>
            </div>
            <div style="display: flex; flex-direction: row; gap: 4px;">
              <a href="https://dxer.site" target="_blank" title="Go to homepage"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                üè†
              </a>
              <a href="https://dxer.site/eme-observer/" target="_blank" title="Go to EME Observer"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                üó∫Ô∏è
              </a>
              <a href="https://dxer.site/sky-observer-faq.html" target="_blank" title="Open FAQ"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                ‚ùì
              </a>
            </div>
          </div>
        </div>

        <div id="controlPanel" style="
          position: absolute;
          top: 36px;
          left: 8px;
          z-index: 20;
          background: rgba(0,0,0,0.6);
          padding: 6px 8px;
          border-radius: 8px;
          display: flex;
          flex-direction: column;
          gap: 6px;
          font-family: 'Segoe UI', sans-serif;
          font-size: 12px;
          color: white;
          max-width: 160px;
        ">
          <div style="display: flex; align-items: center; gap: 4px;">
            <label for="gridInput">My locator:</label>
            <input type="text" id="gridInput" maxlength="6" placeholder="e.g. JO89tt"
                   style="width: 60px; font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none;">
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <label for="dxGridInput">DX locator:</label>
            <input type="text" id="dxGridInput" maxlength="6" placeholder="e.g. FN20as"
                   style="width: 60px; font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none;">
          </div>
          <div style="display: flex; flex-direction: column; gap: 2px;">
            <label for="csvUpload">
              CSV <span style="font-size: 9px; color: #ccc;">(e.g. from SkyScanner)</span>:
            </label>
            <input type="file" id="csvUpload" accept=".csv"
                   style="font-size: 10px; padding: 2px 0px; color: white;">
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <button id="prevDate">&lt;</button>
            <input type="date" id="datePicker"
                   style="font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none; width: 100px;">
            <button id="nextDate">&gt;</button>
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <input type="checkbox" id="showSun" style="width: 14px; height: 14px;">
            <label for="showSun">Show sun</label>
          </div>
          <div id="demoStatus" style="color: red; font-weight: bold; margin-top: 10px;">
            Demo loaded!
          </div>
        </div>

        <div id="moonTimeControls" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 10px;">
          <span id="moonTimeDisplay" style="color: white; font-family: 'Courier New', monospace; font-size: 18px; padding: 8px 12px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.2);">
            --:-- UTC
          </span>
          <input type="range" id="timeSlider" min="0" max="0" value="0" aria-label="Select time for moon and sun position" role="slider" tabindex="0" style="width: 80vw; max-width: 300px; accent-color: #fff; cursor: pointer;">
        </div>

        <div id="colorBarContainer" style="
          position: absolute;
          bottom: 180px;
          right: 10px;
          z-index: 30;
          display: flex;
          flex-direction: column;
          align-items: center;
          font-family: 'Segoe UI', sans-serif;
          font-size: 12px;
          color: white;
          width: 40px;
          height: auto;
          top: auto;
          left: auto;
        ">
          <div id="maxNoiseLabel" style="position: absolute; top: -18px; left: 50%; transform: translateX(-50%); text-align: center; width: 100%; z-index: 31; background: rgba(0,0,0,0.6); padding: 2px 4px; border-radius: 2px; line-height: 1.2;">-- dB</div>
          <canvas id="colorBar" width="20" height="200" style="border: 1px solid rgba(255,255,255,0.3); z-index: 30;"></canvas>
          <div id="minNoiseLabel" style="position: absolute; bottom: -18px; left: 50%; transform: translateX(-50%); text-align: center; width: 100%; z-index: 31; background: rgba(0,0,0,0.6); padding: 2px 4px; border-radius: 2px; line-height: 1.2;">-- dB</div>
        </div>

        <script src="a.ob.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/FontLoader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TextGeometry.js"></script>

        <script>
          const scene = new THREE.Scene();
          const moonTrajectoryGroup = new THREE.Group();
          const sunTrajectoryGroup = new THREE.Group();
          
          let moonPositions = [];
          let dxMoonPositions = [];
          let sunPositions = [];
          let commonMoonWindow = [];
          let currentTimeIndex = 0;
          let moonMarker = null;
          let sunMarker = null;
          let azStep = 5;
          let elStep = 5;
          
          const moonTimeDisplay = document.getElementById('moonTimeDisplay');
          const timeSlider = document.getElementById('timeSlider');
          const datePicker = document.getElementById('datePicker');
          const prevDateBtn = document.getElementById('prevDate');
          const nextDateBtn = document.getElementById('nextDate');
          const gridInput = document.getElementById('gridInput');
          const dxGridInput = document.getElementById('dxGridInput');
          const showSunCheckbox = document.getElementById('showSun');
          const demoStatus = document.getElementById('demoStatus');
          const colorBarCanvas = document.getElementById('colorBar');
          const colorBarContext = colorBarCanvas.getContext('2d');
          const minNoiseLabel = document.getElementById('minNoiseLabel');
          const maxNoiseLabel = document.getElementById('maxNoiseLabel');
          const colorBarContainer = document.getElementById('colorBarContainer');

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);

          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          const defaultDistance = 2;
          const defaultAzRad = THREE.MathUtils.degToRad(180);
          const defaultElRad = THREE.MathUtils.degToRad(30);
          camera.position.set(
            defaultDistance * Math.cos(defaultElRad) * Math.sin(defaultAzRad),
            defaultDistance * Math.sin(defaultElRad),
            defaultDistance * Math.cos(defaultElRad) * Math.cos(defaultAzRad)
          );
          camera.lookAt(0, 0, 0);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.target.set(0, 0, 0);
          controls.rotateSpeed = 0.5;
          controls.zoomSpeed = 0.5;
          controls.panSpeed = 0.5;
          controls.update();

          function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            drawColorBar();
          }

          window.addEventListener('resize', onWindowResize);
          window.addEventListener('orientationchange', onWindowResize);

          const raycaster = new THREE.Raycaster();
          const mouse = new THREE.Vector2();
          let spheres = [];
          let minNoise = Infinity, maxNoise = -Infinity;
          const rawPoints = [];

          scene.add(moonTrajectoryGroup);
          scene.add(sunTrajectoryGroup);

          function getColor(noise) {
            const range = maxNoise - minNoise;
            const norm = range === 0 ? 0.5 : (noise - minNoise) / range;
            return new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
          }

          function calculateStepSizes() {
            if (!rawPoints.length) {
              return { azStep: 5, elStep: 5 };
            }

            const azValues = [...new Set(rawPoints.map(p => p.az))].sort((a, b) => a - b);
            const elValues = [...new Set(rawPoints.map(p => p.el))].sort((a, b) => a - b);

            const azDiffs = azValues.slice(1).map((v, i) => v - azValues[i]).filter(d => d > 0);
            const elDiffs = elValues.slice(1).map((v, i) => v - elValues[i]).filter(d => d > 0);

            const azStep = azDiffs.length ? Math.min(...azDiffs) : 5;
            const elStep = elDiffs.length ? Math.min(...elDiffs) : 5;

            return { azStep, elStep };
          }

          function interpolateNoiseAtPosition(azimuth, elevation) {
            if (!rawPoints.length) {
              return null;
            }

            const maxDistance = Math.max(azStep, elStep) * 1.0;
            const maxClosestDistance = 6;
            const minPoints = 1;

            const pointsWithDistance = rawPoints.map(point => {
              const dAz = Math.abs(point.az - azimuth);
              const dEl = Math.abs(point.el - elevation);
              const distance = Math.sqrt(dAz * dAz + dEl * dEl);
              return { ...point, distance };
            });

            const nearbyPoints = pointsWithDistance.filter(p => p.distance <= maxDistance);

            if (nearbyPoints.length >= minPoints) {
              if (nearbyPoints.length === 1) {
                return { noise: nearbyPoints[0].noise };
              }

              let totalWeight = 0;
              let weightedNoise = 0;
              nearbyPoints.forEach(point => {
                const weight = 1 / (point.distance * point.distance + 1e-6);
                weightedNoise += weight * point.noise;
                totalWeight += weight;
              });

              if (totalWeight === 0) {
                return null;
              }

              const interpolatedNoise = weightedNoise / totalWeight;
              return { noise: Math.max(minNoise, Math.min(maxNoise, interpolatedNoise)) };
            }

            const closestPoint = pointsWithDistance.reduce((min, p) => p.distance < min.distance ? p : min, pointsWithDistance[0]);
            if (closestPoint.distance <= maxClosestDistance) {
              return { noise: closestPoint.noise };
            }
            return null;
          }

          function drawColorBar() {
            if (minNoise === Infinity || maxNoise === -Infinity) {
              colorBarContainer.style.display = 'none';
              return;
            }
            colorBarContainer.style.display = 'flex';

            minNoiseLabel.textContent = `${minNoise.toFixed(2)} dB`;
            maxNoiseLabel.textContent = `${maxNoise.toFixed(2)} dB`;

            const dpr = window.devicePixelRatio || 1;
            const computedStyle = getComputedStyle(colorBarCanvas);
            const canvasWidth = parseFloat(computedStyle.width);
            const canvasHeight = parseFloat(computedStyle.height);
            colorBarCanvas.width = canvasWidth * dpr;
            colorBarCanvas.height = canvasHeight * dpr;
            colorBarContext.scale(dpr, dpr);

            colorBarContext.save();
            colorBarContext.setTransform(1, 0, 0, 1, 0, 0);
            colorBarContext.clearRect(0, 0, colorBarCanvas.width, colorBarCanvas.height);

            const gradient = colorBarContext.createLinearGradient(0, colorBarCanvas.height, 0, 0);
            for (let i = 0; i <= 1; i += 0.1) {
              const norm = i;
              const color = new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
              gradient.addColorStop(i, `#${color.getHexString()}`);
            }
            colorBarContext.fillStyle = gradient;
            colorBarContext.fillRect(0, 0, colorBarCanvas.width, colorBarCanvas.height);

            if (moonPositions.length && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0 && rawPoints.length) {
              const moonData = moonPositions[currentTimeIndex];
              const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
              if (noisePoint) {
                const noise = noisePoint.noise;
                const norm = (maxNoise - minNoise) === 0 ? 0.5 : (noise - minNoise) / (maxNoise - minNoise);
                let y = colorBarCanvas.height * (1 - norm);
                y = Math.max(2 * dpr, Math.min(colorBarCanvas.height - 2 * dpr, y));

                const isMobile = window.innerWidth <= 600 || window.matchMedia("(orientation: portrait)").matches;
                const triangleSize = isMobile ? 12 : 18;
                const textOffset = isMobile ? 14 : 22;
                const fontSize = isMobile ? 12 : 14;

                colorBarContext.strokeStyle = '#000000';
                colorBarContext.lineWidth = 2 * dpr;
                colorBarContext.beginPath();
                colorBarContext.moveTo(colorBarCanvas.width, y);
                colorBarContext.lineTo(colorBarCanvas.width + triangleSize * dpr, y - (triangleSize / 2) * dpr);
                colorBarContext.lineTo(colorBarCanvas.width + triangleSize * dpr, y + (triangleSize / 2) * dpr);
                colorBarContext.closePath();
                colorBarContext.stroke();

                colorBarContext.fillStyle = '#ffffff';
                colorBarContext.fill();

                colorBarContext.fillStyle = '#ffffff';
                colorBarContext.strokeStyle = '#000000';
                colorBarContext.lineWidth = 1 * dpr;
                colorBarContext.font = `bold ${fontSize * dpr}px Segoe UI`;
                colorBarContext.textAlign = 'left';
                colorBarContext.textBaseline = 'middle';
                colorBarContext.strokeText(`${noise.toFixed(2)} dB`, colorBarCanvas.width + textOffset * dpr, y);
                colorBarContext.fillText(`${noise.toFixed(2)} dB`, colorBarCanvas.width + textOffset * dpr, y);

                colorBarContext.fillStyle = '#ff0000';
                colorBarContext.fillRect(0, y - 2 * dpr, 5 * dpr, 4 * dpr);
              }
            }

            colorBarContext.restore();
          }

          function updateMoonMarker() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            const moonData = moonPositions[currentTimeIndex];
            if (moonData.elevation <= 0) {
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            if (!moonMarker) {
              const geom = new THREE.SphereGeometry(0.03);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
              moonMarker = new THREE.Mesh(geom, mat);
              scene.add(moonMarker);
            }

            moonMarker.visible = true;
            moonMarker.position.copy(moonData.position);
            return true;
          }

          function updateSunMarker() {
            if (!sunPositions.length || !showSunCheckbox.checked || !sunPositions[currentTimeIndex]) {
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            const sunData = sunPositions[currentTimeIndex];
            if (sunData.elevation <= 0) {
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            if (!sunMarker) {
              const geom = new THREE.SphereGeometry(0.02);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
              sunMarker = new THREE.Mesh(geom, mat);
              scene.add(sunMarker);
            }

            sunMarker.visible = true;
            sunMarker.position.copy(sunData.position);
            return true;
          }

          function updateInfoBox() {
            let html = '';

            if (moonPositions.length && moonPositions[currentTimeIndex]) {
              const moonData = moonPositions[currentTimeIndex];
              if (moonData.elevation > 0) {
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A';
                html += `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
              } else {
                html += `
                  <b>Moon</b><br>
                  Moon below horizon
                `;
              }
            } else {
              html += `
                <b>Moon</b><br>
                Moon below horizon
              `;
            }

            if (dxMoonPositions.length && dxMoonPositions[currentTimeIndex]) {
              const dxMoonData = dxMoonPositions[currentTimeIndex];
              html += `<br>`;
              if (dxMoonData.elevation > 0) {
                html += `
                  <b>DX Moon</b><br>
                  Az: ${dxMoonData.azimuth.toFixed(1)}¬∞ El: ${dxMoonData.elevation.toFixed(1)}¬∞
                `;
              } else {
                html += `
                  <b>DX Moon</b><br>
                  DX Moon below horizon
                `;
              }
            }

            if (showSunCheckbox.checked && sunPositions.length && sunPositions[currentTimeIndex]) {
              const sunData = sunPositions[currentTimeIndex];
              html += `<br>`;
              if (sunData.elevation > 0) {
                html += `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
              } else {
                html += `
                  <b>Sun</b><br>
                  Sun below horizon
                `;
              }
            } else if (showSunCheckbox.checked) {
              html += `
                <br><b>Sun</b><br>
                Sun below horizon
              `;
            }

            infoBox.innerHTML = html;
            infoBox.style.display = 'block';
          }

          function updateTimeDisplay() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              moonTimeDisplay.textContent = '--:-- UTC';
              updateInfoBox();
              drawColorBar();
              return;
            }

            const time = moonPositions[currentTimeIndex].time;
            const moonVisible = moonPositions[currentTimeIndex].elevation > 0;
            const sunVisible = showSunCheckbox.checked && sunPositions[currentTimeIndex]?.elevation > 0;

            if (moonVisible || sunVisible) {
              const hours = String(time.getUTCHours()).padStart(2, '0');
              const minutes = String(time.getUTCMinutes()).padStart(2, '0');
              moonTimeDisplay.textContent = `${hours}:${minutes} UTC`;
            } else {
              moonTimeDisplay.textContent = '--:-- UTC';
            }
            updateInfoBox();
            drawColorBar();
          }

          function updateTimeSlider() {
            timeSlider.min = 0;
            timeSlider.max = moonPositions.length - 1 || 0;
            timeSlider.value = currentTimeIndex;
            timeSlider.disabled = moonPositions.length === 0;
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeTime(index) {
            if (!moonPositions.length) return;
            currentTimeIndex = Math.max(0, Math.min(index, moonPositions.length - 1));
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeDate(days) {
            let currentDate = datePicker.value ? new Date(datePicker.value) : new Date();
            currentDate.setUTCDate(currentDate.getUTCDate() + days);
            const year = currentDate.getUTCFullYear();
            const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(currentDate.getUTCDate()).padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            addTrajectories(datePicker.value);
          }

          timeSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            changeTime(parseInt(e.target.value));
          });

          timeSlider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            controls.enabled = false;
          });

          timeSlider.addEventListener('touchend', (e) => {
            e.stopPropagation();
            controls.enabled = true;
          });

          timeSlider.addEventListener('touchcancel', (e) => {
            e.stopPropagation();
            controls.enabled = true;
          });

          datePicker.addEventListener('change', (e) => {
            const selectedDate = e.target.value;
            if (selectedDate) {
              addTrajectories(selectedDate);
            }
          });

          prevDateBtn.addEventListener('click', () => changeDate(-1));
          nextDateBtn.addEventListener('click', () => changeDate(1));

          showSunCheckbox.addEventListener('change', () => {
            sunTrajectoryGroup.visible = showSunCheckbox.checked;
            updateSunMarker();
            updateTimeDisplay();
          });

          function isValidGrid(locator) {
            if (!locator || locator.length < 4 || locator.length > 6) return false;
            locator = locator.toUpperCase();
            const regex = /^[A-R]{2}[0-9]{2}([A-X]{2})?$/;
            return regex.test(locator);
          }

          gridInput.addEventListener('input', () => {
            const grid = gridInput.value;
            if (isValidGrid(grid)) {
              gridInput.style.borderColor = '#fff';
              localStorage.setItem('skyObserverGrid', grid);
              const dateVal = datePicker.value || new Date().toISOString().split('T')[0];
              addTrajectories(dateVal);
            } else {
              gridInput.style.borderColor = 'red';
            }
          });

          dxGridInput.addEventListener('input', () => {
            const dxGrid = dxGridInput.value;
            if (dxGrid && isValidGrid(dxGrid)) {
              dxGridInput.style.borderColor = '#fff';
            } else if (dxGrid) {
              dxGridInput.style.borderColor = 'red';
            } else {
              dxGridInput.style.borderColor = '#fff';
            }
            const dateVal = datePicker.value || new Date().toISOString().split('T')[0];
            addTrajectories(dateVal);
          });

          function maidenheadToLatLon(locator) {
            if (!locator || locator.length < 4) return null;
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            let lon = (locator.charCodeAt(0) - A) * 20 - 180;
            let lat = (locator.charCodeAt(1) - A) * 10 - 90;
            lon += parseInt(locator[2]) * 2;
            lat += parseInt(locator[3]) * 1;
            if (locator.length >= 6) {
              lon += (locator.charCodeAt(4) - A) * 5 / 60;
              lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
            }
            lon += 2.5 / 60;
            lat += 1.25 / 60;
            return { lat, lon };
          }

          const infoBox = document.createElement('div');
          infoBox.id = 'infoBox';
          document.body.appendChild(infoBox);

          function addAzimuthCompass() {
            const compassRadius = 1.05;
            const labelDistance = 1.2;
            const compassGroup = new THREE.Group();

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
              const directions = [
                { label: 'N', az: 0, color: 0xff0000 },
                { label: 'E', az: 90, color: 0xffffff },
                { label: 'S', az: 180, color: 0xffffff },
                { label: 'W', az: 270, color: 0xffffff }
              ];

              directions.forEach(dir => {
                const azRad = THREE.MathUtils.degToRad(360 - dir.az);
                const x = labelDistance * Math.sin(azRad);
                const z = labelDistance * Math.cos(azRad);
                const y = 0;

                const textGeom = new THREE.TextGeometry(dir.label, {
                  font: font,
                  size: 0.1,
                  height: 0.001
                });
                const textMat = new THREE.MeshBasicMaterial({ color: dir.color });
                const text = new THREE.Mesh(textGeom, textMat);
                text.position.set(x, y, z);
                text.lookAt(0, 0, 0);
                compassGroup.add(text);
              });

              const ringGeom = new THREE.RingGeometry(compassRadius - 0.002, compassRadius + 0.002, 256);
              const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
              });
              const ring = new THREE.Mesh(ringGeom, ringMat);
              ring.rotation.x = -Math.PI / 2;
              ring.position.y = 0;
              compassGroup.add(ring);

              for (let i = 0; i < 360; i += 10) {
                const angle = THREE.MathUtils.degToRad(360 - i);
                const isMajor = i % 30 === 0;
                const outer = compassRadius + 0.02;
                const inner = compassRadius - (isMajor ? 0.05 : 0.02);

                const x1 = inner * Math.cos(angle);
                const z1 = inner * Math.sin(angle);
                const x2 = outer * Math.cos(angle);
                const z2 = outer * Math.sin(angle);

                const tickGeom = new THREE.BufferGeometry().setFromPoints([
                  new THREE.Vector3(x1, 0, z1),
                  new THREE.Vector3(x2, 0, z2)
                ]);
                const tickMat = new THREE.LineBasicMaterial({
                  color: 0xffffff,
                  transparent: true,
                  opacity: isMajor ? 1.0 : 0.5
                });
                const tick = new THREE.Line(tickGeom, tickMat);
                compassGroup.add(tick);

                if (isMajor && ![0, 90, 180, 270].includes(i)) {
                  const labelDist = compassRadius + 0.1;
                  const lx = labelDist * Math.sin(angle);
                  const lz = labelDist * Math.cos(angle);

                  const degGeom = new THREE.TextGeometry(i.toString(), {
                    font: font,
                    size: 0.045,
                    height: 0.001
                  });
                  const degMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                  const label = new THREE.Mesh(degGeom, degMat);
                  label.position.set(lx, 0, lz);
                  label.lookAt(0, 0, 0);
                  label.rotation.y += Math.PI;
                  compassGroup.add(label);
                }
              }

              scene.add(compassGroup);
            }, undefined, (error) => {});
          }

          function addTrajectories(selectedDate) {
            const grid = gridInput.value || 'JO89tt';
            const dxGrid = dxGridInput.value;
            const coords = maidenheadToLatLon(grid);
            let dxCoords = null;
            if (dxGrid && isValidGrid(dxGrid)) {
              dxCoords = maidenheadToLatLon(dxGrid);
              dxGridInput.style.borderColor = '#fff';
            } else if (dxGrid) {
              dxGridInput.style.borderColor = 'red';
            } else {
              dxGridInput.style.borderColor = '#fff';
            }

            if (!coords) {
              gridInput.style.borderColor = 'red';
              gridInput.value = 'JO89tt';
              localStorage.setItem('skyObserverGrid', 'JO89tt');
              return addTrajectories(selectedDate);
            }

            const lat = coords.lat;
            const lon = coords.lon;
            const observer = new Astronomy.Observer(lat, lon, 0);
            let dxObserver = null;
            if (dxCoords) {
              dxObserver = new Astronomy.Observer(dxCoords.lat, dxCoords.lon, 0);
            }

            const date = selectedDate ? new Date(selectedDate) : new Date();
            const startOfDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

            moonTrajectoryGroup.clear();
            sunTrajectoryGroup.clear();
            if (moonMarker) scene.remove(moonMarker);
            if (sunMarker) scene.remove(sunMarker);
            moonMarker = null;
            sunMarker = null;
            moonPositions = [];
            dxMoonPositions = [];
            sunPositions = [];
            commonMoonWindow = [];
            currentTimeIndex = 0;

            let moonSegment = [];
            let sunSegment = [];
            let commonMoonSegment = [];
            const moonSegments = [];
            const sunSegments = [];
            const commonMoonSegments = [];

            let firstMoonVisibleIndex = -1;
            let firstSunVisibleIndex = -1;

            for (let minutes = 0; minutes < 1440; minutes += 10) {
              const time = new Date(startOfDay.getTime() + minutes * 60 * 1000);
              if (time >= endOfDay) break;

              const moonEq = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, false);
              const moonHor = Astronomy.Horizon(time, observer, moonEq.ra, moonEq.dec, 'normal');
              const moonElevationDeg = moonHor.altitude;
              const moonAzimuthDeg = moonHor.azimuth;

              const azRadMoon = THREE.MathUtils.degToRad(360 - moonAzimuthDeg);
              const elRadMoon = THREE.MathUtils.degToRad(Math.max(moonElevationDeg, 0));
              const r = 1;
              const xMoon = r * Math.cos(elRadMoon) * Math.sin(azRadMoon);
              const yMoon = r * Math.sin(elRadMoon);
              const zMoon = r * Math.cos(elRadMoon) * Math.cos(azRadMoon);
              const moonPoint = new THREE.Vector3(xMoon, yMoon, zMoon);

              if (moonElevationDeg > 0) {
                moonSegment.push(moonPoint);
                if (firstMoonVisibleIndex === -1) firstMoonVisibleIndex = minutes / 10;
              } else {
                if (moonSegment.length > 1) moonSegments.push(moonSegment);
                moonSegment = [];
              }
              moonPositions.push({ time, position: moonPoint, azimuth: moonAzimuthDeg, elevation: moonElevationDeg });

              let isCommon = false;
              if (dxObserver) {
                const dxMoonEq = Astronomy.Equator(Astronomy.Body.Moon, time, dxObserver, true, false);
                const dxMoonHor = Astronomy.Horizon(time, dxObserver, dxMoonEq.ra, dxMoonEq.dec, 'normal');
                const dxMoonElevationDeg = dxMoonHor.altitude;
                const dxMoonAzimuthDeg = dxMoonHor.azimuth;

                if (dxMoonElevationDeg > 0 && moonElevationDeg > 0) {
                  commonMoonSegment.push(moonPoint);
                  isCommon = true;
                }
                dxMoonPositions.push({ time, azimuth: dxMoonAzimuthDeg, elevation: dxMoonElevationDeg });
              }

              if (isCommon) {
                commonMoonWindow.push({ time, index: minutes / 10 });
              } else if (commonMoonSegment.length > 1) {
                commonMoonSegments.push(commonMoonSegment);
                commonMoonSegment = [];
              }

              const sunEq = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, false);
              const sunHor = Astronomy.Horizon(time, observer, sunEq.ra, sunEq.dec, 'normal');
              const sunElevationDeg = sunHor.altitude;
              const sunAzimuthDeg = sunHor.azimuth;

              const azRadSun = THREE.MathUtils.degToRad(360 - sunAzimuthDeg);
              const elRadSun = THREE.MathUtils.degToRad(Math.max(sunElevationDeg, 0));
              const xSun = r * Math.cos(elRadSun) * Math.sin(azRadSun);
              const ySun = r * Math.sin(elRadSun);
              const zSun = r * Math.cos(elRadSun) * Math.cos(azRadSun);
              const sunPoint = new THREE.Vector3(xSun, ySun, zSun);

              if (sunElevationDeg > 0) {
                sunSegment.push(sunPoint);
                if (firstSunVisibleIndex === -1) firstSunVisibleIndex = minutes / 10;
              } else {
                if (sunSegment.length > 1) sunSegments.push(sunSegment);
                sunSegment = [];
              }
              sunPositions.push({ time, position: sunPoint, azimuth: sunAzimuthDeg, elevation: sunElevationDeg });
            }

            if (moonSegment.length > 1) moonSegments.push(moonSegment);
            if (sunSegment.length > 1) sunSegments.push(sunSegment);
            if (commonMoonSegment.length > 1) commonMoonSegments.push(commonMoonSegment);

            moonSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isMoonTrajectory: true };
              moonTrajectoryGroup.add(line);
            });

            commonMoonSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 1 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isCommonMoonTrajectory: true };
              moonTrajectoryGroup.add(line);
            });

            sunSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffa500 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isSunTrajectory: true };
              sunTrajectoryGroup.add(line);
            });

            sunTrajectoryGroup.visible = showSunCheckbox.checked;

            if (firstMoonVisibleIndex !== -1) {
              currentTimeIndex = firstMoonVisibleIndex;
            } else if (showSunCheckbox.checked && firstSunVisibleIndex !== -1) {
              currentTimeIndex = firstSunVisibleIndex;
            } else {
              currentTimeIndex = 72;
            }
            updateTimeSlider();
          }

          window.addTrajectories = addTrajectories;

          function parseCsvData(csvText, csvSource) {
            Papa.parse(csvText, {
              header: true,
              delimiter: ";",
              skipEmptyLines: true,
              complete: function (results) {
                rawPoints.length = 0;
                spheres.forEach(s => scene.remove(s));
                spheres.length = 0;
                minNoise = Infinity;
                maxNoise = -Infinity;

                const headers = results.meta.fields;
                const requiredColumns = ['Azimuth', 'Elevation', 'Noise'];
                const hasRequiredColumns = requiredColumns.every(col => headers.includes(col));
                if (!hasRequiredColumns) {
                  demoStatus.textContent = 'Error: CSV must contain Azimuth, Elevation, and Noise columns';
                  demoStatus.style.color = 'red';
                  demoStatus.style.display = 'block';
                  return;
                }

                results.data.forEach(row => {
                  if (row.Valid !== undefined && row.Valid !== "True") return;

                  const az = parseFloat(row.Azimuth?.replace(",", "."));
                  const el = parseFloat(row.Elevation?.replace(",", "."));
                  const noise = parseFloat(row.Noise?.replace(",", "."));

                  if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

                  minNoise = Math.min(minNoise, noise);
                  maxNoise = Math.max(maxNoise, noise);

                  rawPoints.push({ az, el, noise });
                });

                if (rawPoints.length === 0) {
                  demoStatus.textContent = 'Error: No valid data points in CSV';
                  demoStatus.style.color = 'red';
                  demoStatus.style.display = 'block';
                  return;
                }

                const steps = calculateStepSizes();
                azStep = steps.azStep;
                elStep = steps.elStep;

                rawPoints.forEach(point => {
                  const azRad = THREE.MathUtils.degToRad(360 - point.az);
                  const elRad = THREE.MathUtils.degToRad(point.el);
                  const r = 1;

                  const x = r * Math.cos(elRad) * Math.sin(azRad);
                  const y = r * Math.sin(elRad);
                  const z = r * Math.cos(elRad) * Math.cos(azRad);

                  const geometry = new THREE.SphereGeometry(0.02, 8, 8);
                  const material = new THREE.MeshBasicMaterial({ color: getColor(point.noise) });

                  const sphere = new THREE.Mesh(geometry, material);
                  sphere.position.set(x, y, z);

                  sphere.userData = {
                    azimuth: point.az,
                    elevation: point.el,
                    noise: point.noise
                  };

                  spheres.push(sphere);
                  scene.add(sphere);
                });

                let isCompleteDome = false;
                if (rawPoints.length > 0) {
                  const azValues = [...new Set(rawPoints.map(p => p.az))].sort((a, b) => a - b);
                  const elValues = [...new Set(rawPoints.map(p => p.el))].sort((a, b) => a - b);
                  const azRange = azValues[azValues.length - 1] - azValues[0];
                  const elRange = elValues[elValues.length - 1] - elValues[0];
                  isCompleteDome = azRange > 300 && elRange > 80;
                }

                if (!rawPoints.length || isCompleteDome) {
                  const distance = 2;
                  const azRad = THREE.MathUtils.degToRad(180);
                  const elRad = THREE.MathUtils.degToRad(30);
                  camera.position.set(
                    distance * Math.cos(elRad) * Math.sin(azRad),
                    distance * Math.sin(elRad),
                    distance * Math.cos(elRad) * Math.cos(azRad)
                  );
                  camera.lookAt(0, 0, 0);
                  controls.target.set(0, 0, 0);
                } else {
                  const boundingBox = new THREE.Box3();
                  spheres.forEach(s => boundingBox.expandByPoint(s.position));

                  const center = new THREE.Vector3();
                  boundingBox.getCenter(center);

                  const size = new THREE.Vector3();
                  boundingBox.getSize(size);
                  const maxDim = Math.max(size.x, size.y, size.z) || 2;

                  let avgPosition = new THREE.Vector3();
                  spheres.forEach(s => avgPosition.add(s.position));
                  avgPosition.divideScalar(spheres.length);

                  const directionToData = avgPosition.clone().normalize();
                  const distance = maxDim * 2;
                  camera.position.copy(directionToData.clone().multiplyScalar(distance));
                  camera.lookAt(center);
                  controls.target.copy(center);
                }

                controls.update();
                addAzimuthCompass();
                updateTimeDisplay();
                drawColorBar();

                if (csvSource === 'demo') {
                  demoStatus.textContent = 'Demo loaded!';
                  demoStatus.style.color = 'red';
                  demoStatus.style.display = 'block';
                } else if (csvSource === 'stored') {
                  demoStatus.textContent = 'Stored CSV loaded';
                  demoStatus.style.color = 'blue';
                  demoStatus.style.display = 'block';
                } else {
                  demoStatus.textContent = 'CSV loaded!';
                  demoStatus.style.color = 'blue';
                  demoStatus.style.display = 'block';
                }
              },
              error: function (error) {
                demoStatus.textContent = 'Error: Invalid CSV format';
                demoStatus.style.color = 'red';
                demoStatus.style.display = 'block';
              }
            });
          }

          const storedGrid = localStorage.getItem('skyObserverGrid');
          if (storedGrid && isValidGrid(storedGrid)) {
            gridInput.value = storedGrid;
            gridInput.style.borderColor = '#fff';
          } else {
            gridInput.value = 'JO89tt';
            localStorage.setItem('skyObserverGrid', 'JO89tt');
          }

          const storedCsv = localStorage.getItem('skyObserverCsv');
          if (storedCsv) {
            parseCsvData(storedCsv, 'stored');
          } else {
            fetch('2025-05-29_20.44.04.csv')
              .then(response => response.text())
              .then(csv => parseCsvData(csv, 'demo'))
              .catch(error => {
                console.error('Error loading demo CSV:', error);
                const distance = 2;
                const azRad = THREE.MathUtils.degToRad(180);
                const elRad = THREE.MathUtils.degToRad(30);
                camera.position.set(
                  distance * Math.cos(elRad) * Math.sin(azRad),
                  distance * Math.sin(elRad),
                  distance * Math.cos(elRad) * Math.cos(azRad)
                );
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
                addAzimuthCompass();
                addTrajectories();
              });
          }

          document.getElementById('csvUpload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (event) {
              const csvText = event.target.result;
              localStorage.setItem('skyObserverCsv', csvText);
              parseCsvData(csvText, 'uploaded');
            };
            reader.readAsText(file);
          });

          window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([
              ...spheres,
              moonMarker,
              sunMarker
            ].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData?.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          window.addEventListener('touchend', (event) => {
            const touch = event.changedTouches[0];
            if (!touch) return;

            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([
              ...spheres,
              moonMarker,
              sunMarker
            ].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData?.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }

          animate();

          const today = new Date();
          const year = today.getUTCFullYear();
          const month = String(today.getUTCMonth() + 1).padStart(2, '0');
          const day = String(today.getUTCDate()).padStart(2, '0');
          datePicker.value = `${year}-${month}-${day}`;
          addTrajectories();
        </script>
    </body>
</html>
