<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <title>Sky Observer</title>
      <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        
        html, body {
          touch-action: none;
        }

        button {
          min-width: 44px;
          min-height: 44px;
        }

        #infoBox {
          position: absolute;
          top: 10px;
          right: 10px;
          left: auto;
          padding: 10px;
          background: rgba(0,0,0,0.7);
          color: #fff;
          font-family: monospace;
          font-size: 12px;
          display: none;
          max-width: 80vw;
          z-index: 10;
          text-align: right;
          width: fit-content;
        }

        @media (max-width: 600px), (orientation: portrait) {
          #infoBox {
            font-size: 16px;
            padding: 16px;
            top: 15px;
            right: 15px;
            left: auto;
            text-align: right;
            width: fit-content;
            max-width: 90vw;
            line-height: 1.4;
          }
        }

        #moonTimeControls button {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.3);
          border-radius: 12px;
          color: white;
          font-size: 24px;
          font-family: sans-serif;
          padding: 10px 20px;
          cursor: pointer;
          transition: background 0.2s, transform 0.2s;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #moonTimeControls button:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
        }

        #moonTimeControls button:active {
          background: rgba(255, 255, 255, 0.3);
          transform: scale(0.97);
        }

        #moonTimeDisplay {
          color: white;
          font-family: 'Courier New', monospace;
          font-size: 20px;
          padding: 8px 12px;
          border-radius: 8px;
          background-color: rgba(0, 0, 0, 0.4);
          border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #prevDate, #nextDate {
          padding: 1px 6px;
          font-size: 10px;
          line-height: 1.2;
          min-height: 20px;
          width: 24px;
          border-radius: 4px;
          background: #444;
          color: white;
          border: none;
          cursor: pointer;
          transition: background 0.2s, transform 0.2s;
        }
        #prevDate:hover, #nextDate:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
        }
        #prevDate:active, #nextDate:active {
          background: rgba(255, 255, 255, 0.3);
          transform: scale(0.97);
        }

        #timeSlider {
          -webkit-appearance: none;
          appearance: none;
          background: rgba(255, 255, 255, 0.3);
          height: 12px;
          border-radius: 6px;
          outline: none;
          width: 80vw;
          max-width: 300px;
          touch-action: pan-y;
          z-index: 30;
        }
        #timeSlider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 24px;
          height: 24px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #timeSlider::-moz-range-thumb {
          width: 24px;
          height: 24px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #timeSlider:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        #colorBar {
          width: 20px !important;
          height: 200px !important;
        }
          /* Existing styles remain unchanged, add this to the <style> section */
          @media (max-width: 600px), (orientation: portrait) {
            #colorBar {
              width: 20px !important;
              height: 120px !important; /* Reduced from 200px */
            }
            #colorBarContainer {
              bottom: 100px; /* Move up to avoid time slider */
              right: 10px; /* Slightly closer to edge for space */
              font-size: 10px; /* Smaller labels for compactness */
            }
            #moonTimeControls {
              bottom: 10px; /* Slightly lower to maximize space */
            }
            #maxNoiseLabel, #minNoiseLabel {
              font-size: 10px; /* Match container font-size */
            }
          }
      </style>
    </head>
    <body>
        <!-- App Title + Author + Buttons -->
        <div style="position: absolute; top: 8px; left: 8px; z-index: 30; font-family: 'Segoe UI', sans-serif;">
          <div style="display: flex; flex-direction: row; align-items: flex-end; gap: 8px;">
            <div style="display: flex; flex-direction: column; align-items: flex-end; line-height: 1;">
              <div style="font-size: 10px; color: #aaa; padding-right: 2px;">
                by SA5IKN
              </div>
              <div style="font-size: 16px; color: white; font-weight: 600; background: rgba(0, 0, 0, 0.6); padding: 2px 4px; border-radius: 2px;">
                Sky Observer
              </div>
            </div>
            <div style="display: flex; flex-direction: row; gap: 4px;">
              <a href="https://dxer.site" target="_blank" title="Go to homepage"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                üè†
              </a>
              <a href="https://dxer.site/sky-observer-faq.html" target="_blank" title="Open FAQ"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                ‚ùì
              </a>
            </div>
          </div>
        </div>

        <!-- Ultra-Compact Control Panel -->
        <div id="controlPanel" style="
          position: absolute;
          top: 36px;
          left: 8px;
          z-index: 20;
          background: rgba(0,0,0,0.6);
          padding: 6px 8px;
          border-radius: 8px;
          display: flex;
          flex-direction: column;
          gap: 6px;
          font-family: 'Segoe UI', sans-serif;
          font-size: 12px;
          color: white;
          max-width: 160px;
        ">
          <div style="display: flex; align-items: center; gap: 4px;">
            <label for="gridInput">Grid:</label>
            <input type="text" id="gridInput" maxlength="6" placeholder="e.g. JO89tt"
                   style="width: 60px; font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none;">
          </div>
          <div style="display: flex; flex-direction: column; gap: 2px;">
            <label for="csvUpload">
              CSV <span style="font-size: 9px; color: #ccc;">(e.g. from SkyScanner)</span>:
            </label>
            <input type="file" id="csvUpload" accept=".csv"
                   style="font-size: 10px; padding: 2px 0px; color: white;">
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <button id="prevDate">&lt;</button>
            <input type="date" id="datePicker"
                   style="font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none; width: 100px;">
            <button id="nextDate">&gt;</button>
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <input type="checkbox" id="showSun" style="width: 14px; height: 14px;">
            <label for="showSun">Show sun</label>
          </div>
          <div id="demoStatus" style="color: red; font-weight: bold; margin-top: 10px;">
            Demo loaded!
          </div>
        </div>

        <!-- Time Slider -->
        <div id="moonTimeControls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 10px;">
          <span id="moonTimeDisplay" style="color: white; font-family: 'Courier New', monospace; font-size: 18px; padding: 8px 12px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.2);">
            --:-- UTC
          </span>
          <input type="range" id="timeSlider" min="0" max="0" value="0" aria-label="Select time for moon and sun position" role="slider" tabindex="0" style="width: 80vw; max-width: 300px; accent-color: #fff; cursor: pointer;">
        </div>

        <!-- Color-Bar for Noise Levels -->
        <div id="colorBarContainer" style="
          position: absolute;
          bottom: 20px;
          right: 20px;
          z-index: 30;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 5px;
          font-family: 'Segoe UI', sans-serif;
          font-size: 12px;
          color: white;
        ">
          <div id="maxNoiseLabel" style="text-align: center;">-- dB</div>
          <canvas id="colorBar" width="20" height="200" style="border: 1px solid rgba(255,255,255,0.3);"></canvas>
          <div id="minNoiseLabel" style="text-align: center;">-- dB</div>
        </div>

        <script src="a.ob.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/FontLoader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TextGeometry.js"></script>

        <script>
          const scene = new THREE.Scene();
          const moonTrajectoryGroup = new THREE.Group();
          const sunTrajectoryGroup = new THREE.Group();
          
          let moonPositions = [];
          let sunPositions = [];
          let currentTimeIndex = 0;
          let moonMarker = null;
          let sunMarker = null;
          let azStep = 5; // Default step size
          let elStep = 5; // Default step size
          
          const moonTimeDisplay = document.getElementById('moonTimeDisplay');
          const timeSlider = document.getElementById('timeSlider');
          const datePicker = document.getElementById('datePicker');
          const prevDateBtn = document.getElementById('prevDate');
          const nextDateBtn = document.getElementById('nextDate');
          const gridInput = document.getElementById('gridInput');
          const showSunCheckbox = document.getElementById('showSun');
          const demoStatus = document.getElementById('demoStatus');
          const colorBarCanvas = document.getElementById('colorBar');
          const colorBarContext = colorBarCanvas.getContext('2d');
          const minNoiseLabel = document.getElementById('minNoiseLabel');
          const maxNoiseLabel = document.getElementById('maxNoiseLabel');
          const colorBarContainer = document.getElementById('colorBarContainer');

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);

          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(0, 0, 2);
          camera.lookAt(0, 0, 0);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.target.set(0, 0, 0);
          controls.rotateSpeed = 0.5;
          controls.zoomSpeed = 0.5;
          controls.panSpeed = 0.5;
          controls.update();

          const raycaster = new THREE.Raycaster();
          const mouse = new THREE.Vector2();
          let spheres = [];
          let minNoise = Infinity, maxNoise = -Infinity;
          const rawPoints = [];

          scene.add(moonTrajectoryGroup);
          scene.add(sunTrajectoryGroup);

          function getColor(noise) {
            const range = maxNoise - minNoise;
            const norm = range === 0 ? 0.5 : (noise - minNoise) / range;
            return new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
          }

          function calculateStepSizes() {
            if (!rawPoints.length) {
              console.log('calculateStepSizes: No points available, using defaults azStep=5¬∞, elStep=5¬∞');
              return { azStep: 5, elStep: 5 };
            }

            const azValues = [...new Set(rawPoints.map(p => p.az))].sort((a, b) => a - b);
            const elValues = [...new Set(rawPoints.map(p => p.el))].sort((a, b) => a - b);

            const azDiffs = azValues.slice(1).map((v, i) => v - azValues[i]).filter(d => d > 0);
            const elDiffs = elValues.slice(1).map((v, i) => v - elValues[i]).filter(d => d > 0);

            const azStep = azDiffs.length ? Math.min(...azDiffs) : 5;
            const elStep = elDiffs.length ? Math.min(...elDiffs) : 5;

            console.log(`calculateStepSizes: azStep=${azStep.toFixed(2)}¬∞, elStep=${elStep.toFixed(2)}¬∞, azValues=${azValues.length}, elValues=${elValues.length}, azDiffs=[${azDiffs.map(d => d.toFixed(2)).join(', ')}], elDiffs=[${elDiffs.map(d => d.toFixed(2)).join(', ')}]`);
            return { azStep, elStep };
          }

          function interpolateNoiseAtPosition(azimuth, elevation) {
            if (!rawPoints.length) {
              console.log('interpolateNoiseAtPosition: No noise data available');
              return null;
            }

            const maxDistance = Math.max(azStep, elStep) * 1.0; // 15¬∞ for 5¬∞ steps
            const maxClosestDistance = 6; // Maximum distance for closest point
            const minPoints = 1;

            const pointsWithDistance = rawPoints.map(point => {
              const dAz = Math.abs(point.az - azimuth);
              const dEl = Math.abs(point.el - elevation);
              const distance = Math.sqrt(dAz * dAz + dEl * dEl);
              return { ...point, distance };
            });

            console.log(`interpolateNoiseAtPosition: All points for Az=${azimuth.toFixed(1)}¬∞, El=${elevation.toFixed(1)}¬∞:`);
            pointsWithDistance.forEach(p => {
              console.log(`  Az=${p.az.toFixed(1)}¬∞, El=${p.el.toFixed(1)}¬∞, Noise=${p.noise.toFixed(2)} dB, Distance=${p.distance.toFixed(2)}¬∞`);
            });

            const nearbyPoints = pointsWithDistance.filter(p => p.distance <= maxDistance);

            console.log(`interpolateNoiseAtPosition: Found ${nearbyPoints.length} points within maxDistance=${maxDistance.toFixed(2)}¬∞`);

            if (nearbyPoints.length >= minPoints) {
              if (nearbyPoints.length === 1) {
                const point = nearbyPoints[0];
                console.log(`interpolateNoiseAtPosition: Using single point Az=${point.az.toFixed(1)}¬∞, El=${point.el.toFixed(1)}¬∞, Noise=${point.noise.toFixed(2)} dB, Distance=${point.distance.toFixed(2)}¬∞`);
                return { noise: point.noise };
              }

              let totalWeight = 0;
              let weightedNoise = 0;
              nearbyPoints.forEach(point => {
                const weight = 1 / (point.distance * point.distance + 1e-6);
                weightedNoise += weight * point.noise;
                totalWeight += weight;
                console.log(`Point used: Az=${point.az.toFixed(1)}¬∞, El=${point.el.toFixed(1)}¬∞, Noise=${point.noise.toFixed(2)} dB, Distance=${point.distance.toFixed(2)}¬∞, Weight=${weight.toFixed(4)}`);
              });

              if (totalWeight === 0) {
                console.log(`interpolateNoiseAtPosition: Zero total weight for Az=${azimuth.toFixed(1)}¬∞, El=${elevation.toFixed(1)}¬∞`);
                return null;
              }

              const interpolatedNoise = weightedNoise / totalWeight;
              console.log(`interpolateNoiseAtPosition: Az=${azimuth.toFixed(1)}¬∞, El=${elevation.toFixed(1)}¬∞, Interpolated Noise=${interpolatedNoise.toFixed(2)} dB, Points used=${nearbyPoints.length}`);
              return { noise: Math.max(minNoise, Math.min(maxNoise, interpolatedNoise)) };
            }

            const closestPoint = pointsWithDistance.reduce((min, p) => p.distance < min.distance ? p : min, pointsWithDistance[0]);
            if (closestPoint.distance <= maxClosestDistance) {
              console.log(`interpolateNoiseAtPosition: No points within maxDistance=${maxDistance.toFixed(2)}¬∞, using closest point Az=${closestPoint.az.toFixed(1)}¬∞, El=${closestPoint.el.toFixed(1)}¬∞, Noise=${closestPoint.noise.toFixed(2)} dB, Distance=${closestPoint.distance.toFixed(2)}¬∞`);
              return { noise: closestPoint.noise };
            } else {
              console.log(`interpolateNoiseAtPosition: Closest point too far at Distance=${closestPoint.distance.toFixed(2)}¬∞ (> ${maxClosestDistance}¬∞), skipping interpolation`);
              return null;
            }
          }

            function drawColorBar() {
              if (minNoise === Infinity || maxNoise === -Infinity) {
                console.log('drawColorBar: No valid noise data, hiding color bar');
                colorBarContainer.style.display = 'none';
                return;
              }
              colorBarContainer.style.display = 'flex';

              minNoiseLabel.textContent = `${minNoise.toFixed(2)} dB`;
              maxNoiseLabel.textContent = `${maxNoise.toFixed(2)} dB`;

              // Adjust for device pixel ratio
              const dpr = window.devicePixelRatio || 1;
              const computedStyle = getComputedStyle(colorBarCanvas);
              const canvasWidth = parseFloat(computedStyle.width);
              const canvasHeight = parseFloat(computedStyle.height);
              colorBarCanvas.width = canvasWidth * dpr;
              colorBarCanvas.height = canvasHeight * dpr;
              colorBarContext.scale(dpr, dpr);

              colorBarContext.save();
              colorBarContext.setTransform(1, 0, 0, 1, 0, 0);
              colorBarContext.clearRect(0, 0, colorBarCanvas.width, colorBarCanvas.height);

              console.log(`drawColorBar: Canvas width=${colorBarCanvas.width}, height=${colorBarCanvas.height}, computedStyle=${computedStyle.width}x${computedStyle.height}, DPR=${dpr}`);

              const gradient = colorBarContext.createLinearGradient(0, colorBarCanvas.height, 0, 0);
              for (let i = 0; i <= 1; i += 0.1) {
                const norm = i;
                const color = new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
                gradient.addColorStop(i, `#${color.getHexString()}`);
              }
              colorBarContext.fillStyle = gradient;
              colorBarContext.fillRect(0, 0, colorBarCanvas.width, colorBarCanvas.height);

              if (moonPositions.length && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0 && rawPoints.length) {
                const moonData = moonPositions[currentTimeIndex];
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                if (noisePoint) {
                  const noise = noisePoint.noise;
                  const norm = (maxNoise - minNoise) === 0 ? 0.5 : (noise - minNoise) / (maxNoise - minNoise);
                  let y = colorBarCanvas.height * (1 - norm);
                  y = Math.max(2 * dpr, Math.min(colorBarCanvas.height - 2 * dpr, y));

                  console.log(`drawColorBar: Drawing Moon noise marker at Noise=${noise.toFixed(2)} dB, y=${y.toFixed(2)}, norm=${norm.toFixed(4)}`);

                  // Adjust triangle size for mobile
                  const isMobile = window.innerWidth <= 600 || window.matchMedia("(orientation: portrait)").matches;
                  const triangleSize = isMobile ? 12 : 18;
                  const textOffset = isMobile ? 14 : 22;
                  const fontSize = isMobile ? 12 : 14;

                  colorBarContext.strokeStyle = '#000000';
                  colorBarContext.lineWidth = 2 * dpr;
                  colorBarContext.beginPath();
                  colorBarContext.moveTo(colorBarCanvas.width, y);
                  colorBarContext.lineTo(colorBarCanvas.width + triangleSize * dpr, y - (triangleSize / 2) * dpr);
                  colorBarContext.lineTo(colorBarCanvas.width + triangleSize * dpr, y + (triangleSize / 2) * dpr);
                  colorBarContext.closePath();
                  colorBarContext.stroke();

                  colorBarContext.fillStyle = '#ffffff';
                  colorBarContext.fill();

                  colorBarContext.fillStyle = '#ffffff';
                  colorBarContext.strokeStyle = '#000000';
                  colorBarContext.lineWidth = 10 * dpr;
                  colorBarContext.font = `bold ${fontSize * dpr}px Segoe UI`;
                  colorBarContext.textAlign = 'left';
                  colorBarContext.textBaseline = 'middle';
                  colorBarContext.strokeText(`${noise.toFixed(2)} dB`, colorBarCanvas.width + textOffset * dpr, y);
                  colorBarContext.fillText(`${noise.toFixed(2)} dB`, colorBarCanvas.width + textOffset * dpr, y);

                  // Optional: Comment out or remove the red rectangle if not needed
                  // colorBarContext.fillStyle = '#ff0000';
                  // colorBarContext.fillRect(0, y - 2 * dpr, 5 * dpr, 4 * dpr);
                } else {
                  console.log(`drawColorBar: No valid noise point for Moon at Az=${moonData.azimuth.toFixed(1)}¬∞, El=${moonData.elevation.toFixed(1)}¬∞`);
                }
              } else {
                console.log('drawColorBar: Moon below horizon or no data, skipping marker');
              }

              colorBarContext.restore();
            }

          function updateMoonMarker() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              console.log(`updateMoonMarker: No moon position at index ${currentTimeIndex}`);
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            const moonData = moonPositions[currentTimeIndex];
            if (moonData.elevation <= 0) {
              console.log(`updateMoonMarker: Moon below horizon at ${moonData.time.toUTCString()} (elevation=${moonData.elevation.toFixed(1)}¬∞)`);
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            if (!moonMarker) {
              console.log(`updateMoonMarker: Creating moon marker`);
              const geom = new THREE.SphereGeometry(0.03);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
              moonMarker = new THREE.Mesh(geom, mat);
              scene.add(moonMarker);
            }

            console.log(`updateMoonMarker: Showing moon marker at ${moonData.time.toUTCString()}, Az=${moonData.azimuth.toFixed(1)}¬∞, El=${moonData.elevation.toFixed(1)}¬∞`);
            moonMarker.visible = true;
            moonMarker.position.copy(moonData.position);
            return true;
          }

          function updateSunMarker() {
            if (!sunPositions.length || !showSunCheckbox.checked || !sunPositions[currentTimeIndex]) {
              console.log(`updateSunMarker: No sun position or sun not shown at index ${currentTimeIndex}`);
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            const sunData = sunPositions[currentTimeIndex];
            if (sunData.elevation <= 0) {
              console.log(`updateSunMarker: Sun below horizon at ${sunData.time.toUTCString()} (elevation=${sunData.elevation.toFixed(1)}¬∞)`);
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            if (!sunMarker) {
              console.log(`updateSunMarker: Creating sun marker`);
              const geom = new THREE.SphereGeometry(0.02);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
              sunMarker = new THREE.Mesh(geom, mat);
              scene.add(sunMarker);
            }

            console.log(`updateSunMarker: Showing sun marker at ${sunData.time.toUTCString()}, Az=${sunData.azimuth.toFixed(1)}¬∞, El=${sunData.elevation.toFixed(1)}¬∞`);
            sunMarker.visible = true;
            sunMarker.position.copy(sunData.position);
            return true;
          }

          function updateInfoBox() {
            let html = '';

            if (moonPositions.length && moonPositions[currentTimeIndex]) {
              const moonData = moonPositions[currentTimeIndex];
              if (moonData.elevation > 0) {
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A';
                html += `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
              } else {
                html += `
                  <b>Moon</b><br>
                  Moon below horizon
                `;
              }
            } else {
              html += `
                <b>Moon</b><br>
                Moon below horizon
              `;
            }

            if (showSunCheckbox.checked && sunPositions.length && sunPositions[currentTimeIndex]) {
              const sunData = sunPositions[currentTimeIndex];
              html += `<br>`;
              if (sunData.elevation > 0) {
                html += `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
              } else {
                html += `
                  <b>Sun</b><br>
                  Sun below horizon
                `;
              }
            } else if (showSunCheckbox.checked) {
              html += `
                <br><b>Sun</b><br>
                Sun below horizon
              `;
            }

            infoBox.innerHTML = html;
            infoBox.style.display = 'block';
          }

          function updateTimeDisplay() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              console.log(`updateTimeDisplay: No positions at index ${currentTimeIndex}`);
              moonTimeDisplay.textContent = '--:-- UTC';
              updateInfoBox();
              drawColorBar();
              return;
            }

            const time = moonPositions[currentTimeIndex].time;
            const moonVisible = moonPositions[currentTimeIndex].elevation > 0;
            const sunVisible = showSunCheckbox.checked && sunPositions[currentTimeIndex]?.elevation > 0;

            console.log(`updateTimeDisplay at ${time.toUTCString()}: moonVisible=${moonVisible}, sunVisible=${sunVisible}`);

            if (moonVisible || sunVisible) {
              const hours = String(time.getUTCHours()).padStart(2, '0');
              const minutes = String(time.getUTCMinutes()).padStart(2, '0');
              moonTimeDisplay.textContent = `${hours}:${minutes} UTC`;
            } else {
              moonTimeDisplay.textContent = '--:-- UTC';
            }
            updateInfoBox();
            drawColorBar();
          }

          function updateTimeSlider() {
            timeSlider.min = 0;
            timeSlider.max = moonPositions.length - 1 || 0;
            timeSlider.value = currentTimeIndex;
            timeSlider.disabled = moonPositions.length === 0;
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeTime(index) {
            if (!moonPositions.length) return;
            currentTimeIndex = Math.max(0, Math.min(index, moonPositions.length - 1));
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeDate(days) {
            let currentDate = datePicker.value ? new Date(datePicker.value) : new Date();
            currentDate.setUTCDate(currentDate.getUTCDate() + days);
            const year = currentDate.getUTCFullYear();
            const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(currentDate.getUTCDate()).padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            addTrajectories(datePicker.value);
          }

          timeSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            changeTime(parseInt(e.target.value));
          });

          timeSlider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            controls.enabled = false;
            console.log('Slider touchstart: OrbitControls disabled');
          });

          timeSlider.addEventListener('touchend', (e) => {
            e.stopPropagation();
            controls.enabled = true;
            console.log('Slider touchend: OrbitControls enabled');
          });

          timeSlider.addEventListener('touchcancel', (e) => {
            e.stopPropagation();
            controls.enabled = true;
            console.log('Slider touchcancel: OrbitControls enabled');
          });

          datePicker.addEventListener('change', (e) => {
            const selectedDate = e.target.value;
            if (selectedDate) {
              addTrajectories(selectedDate);
            }
          });

          prevDateBtn.addEventListener('click', () => changeDate(-1));
          nextDateBtn.addEventListener('click', () => changeDate(1));

          showSunCheckbox.addEventListener('change', () => {
            sunTrajectoryGroup.visible = showSunCheckbox.checked;
            updateSunMarker();
            updateTimeDisplay();
            console.log(`Sun visibility toggled: ${showSunCheckbox.checked}`);
          });

          function isValidGrid(locator) {
            if (!locator || locator.length < 4 || locator.length > 6) return false;
            locator = locator.toUpperCase();
            const regex = /^[A-R]{2}[0-9]{2}([A-X]{2})?$/;
            return regex.test(locator);
          }

          gridInput.addEventListener('input', () => {
            const grid = gridInput.value;
            if (isValidGrid(grid)) {
              gridInput.style.borderColor = '#fff';
              localStorage.setItem('skyObserverGrid', grid);
              const dateVal = datePicker.value || new Date().toISOString().split('T')[0];
              addTrajectories(dateVal);
            } else {
              gridInput.style.borderColor = 'red';
            }
          });

          function maidenheadToLatLon(locator) {
            if (!locator || locator.length < 4) return null;
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            let lon = (locator.charCodeAt(0) - A) * 20 - 180;
            let lat = (locator.charCodeAt(1) - A) * 10 - 90;
            lon += parseInt(locator[2]) * 2;
            lat += parseInt(locator[3]) * 1;
            if (locator.length >= 6) {
              lon += (locator.charCodeAt(4) - A) * 5 / 60;
              lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
            }
            lon += 2.5 / 60;
            lat += 1.25 / 60;
            return { lat, lon };
          }

          const infoBox = document.createElement('div');
          infoBox.id = 'infoBox';
          document.body.appendChild(infoBox);

          function addAzimuthCompass() {
            const compassRadius = 1.05;
            const labelDistance = 1.2;
            const compassGroup = new THREE.Group();

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
              const directions = [
                { label: 'N', az: 0, color: 0xff0000 },
                { label: 'E', az: 90, color: 0xffffff },
                { label: 'S', az: 180, color: 0xffffff },
                { label: 'W', az: 270, color: 0xffffff }
              ];

              directions.forEach(dir => {
                const azRad = THREE.MathUtils.degToRad(360 - dir.az);
                const x = labelDistance * Math.sin(azRad);
                const z = labelDistance * Math.cos(azRad);
                const y = 0;

                const textGeom = new THREE.TextGeometry(dir.label, {
                  font: font,
                  size: 0.1,
                  height: 0.001
                });
                const textMat = new THREE.MeshBasicMaterial({ color: dir.color });
                const text = new THREE.Mesh(textGeom, textMat);
                text.position.set(x, y, z);
                text.lookAt(0, 0, 0);
                compassGroup.add(text);
              });

              const ringGeom = new THREE.RingGeometry(compassRadius - 0.002, compassRadius + 0.002, 256);
              const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
              });
              const ring = new THREE.Mesh(ringGeom, ringMat);
              ring.rotation.x = -Math.PI / 2;
              ring.position.y = 0;
              compassGroup.add(ring);

              for (let i = 0; i < 360; i += 10) {
                const angle = THREE.MathUtils.degToRad(360 - i);
                const isMajor = i % 30 === 0;
                const outer = compassRadius + 0.02;
                const inner = compassRadius - (isMajor ? 0.05 : 0.02);

                const x1 = inner * Math.cos(angle);
                const z1 = inner * Math.sin(angle);
                const x2 = outer * Math.cos(angle);
                const z2 = outer * Math.sin(angle);

                const tickGeom = new THREE.BufferGeometry().setFromPoints([
                  new THREE.Vector3(x1, 0, z1),
                  new THREE.Vector3(x2, 0, z2)
                ]);
                const tickMat = new THREE.LineBasicMaterial({
                  color: 0xffffff,
                  transparent: true,
                  opacity: isMajor ? 1.0 : 0.5
                });
                const tick = new THREE.Line(tickGeom, tickMat);
                compassGroup.add(tick);

                if (isMajor && ![0, 90, 180, 270].includes(i)) {
                  const labelDist = compassRadius + 0.1;
                  const lx = labelDist * Math.sin(angle);
                  const lz = labelDist * Math.cos(angle);

                  const degGeom = new THREE.TextGeometry(i.toString(), {
                    font: font,
                    size: 0.045,
                    height: 0.001
                  });
                  const degMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                  const label = new THREE.Mesh(degGeom, degMat);
                  label.position.set(lx, 0, lz);
                  label.lookAt(0, 0, 0);
                  label.rotation.y += Math.PI;
                  compassGroup.add(label);
                }
              }

              scene.add(compassGroup);
              console.log(`Compass added, children: ${compassGroup.children.length}`);
            }, undefined, (error) => {
              console.error('Font loading failed:', error);
            });
          }

          function addTrajectories(selectedDate) {
            const grid = gridInput.value || 'JO89tt';
            const coords = maidenheadToLatLon(grid);
            if (!coords) {
              gridInput.style.borderColor = 'red';
              gridInput.value = 'JO89tt';
              localStorage.setItem('skyObserverGrid', 'JO89tt');
              return addTrajectories(selectedDate);
            }
            const lat = coords.lat;
            const lon = coords.lon;

            const observer = new Astronomy.Observer(lat, lon, 0);

            const date = selectedDate ? new Date(selectedDate) : new Date();
            const startOfDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

            moonTrajectoryGroup.clear();
            sunTrajectoryGroup.clear();
            if (moonMarker) scene.remove(moonMarker);
            if (sunMarker) scene.remove(sunMarker);
            moonMarker = null;
            sunMarker = null;
            moonPositions = [];
            sunPositions = [];
            currentTimeIndex = 0;

            let moonSegment = [];
            let sunSegment = [];
            const moonSegments = [];
            const sunSegments = [];

            let firstMoonVisibleIndex = -1;
            let firstSunVisibleIndex = -1;

            for (let minutes = 0; minutes < 1440; minutes += 10) {
              const time = new Date(startOfDay.getTime() + minutes * 60 * 1000);

              if (time >= endOfDay) break;

              const moonEq = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, false);
              const moonHor = Astronomy.Horizon(time, observer, moonEq.ra, moonEq.dec, 'normal');
              const moonElevationDeg = moonHor.altitude;
              const moonAzimuthDeg = moonHor.azimuth;

              const azRadMoon = THREE.MathUtils.degToRad(360 - moonAzimuthDeg);
              const elRadMoon = THREE.MathUtils.degToRad(Math.max(moonElevationDeg, 0));
              const r = 1;
              const xMoon = r * Math.cos(elRadMoon) * Math.sin(azRadMoon);
              const yMoon = r * Math.sin(elRadMoon);
              const zMoon = r * Math.cos(elRadMoon) * Math.cos(azRadMoon);
              const moonPoint = new THREE.Vector3(xMoon, yMoon, zMoon);

              if (moonElevationDeg > 0) {
                moonSegment.push(moonPoint);
                if (firstMoonVisibleIndex === -1) firstMoonVisibleIndex = minutes / 10;
              } else {
                if (moonSegment.length > 1) moonSegments.push(moonSegment);
                moonSegment = [];
              }
              moonPositions.push({ time, position: moonPoint, azimuth: moonAzimuthDeg, elevation: moonElevationDeg });

              const sunEq = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, false);
              const sunHor = Astronomy.Horizon(time, observer, sunEq.ra, sunEq.dec, 'normal');
              const sunElevationDeg = sunHor.altitude;
              const sunAzimuthDeg = sunHor.azimuth;

              const azRadSun = THREE.MathUtils.degToRad(360 - sunAzimuthDeg);
              const elRadSun = THREE.MathUtils.degToRad(Math.max(sunElevationDeg, 0));
              const xSun = r * Math.cos(elRadSun) * Math.sin(azRadSun);
              const ySun = r * Math.sin(elRadSun);
              const zSun = r * Math.cos(elRadSun) * Math.cos(azRadSun);
              const sunPoint = new THREE.Vector3(xSun, ySun, zSun);

              if (sunElevationDeg > 0) {
                sunSegment.push(sunPoint);
                if (firstSunVisibleIndex === -1) firstSunVisibleIndex = minutes / 10;
              } else {
                if (sunSegment.length > 1) sunSegments.push(sunSegment);
                sunSegment = [];
              }
              sunPositions.push({ time, position: sunPoint, azimuth: sunAzimuthDeg, elevation: sunElevationDeg });

              if (minutes === 720 || minutes === 1030 || minutes === 1140) {
                console.log(`At ${time.toUTCString()}:`);
                console.log(`  Moon: Az=${moonAzimuthDeg.toFixed(1)}¬∞, El=${moonElevationDeg.toFixed(1)}¬∞`);
                console.log(`  Sun: Az=${sunAzimuthDeg.toFixed(1)}¬∞, El=${sunElevationDeg.toFixed(1)}¬∞`);
              }
            }

            if (moonSegment.length > 1) moonSegments.push(moonSegment);
            if (sunSegment.length > 1) sunSegments.push(sunSegment);

            moonSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isMoonTrajectory: true };
              moonTrajectoryGroup.add(line);
            });

            sunSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffa500 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isSunTrajectory: true };
              sunTrajectoryGroup.add(line);
            });

            sunTrajectoryGroup.visible = showSunCheckbox.checked;

            if (firstMoonVisibleIndex !== -1) {
              currentTimeIndex = firstMoonVisibleIndex;
            } else if (showSunCheckbox.checked && firstSunVisibleIndex !== -1) {
              currentTimeIndex = firstSunVisibleIndex;
            } else {
              currentTimeIndex = 72;
            }
            console.log(`addTrajectories: moonSegments=${moonSegments.length}, sunSegments=${sunSegments.length}, currentTimeIndex=${currentTimeIndex}`);
            updateTimeSlider();
          }

          window.addTrajectories = addTrajectories;

          function parseCsvData(csvText, csvSource) {
            Papa.parse(csvText, {
              header: true,
              delimiter: ";",
              complete: function (results) {
                rawPoints.length = 0;
                spheres.forEach(s => scene.remove(s));
                spheres.length = 0;
                minNoise = Infinity;
                maxNoise = -Infinity;

                results.data.forEach(row => {
                  if (!row.Valid || row.Valid !== "True") return;

                  const az = parseFloat(row.Azimuth?.replace(",", "."));
                  const el = parseFloat(row.Elevation?.replace(",", "."));
                  const noise = parseFloat(row.Noise?.replace(",", "."));

                  if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

                  minNoise = Math.min(minNoise, noise);
                  maxNoise = Math.max(maxNoise, noise);

                  rawPoints.push({ az, el, noise });
                });

                const steps = calculateStepSizes();
                azStep = steps.azStep;
                elStep = steps.elStep;

                console.log(`parseCsvData: minNoise=${minNoise.toFixed(2)} dB, maxNoise=${maxNoise.toFixed(2)} dB`);
                console.log('Noise points:', rawPoints.map(p => `Az=${p.az.toFixed(1)}¬∞, El=${p.el.toFixed(1)}¬∞, Noise=${p.noise.toFixed(2)} dB`));

                rawPoints.forEach(point => {
                  const azRad = THREE.MathUtils.degToRad(360 - point.az);
                  const elRad = THREE.MathUtils.degToRad(point.el);
                  const r = 1;

                  const x = r * Math.cos(elRad) * Math.sin(azRad);
                  const y = r * Math.sin(elRad);
                  const z = r * Math.cos(elRad) * Math.cos(azRad);

                  const geometry = new THREE.SphereGeometry(0.02, 8, 8);
                  const material = new THREE.MeshBasicMaterial({ color: getColor(point.noise) });

                  const sphere = new THREE.Mesh(geometry, material);
                  sphere.position.set(x, y, z);

                  sphere.userData = {
                    azimuth: point.az,
                    elevation: point.el,
                    noise: point.noise
                  };

                  spheres.push(sphere);
                  scene.add(sphere);
                });

                const boundingBox = new THREE.Box3();
                spheres.forEach(s => boundingBox.expandByPoint(s.position));

                const center = new THREE.Vector3();
                boundingBox.getCenter(center);

                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 2;

                let avgPosition = new THREE.Vector3();
                spheres.forEach(s => avgPosition.add(s.position));
                avgPosition.divideScalar(spheres.length);

                const directionToData = avgPosition.clone().normalize();
                const distance = maxDim * 2;
                camera.position.copy(directionToData.clone().multiplyScalar(distance));
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                addAzimuthCompass();
                updateTimeDisplay();
                drawColorBar();

                if (csvSource === 'demo') {
                  demoStatus.textContent = 'Demo loaded!';
                  demoStatus.style.display = 'block';
                } else if (csvSource === 'stored') {
                  demoStatus.textContent = 'Stored CSV loaded';
                  demoStatus.style.display = 'block';
                } else {
                  demoStatus.style.display = 'none';
                }
                console.log(`parseCsvData: Spheres added=${spheres.length}`);
              }
            });
          }

          const storedGrid = localStorage.getItem('skyObserverGrid');
          if (storedGrid && isValidGrid(storedGrid)) {
            gridInput.value = storedGrid;
            gridInput.style.borderColor = '#fff';
          } else {
            gridInput.value = 'JO89tt';
            localStorage.setItem('skyObserverGrid', 'JO89tt');
          }

          const storedCsv = localStorage.getItem('skyObserverCsv');
          if (storedCsv) {
            parseCsvData(storedCsv, 'stored');
          } else {
            fetch('2025-05-29_20.44.04.csv')
              .then(response => response.text())
              .then(csv => parseCsvData(csv, 'demo'))
              .catch(error => {
                console.error('Error loading demo CSV:', error);
                addAzimuthCompass();
                addTrajectories();
              });
          }

          document.getElementById('csvUpload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (event) {
              const csvText = event.target.result;
              localStorage.setItem('skyObserverCsv', csvText);
              parseCsvData(csvText, 'uploaded');
            };
            reader.readAsText(file);
          });

          window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          window.addEventListener('touchend', (event) => {
            const touch = event.changedTouches[0];
            if (!touch) return;

            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                const noisePoint = interpolateNoiseAtPosition(moonData.azimuth, moonData.elevation);
                const noiseText = noisePoint ? `Noise: ${noisePoint.noise.toFixed(2)} dB` : 'Noise: N/A (Outside Dome)';
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞<br>
                  ${noiseText}
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }

          animate();

          const today = new Date();
          const year = today.getUTCFullYear();
          const month = String(today.getUTCMonth() + 1).padStart(2, '0');
          const day = String(today.getUTCDate()).padStart(2, '0');
          datePicker.value = `${year}-${month}-${day}`;
          addTrajectories();
        </script>
    </body>
</html>
