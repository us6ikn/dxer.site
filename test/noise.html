<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <title>Sky Observer</title>
      <style>
        body {
          margin: 0;
          overflow: hidden;
          background: #000; /* Set black background to avoid white flash */
        }
        canvas {
          display: block;
          width: 100vw !important;
          height: 100vh !important;
          position: absolute;
          top: 0;
          left: 0;
          z-index: 1; /* Ensure canvas is behind UI */
        }
        
        html, body {
          touch-action: none;
        }

        button {
          min-width: 44px;
          min-height: 44px;
        }

        #errorMessage {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          color: red;
          font-family: 'Segoe UI', sans-serif;
          font-size: 16px;
          text-align: center;
          z-index: 50;
          display: none;
        }

        #infoBox {
          position: absolute;
          top: 10px;
          right: 10px;
          left: auto;
          padding: 10px;
          background: rgba(0,0,0,0.7);
          color: #fff;
          font-family: monospace;
          font-size: 12px;
          display: none;
          max-width: 80vw;
          z-index: 10;
          text-align: right;
          width: fit-content;
        }

        @media (max-width: 600px), (orientation: portrait) {
          #infoBox {
            font-size: 16px;
            padding: 16px;
            top: 15px;
            right: 15px;
            left: auto;
            text-align: right;
            width: fit-content;
            max-width: 90vw;
            line-height: 1.4;
          }
          #controlPanel {
            max-width: 90vw;
            left: 8px;
            top: 36px;
          }
          #moonTimeControls {
            bottom: 20px;
            width: 90vw;
            max-width: 300px;
          }
        }

        #moonTimeControls button {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.3);
          border-radius: 12px;
          color: white;
          font-size: 24px;
          font-family: sans-serif;
          padding: 10px 20px;
          cursor: pointer;
          transition: background 0.2s, transform 0.2s;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #moonTimeControls button:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
        }

        #moonTimeControls button:active {
          background: rgba(255, 255, 255, 0.3);
          transform: scale(0.97);
        }

        #moonTimeDisplay {
          color: white;
          font-family: 'Courier New', monospace;
          font-size: 20px;
          padding: 8px 12px;
          border-radius: 8px;
          background-color: rgba(0, 0, 0, 0.4);
          border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #prevDate, #nextDate {
          padding: 1px 6px;
          font-size: 10px;
          line-height: 1.2;
          min-height: 20px;
          width: 24px;
          border-radius: 4px;
          background: #444;
          color: white;
          border: none;
          cursor: pointer;
          transition: background 0.2s, transform 0.2s;
        }
        #prevDate:hover, #nextDate:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
        }
        #prevDate:active, #nextDate:active {
          background: rgba(255, 255, 255, 0.3);
          transform: scale(0.97);
        }

        #timeSlider {
          -webkit-appearance: none;
          appearance: none;
          background: rgba(255, 255, 255, 0.3);
          height: 12px;
          border-radius: 6px;
          outline: none;
          width: 80vw;
          max-width: 300px;
          touch-action: pan-y;
          z-index: 30;
        }
        #timeSlider::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 24px;
          height: 24px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #timeSlider::-moz-range-thumb {
          width: 24px;
          height: 24px;
          background: #fff;
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #timeSlider:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
      </style>
    </head>
    <body>
        <!-- Error Message for WebGL or Dependency Failure -->
        <div id="errorMessage">
          Unable to initialize Sky Observer. Your device may not support WebGL or required resources failed to load. Please try a different browser or device.
        </div>

        <!-- App Title + Author + Buttons -->
        <div style="position: absolute; top: 8px; left: 8px; z-index: 30; font-family: 'Segoe UI', sans-serif;">
          <div style="display: flex; flex-direction: row; align-items: flex-end; gap: 8px;">
            <div style="display: flex; flex-direction: column; align-items: flex-end; line-height: 1;">
              <div style="font-size: 10px; color: #aaa; padding-right: 2px;">
                by SA5IKN
              </div>
              <div style="font-size: 16px; color: white; font-weight: 600; background: rgba(0, 0, 0, 0.6); padding: 2px 4px; border-radius: 2px;">
                Sky Observer
              </div>
            </div>
            <div style="display: flex; flex-direction: row; gap: 4px;">
              <a href="https://dxer.site" target="_blank" title="Go to homepage"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                üè†
              </a>
              <a href="https://dxer.site/sky-observer-faq.html" target="_blank" title="Open FAQ"
                 style="text-decoration: none; font-size: 16px; background: rgba(255,255,255,0.1); color: white; padding: 2px 6px; border-radius: 4px;">
                ‚ùì
              </a>
            </div>
          </div>
        </div>

        <!-- Ultra-Compact Control Panel -->
        <div id="controlPanel" style="
          position: absolute;
          top: 36px;
          left: 8px;
          z-index: 20;
          background: rgba(0,0,0,0.6);
          padding: 6px 8px;
          border-radius: 8px;
          display: flex;
          flex-direction: column;
          gap: 6px;
          font-family: 'Segoe UI', sans-serif;
          font-size: 12px;
          color: white;
          max-width: 160px;
        ">
          <div style="display: flex; align-items: center; gap: 4px;">
            <label for="gridInput">Grid:</label>
            <input type="text" id="gridInput" maxlength="6" placeholder="e.g. JO89tt"
                   style="width: 60px; font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none;">
          </div>
          <div style="display: flex; flex-direction: column; gap: 2px;">
            <label for="csvUpload">
              CSV <span style="font-size: 9px; color: #ccc;">(e.g. from SkyScanner)</span>:
            </label>
            <input type="file" id="csvUpload" accept=".csv"
                   style="font-size: 10px; padding: 2px 0px; color: white;">
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <button id="prevDate">&lt;</button>
            <input type="date" id="datePicker"
                   style="font-size: 11px; padding: 2px 4px; border-radius: 4px; border: none; width: 100px;">
            <button id="nextDate">&gt;</button>
          </div>
          <div style="display: flex; align-items: center; gap: 4px;">
            <input type="checkbox" id="showSun" style="width: 14px; height: 14px;">
            <label for="showSun">Show sun</label>
          </div>
          <div id="demoStatus" style="color: red; font-weight: bold; margin-top: 10px;">
            Demo loaded!
          </div>
        </div>

        <!-- Time Slider -->
        <div id="moonTimeControls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 10px;">
          <span id="moonTimeDisplay" style="color: white; font-family: 'Courier New', monospace; font-size: 18px; padding: 8px 12px; border-radius: 8px; background-color: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.2);">
            --:-- UTC
          </span>
          <input type="range" id="timeSlider" min="0" max="0" value="0" aria-label="Select time for moon and sun position" role="slider" tabindex="0" style="width: 80vw; max-width: 300px; accent-color: #fff; cursor: pointer;">
        </div>

        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/FontLoader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/geometries/TextGeometry.js"></script>
        <script src="a.ob.js"></script>

        <script>
          // Check WebGL support
          function checkWebGLSupport() {
            try {
              const canvas = document.createElement('canvas');
              return !!(window.WebGLRenderingContext &&
                       (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
              return false;
            }
          }

          const errorMessage = document.getElementById('errorMessage');

          if (!checkWebGLSupport()) {
            errorMessage.style.display = 'block';
            console.error('WebGL not supported on this device.');
            throw new Error('WebGL not supported');
          }

          const scene = new THREE.Scene();
          const moonTrajectoryGroup = new THREE.Group();
          const sunTrajectoryGroup = new THREE.Group();
          
          let moonPositions = [];
          let sunPositions = [];
          let currentTimeIndex = 0;
          let moonMarker = null;
          let sunMarker = null;
          
          const moonTimeDisplay = document.getElementById('moonTimeDisplay');
          const timeSlider = document.getElementById('timeSlider');
          const datePicker = document.getElementById('datePicker');
          const prevDateBtn = document.getElementById('prevDate');
          const nextDateBtn = document.getElementById('nextDate');
          const gridInput = document.getElementById('gridInput');
          const showSunCheckbox = document.getElementById('showSun');
          const demoStatus = document.getElementById('demoStatus');

          let renderer;
          try {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x000000); // Set black clear color
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
          } catch (e) {
            console.error('Failed to initialize WebGL renderer:', e);
            errorMessage.textContent = 'Failed to initialize WebGL. Please try a different browser or device.';
            errorMessage.style.display = 'block';
            throw e;
          }

          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(0, 0, 2);
          camera.lookAt(0, 0, 0);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.target.set(0, 0, 0);
          controls.rotateSpeed = 0.5;
          controls.zoomSpeed = 0.5;
          controls.panSpeed = 0.5;
          controls.update();

          const raycaster = new THREE.Raycaster();
          const mouse = new THREE.Vector2();
          let spheres = [];
          let minNoise = Infinity, maxNoise = -Infinity;
          const rawPoints = [];

          scene.add(moonTrajectoryGroup);
          scene.add(sunTrajectoryGroup);

          // Debounce function
          function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
              const later = () => {
                clearTimeout(timeout);
                func(...args);
              };
              clearTimeout(timeout);
              timeout = setTimeout(later, wait);
            };
          }

          // Handle window resize and orientation change
          function handleResize() {
            const width = Math.max(1, window.innerWidth); // Prevent zero width
            const height = Math.max(1, window.innerHeight); // Prevent zero height

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            renderer.render(scene, camera);

            console.log(`Resize handled: ${width}x${height}, aspect=${camera.aspect}`);
          }

          window.addEventListener('resize', debounce(handleResize, 100));
          window.addEventListener('orientationchange', debounce(handleResize, 100));

          function getColor(noise) {
            const range = maxNoise - minNoise;
            const norm = range === 0 ? 0.5 : (noise - minNoise) / range;
            return new THREE.Color().setHSL(0.7 - norm * 0.7, 1.0, 0.5);
          }

          function updateMoonMarker() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              console.log(`updateMoonMarker: No moon position at index ${currentTimeIndex}`);
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            const moonData = moonPositions[currentTimeIndex];
            if (moonData.elevation <= 0) {
              console.log(`updateMoonMarker: Moon below horizon at ${moonData.time.toUTCString()} (elevation=${moonData.elevation.toFixed(1)}¬∞)`);
              if (moonMarker) moonMarker.visible = false;
              return false;
            }

            if (!moonMarker) {
              console.log(`updateMoonMarker: Creating moon marker`);
              const geom = new THREE.SphereGeometry(0.03);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
              moonMarker = new THREE.Mesh(geom, mat);
              scene.add(moonMarker);
            }

            console.log(`updateMoonMarker: Showing moon marker at ${moonData.time.toUTCString()}, Az=${moonData.azimuth.toFixed(1)}¬∞, El=${moonData.elevation.toFixed(1)}¬∞`);
            moonMarker.visible = true;
            moonMarker.position.copy(moonData.position);
            return true;
          }

          function updateSunMarker() {
            if (!sunPositions.length || !showSunCheckbox.checked || !sunPositions[currentTimeIndex]) {
              console.log(`updateSunMarker: No sun position or sun not shown at index ${currentTimeIndex}`);
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            const sunData = sunPositions[currentTimeIndex];
            if (sunData.elevation <= 0) {
              console.log(`updateSunMarker: Sun below horizon at ${sunData.time.toUTCString()} (elevation=${sunData.elevation.toFixed(1)}¬∞)`);
              if (sunMarker) sunMarker.visible = false;
              return false;
            }

            if (!sunMarker) {
              console.log(`updateSunMarker: Creating sun marker`);
              const geom = new THREE.SphereGeometry(0.02);
              const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
              sunMarker = new THREE.Mesh(geom, mat);
              scene.add(sunMarker);
            }

            console.log(`updateSunMarker: Showing sun marker at ${sunData.time.toUTCString()}, Az=${sunData.azimuth.toFixed(1)}¬∞, El=${sunData.elevation.toFixed(1)}¬∞`);
            sunMarker.visible = true;
            sunMarker.position.copy(sunData.position);
            return true;
          }

          function updateInfoBox() {
            let html = '';

            if (moonPositions.length && moonPositions[currentTimeIndex]) {
              const moonData = moonPositions[currentTimeIndex];
              if (moonData.elevation > 0) {
                html += `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞
                `;
              } else {
                html += `
                  <b>Moon</b><br>
                  Moon below horizon
                `;
              }
            } else {
              html += `
                <b>Moon</b><br>
                Moon below horizon
              `;
            }

            if (showSunCheckbox.checked && sunPositions.length && sunPositions[currentTimeIndex]) {
              const sunData = sunPositions[currentTimeIndex];
              html += `<br>`;
              if (sunData.elevation > 0) {
                html += `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
              } else {
                html += `
                  <b>Sun</b><br>
                  Sun below horizon
                `;
              }
            } else if (showSunCheckbox.checked) {
              html += `
                <br><b>Sun</b><br>
                Sun below horizon
              `;
            }

            infoBox.innerHTML = html;
            infoBox.style.display = 'block';
          }

          function updateTimeDisplay() {
            if (!moonPositions.length || !moonPositions[currentTimeIndex]) {
              console.log(`updateTimeDisplay: No positions at index ${currentTimeIndex}`);
              moonTimeDisplay.textContent = '--:-- UTC';
              updateInfoBox();
              return;
            }

            const time = moonPositions[currentTimeIndex].time;
            const moonVisible = moonPositions[currentTimeIndex].elevation > 0;
            const sunVisible = showSunCheckbox.checked && sunPositions[currentTimeIndex]?.elevation > 0;

            console.log(`updateTimeDisplay at ${time.toUTCString()}: moonVisible=${moonVisible}, sunVisible=${sunVisible}`);

            if (moonVisible || sunVisible) {
              const hours = String(time.getUTCHours()).padStart(2, '0');
              const minutes = String(time.getUTCMinutes()).padStart(2, '0');
              moonTimeDisplay.textContent = `${hours}:${minutes} UTC`;
            } else {
              moonTimeDisplay.textContent = '--:-- UTC';
            }
            updateInfoBox();
          }

          function updateTimeSlider() {
            timeSlider.min = 0;
            timeSlider.max = moonPositions.length - 1 || 0;
            timeSlider.value = currentTimeIndex;
            timeSlider.disabled = moonPositions.length === 0;
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeTime(index) {
            if (!moonPositions.length) return;
            currentTimeIndex = Math.max(0, Math.min(index, moonPositions.length - 1));
            updateMoonMarker();
            updateSunMarker();
            updateTimeDisplay();
          }

          function changeDate(days) {
            let currentDate = datePicker.value ? new Date(datePicker.value) : new Date();
            currentDate.setUTCDate(currentDate.getUTCDate() + days);
            const year = currentDate.getUTCFullYear();
            const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(currentDate.getUTCDate()).padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            addTrajectories(datePicker.value);
          }

          timeSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            changeTime(parseInt(e.target.value));
          });

          timeSlider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            controls.enabled = false;
            console.log('Slider touchstart: OrbitControls disabled');
          });

          timeSlider.addEventListener('touchend', (e) => {
            e.stopPropagation();
            controls.enabled = true;
            console.log('Slider touchend: OrbitControls enabled');
          });

          timeSlider.addEventListener('touchcancel', (e) => {
            e.stopPropagation();
            controls.enabled = true;
            console.log('Slider touchcancel: OrbitControls enabled');
          });

          datePicker.addEventListener('change', (e) => {
            const selectedDate = e.target.value;
            if (selectedDate) {
              addTrajectories(selectedDate);
            }
          });

          prevDateBtn.addEventListener('click', () => changeDate(-1));
          nextDateBtn.addEventListener('click', () => changeDate(1));

          showSunCheckbox.addEventListener('change', () => {
            sunTrajectoryGroup.visible = showSunCheckbox.checked;
            updateSunMarker();
            updateTimeDisplay();
            console.log(`Sun visibility toggled: ${showSunCheckbox.checked}`);
          });

          function isValidGrid(locator) {
            if (!locator || locator.length < 4 || locator.length > 6) return false;
            locator = locator.toUpperCase();
            const regex = /^[A-R]{2}[0-9]{2}([A-X]{2})?$/;
            return regex.test(locator);
          }

          gridInput.addEventListener('input', () => {
            const grid = gridInput.value;
            if (isValidGrid(grid)) {
              gridInput.style.borderColor = '#fff';
              localStorage.setItem('skyObserverGrid', grid);
              const dateVal = datePicker.value || new Date().toISOString().split('T')[0];
              addTrajectories(dateVal);
            } else {
              gridInput.style.borderColor = 'red';
            }
          });

          function maidenheadToLatLon(locator) {
            if (!locator || locator.length < 4) return null;
            locator = locator.toUpperCase();
            const A = 'A'.charCodeAt(0);
            let lon = (locator.charCodeAt(0) - A) * 20 - 180;
            let lat = (locator.charCodeAt(1) - A) * 10 - 90;
            lon += parseInt(locator[2]) * 2;
            lat += parseInt(locator[3]) * 1;
            if (locator.length >= 6) {
              lon += (locator.charCodeAt(4) - A) * 5 / 60;
              lat += (locator.charCodeAt(5) - A) * 2.5 / 60;
            }
            lon += 2.5 / 60;
            lat += 1.25 / 60;
            return { lat, lon };
          }

          const infoBox = document.createElement('div');
          infoBox.id = 'infoBox';
          document.body.appendChild(infoBox);

          function addAzimuthCompass() {
            const compassRadius = 1.05;
            const labelDistance = 1.2;
            const compassGroup = new THREE.Group();

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
              const directions = [
                { label: 'N', az: 0, color: 0xff0000 },
                { label: 'E', az: 90, color: 0xffffff },
                { label: 'S', az: 180, color: 0xffffff },
                { label: 'W', az: 270, color: 0xffffff }
              ];

              directions.forEach(dir => {
                const azRad = THREE.MathUtils.degToRad(360 - dir.az);
                const x = labelDistance * Math.sin(azRad);
                const z = labelDistance * Math.cos(azRad);
                const y = 0;

                const textGeom = new THREE.TextGeometry(dir.label, {
                  font: font,
                  size: 0.1,
                  height: 0.001
                });
                const textMat = new THREE.MeshBasicMaterial({ color: dir.color });
                const text = new THREE.Mesh(textGeom, textMat);
                text.position.set(x, y, z);
                text.lookAt(0, 0, 0);
                compassGroup.add(text);
              });

              const ringGeom = new THREE.RingGeometry(compassRadius - 0.002, compassRadius + 0.002, 256);
              const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
              });
              const ring = new THREE.Mesh(ringGeom, ringMat);
              ring.rotation.x = -Math.PI / 2;
              ring.position.y = 0;
              compassGroup.add(ring);

              for (let i = 0; i < 360; i += 10) {
                const angle = THREE.MathUtils.degToRad(360 - i);
                const isMajor = i % 30 === 0;
                const outer = compassRadius + 0.02;
                const inner = compassRadius - (isMajor ? 0.05 : 0.02);

                const x1 = inner * Math.cos(angle);
                const z1 = inner * Math.sin(angle);
                const x2 = outer * Math.cos(angle);
                const z2 = outer * Math.cos(angle);

                const tickGeom = new THREE.BufferGeometry().setFromPoints([
                  new THREE.Vector3(x1, 0, z1),
                  new THREE.Vector3(x2, 0, z2)
                ]);
                const tickMat = new THREE.LineBasicMaterial({
                  color: 0xffffff,
                  transparent: true,
                  opacity: isMajor ? 1.0 : 0.5
                });
                const tick = new THREE.Line(tickGeom, tickMat);
                compassGroup.add(tick);

                if (isMajor && ![0, 90, 180, 270].includes(i)) {
                  const labelDist = compassRadius + 0.1;
                  const lx = labelDist * Math.sin(angle);
                  const lz = labelDist * Math.cos(angle);

                  const degGeom = new THREE.TextGeometry(i.toString(), {
                    font: font,
                    size: 0.045,
                    height: 0.001
                  });
                  const degMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                  const label = new THREE.Mesh(degGeom, degMat);
                  label.position.set(lx, 0, lz);
                  label.lookAt(0, 0, 0);
                  label.rotation.y += Math.PI;
                  compassGroup.add(label);
                }
              }

              scene.add(compassGroup);
              console.log(`Compass added, children: ${compassGroup.children.length}`);
            }, undefined, (error) => {
              console.error('Font loading failed:', error);
            });
          }

          function addTrajectories(selectedDate) {
            // Fallback if Astronomy is not available
            if (typeof Astronomy === 'undefined') {
              console.error('Astronomy library not loaded');
              errorMessage.textContent = 'Astronomy data unavailable. Please check your network or try a different browser.';
              errorMessage.style.display = 'block';
              return;
            }

            const grid = gridInput.value || 'JO89tt';
            const coords = maidenheadToLatLon(grid);
            if (!coords) {
              gridInput.style.borderColor = 'red';
              gridInput.value = 'JO89tt';
              localStorage.setItem('skyObserverGrid', 'JO89tt');
              return addTrajectories(selectedDate);
            }
            const lat = coords.lat;
            const lon = coords.lon;

            const observer = new Astronomy.Observer(lat, lon, 0);

            const date = selectedDate ? new Date(selectedDate) : new Date();
            const startOfDay = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
            const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);

            moonTrajectoryGroup.clear();
            sunTrajectoryGroup.clear();
            if (moonMarker) scene.remove(moonMarker);
            if (sunMarker) scene.remove(sunMarker);
            moonMarker = null;
            sunMarker = null;
            moonPositions = [];
            sunPositions = [];
            currentTimeIndex = 0;

            let moonSegment = [];
            let sunSegment = [];
            const moonSegments = [];
            const sunSegments = [];

            let firstMoonVisibleIndex = -1;
            let firstSunVisibleIndex = -1;

            for (let minutes = 0; minutes < 1440; minutes += 10) {
              const time = new Date(startOfDay.getTime() + minutes * 60 * 1000);

              if (time >= endOfDay) break;

              const moonEq = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, false);
              const moonHor = Astronomy.Horizon(time, observer, moonEq.ra, moonEq.dec, 'normal');
              const moonElevationDeg = moonHor.altitude;
              const moonAzimuthDeg = moonHor.azimuth;

              const azRadMoon = THREE.MathUtils.degToRad(360 - moonAzimuthDeg);
              const elRadMoon = THREE.MathUtils.degToRad(Math.max(moonElevationDeg, 0));
              const r = 1;
              const xMoon = r * Math.cos(elRadMoon) * Math.sin(azRadMoon);
              const yMoon = r * Math.sin(elRadMoon);
              const zMoon = r * Math.cos(elRadMoon) * Math.cos(azRadMoon);
              const moonPoint = new THREE.Vector3(xMoon, yMoon, zMoon);

              if (moonElevationDeg > 0) {
                moonSegment.push(moonPoint);
                if (firstMoonVisibleIndex === -1) firstMoonVisibleIndex = minutes / 10;
              } else {
                if (moonSegment.length > 1) moonSegments.push(moonSegment);
                moonSegment = [];
              }
              moonPositions.push({ time, position: moonPoint, azimuth: moonAzimuthDeg, elevation: moonElevationDeg });

              const sunEq = Astronomy.Equator(Astronomy.Body.Sun, time, observer, true, false);
              const sunHor = Astronomy.Horizon(time, observer, sunEq.ra, sunEq.dec, 'normal');
              const sunElevationDeg = sunHor.altitude;
              const sunAzimuthDeg = sunHor.azimuth;

              const azRadSun = THREE.MathUtils.degToRad(360 - sunAzimuthDeg);
              const elRadSun = THREE.MathUtils.degToRad(Math.max(sunElevationDeg, 0));
              const xSun = r * Math.cos(elRadSun) * Math.sin(azRadSun);
              const ySun = r * Math.sin(elRadSun);
              const zSun = r * Math.cos(elRadSun) * Math.cos(azRadSun);
              const sunPoint = new THREE.Vector3(xSun, ySun, zSun);

              if (sunElevationDeg > 0) {
                sunSegment.push(sunPoint);
                if (firstSunVisibleIndex === -1) firstSunVisibleIndex = minutes / 10;
              } else {
                if (sunSegment.length > 1) sunSegments.push(sunSegment);
                sunSegment = [];
              }
              sunPositions.push({ time, position: sunPoint, azimuth: sunAzimuthDeg, elevation: sunElevationDeg });

              if (minutes === 720 || minutes === 1030 || minutes === 1140) {
                console.log(`At ${time.toUTCString()}:`);
                console.log(`  Moon: Az=${moonAzimuthDeg.toFixed(1)}¬∞, El=${moonElevationDeg.toFixed(1)}¬∞`);
                console.log(`  Sun: Az=${sunAzimuthDeg.toFixed(1)}¬∞, El=${sunElevationDeg.toFixed(1)}¬∞`);
              }
            }

            if (moonSegment.length > 1) moonSegments.push(moonSegment);
            if (sunSegment.length > 1) sunSegments.push(sunSegment);

            moonSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isMoonTrajectory: true };
              moonTrajectoryGroup.add(line);
            });

            sunSegments.forEach(seg => {
              const geom = new THREE.BufferGeometry().setFromPoints(seg);
              const mat = new THREE.LineBasicMaterial({ color: 0xffa500 });
              const line = new THREE.Line(geom, mat);
              line.userData = { isSunTrajectory: true };
              sunTrajectoryGroup.add(line);
            });

            sunTrajectoryGroup.visible = showSunCheckbox.checked;

            if (firstMoonVisibleIndex !== -1) {
              currentTimeIndex = firstMoonVisibleIndex;
            } else if (showSunCheckbox.checked && firstSunVisibleIndex !== -1) {
              currentTimeIndex = firstSunVisibleIndex;
            } else {
              currentTimeIndex = 72;
            }
            console.log(`addTrajectories: moonSegments=${moonSegments.length}, sunSegments=${sunSegments.length}, currentTimeIndex=${currentTimeIndex}`);
            updateTimeSlider();
          }

          window.addTrajectories = addTrajectories;

          function parseCsvData(csvText, csvSource) {
            Papa.parse(csvText, {
              header: true;
              delimiter: ";",
              complete: function (results) {
                rawPoints.length = 0;
                spheres.forEach(s => scene.remove(s));
                spheres.length = 0;
                minNoise = Infinity;
                maxNoise = -Infinity;

                results.data.forEach(row => {
                  if (!row.Valid || row.Valid !== "True") return;

                  const az = parseFloat(row.Azimuth?.replace(",", "."));
                  const el = parseFloat(row.Elevation?.replace(",", "."));
                  const noise = parseFloat(row.Noise?.replace(",", "."));

                  if (isNaN(az) || isNaN(el) || isNaN(noise)) return;

                  minNoise = Math.min(minNoise, noise);
                  maxNoise = Math.max(maxNoise, noise);

                  rawPoints.push({ az, el, noise });
                });

                rawPoints.forEach(point => {
                  const azRad = THREE.MathUtils.degToRad(360 - point.az);
                  const elRad = THREE.MathUtils.degToRad(point.el);
                  const r = 1;

                  const x = r * Math.cos(elRad) * Math.sin(azRad);
                  const y = r * Math.sin(elRad);
                  const z = r * Math.cos(elRad) * Math.cos(azRad);

                  const geometry = new THREE.SphereGeometry(0.015, 8, 8);
                  const material = new THREE.MeshBasicMaterial({ color: getColor(point.noise) });

                  const sphere = new THREE.Mesh(geometry, material);
                  sphere.position.set(x, y, z);

                  sphere.userData = {
                    azimuth: point.az,
                    elevation: point.el,
                    noise: point.noise
                  };

                  spheres.push(sphere);
                  scene.add(sphere);
                });

                const boundingBox = new THREE.Box3();
                spheres.forEach(s => boundingBox.expandByPoint(s.position));

                const center = new THREE.Vector3();
                boundingBox.getCenter(center);

                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 2;

                let avgPosition = new THREE.Vector3();
                spheres.forEach(s => avgPosition.add(s.position));
                avgPosition.divideScalar(spheres.length);

                const directionToData = avgPosition.clone().normalize();
                const distance = maxDim * 2;
                camera.position.copy(directionToData.clone().multiplyScalar(distance));
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
                addAzimuthCompass();
                updateTimeDisplay();

                if (csvSource === 'demo') {
                  demoStatus.textContent = 'Demo loaded!';
                  demoStatus.style.display = 'block';
                } else if (csvSource === 'stored') {
                  demoStatus.textContent = 'Stored CSV loaded';
                  demoStatus.style.display = 'block';
                } else {
                  demoStatus.style.display = 'none';
                }
                console.log(`parseCsvData: Spheres added=${spheres.length}`);
              }
            });
          }

          const storedGrid = localStorage.getItem('skyObserverGrid');
          if (storedGrid && isValidGrid(storedGrid)) {
            gridInput.value = storedGrid;
            gridInput.style.borderColor = '#fff';
          } else {
            gridInput.value = 'JO89tt';
            localStorage.setItem('skyObserverGrid', 'JO89tt');
          }

          const storedCsv = localStorage.getItem('skyObserverCsv');
          if (storedCsv) {
            parseCsvData(storedCsv, 'stored');
          } else {
            fetch('2025-05-29_20.44.04.csv')
              .then(response => response.text())
              .then(csv => parseCsvData(csv, 'demo'))
              .catch(error => {
                console.error('Error loading demo CSV:', error);
                addAzimuthCompass();
                addTrajectories();
              });
          }

          document.getElementById('csvUpload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (event) {
              const csvText = event.target.result;
              localStorage.setItem('skyObserverCsv', csvText);
              parseCsvData(csvText, 'uploaded');
            };
            reader.readAsText(file);
          });

          window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          window.addEventListener('touchend', (event) => {
            const touch = event.changedTouches[0];
            if (!touch) return;

            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...spheres, moonMarker, sunMarker].filter(obj => obj !== null));

            if (intersects.length > 0) {
              const clickedObject = intersects[0].object;

              if (clickedObject === moonMarker && moonPositions[currentTimeIndex] && moonPositions[currentTimeIndex].elevation > 0) {
                const moonData = moonPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Moon</b><br>
                  Az: ${moonData.azimuth.toFixed(1)}¬∞ El: ${moonData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject === sunMarker && showSunCheckbox.checked && sunPositions[currentTimeIndex] && sunPositions[currentTimeIndex].elevation > 0) {
                const sunData = sunPositions[currentTimeIndex];
                infoBox.innerHTML = `
                  <b>Sun</b><br>
                  Az: ${sunData.azimuth.toFixed(1)}¬∞ El: ${sunData.elevation.toFixed(1)}¬∞
                `;
                infoBox.style.display = 'block';
              } else if (clickedObject.userData.noise !== undefined) {
                const { azimuth, elevation, noise } = clickedObject.userData;
                infoBox.innerHTML = `
                  <b>Measurement</b><br>
                  Az: ${azimuth.toFixed(1)}¬∞ El: ${elevation.toFixed(1)}¬∞<br>
                  Noise: ${noise.toFixed(2)} dB
                `;
                infoBox.style.display = 'block';
              }
            } else {
              updateInfoBox();
            }
          });

          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }

          // Initialize with error handling
          try {
            const today = new Date();
            const year = today.getUTCFullYear();
            const month = String(today.getUTCMonth() + 1).padStart(2, '0');
            const day = String(today.getUTCDate()).padStart(2, '0');
            datePicker.value = `${year}-${month}-${day}`;
            addTrajectories();
            handleResize(); // Initial resize
            animate();
          } catch (e) {
            console.error('Initialization failed:', e);
            errorMessage.textContent = 'Failed to initialize Sky Observer. Please try a different browser or device.';
            errorMessage.style.display = 'block';
          }
        </script>
    </body>
</html>
