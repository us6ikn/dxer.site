<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Ephemeris Overview for 2026</title>
    <script src="https://dxer.site/eme-observer/a.ob.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; font-size: 16px; font-weight: bold; color: black; }
        .chart-container { position: relative; margin-bottom: 20px; width: 800px; height: 300px; }
        .y-label-left { position: absolute; left: 10px; top: 10px; color: #fa4d56; font-weight: bold; font-size: 12px; }
        .y-label-right { position: absolute; right: 10px; top: 10px; color: #1192e8; font-weight: bold; font-size: 12px; }
        .we-label { position: absolute; left: -20px; top: 30px; color: black; font-size: 10px; }
        #explanation { margin-top: 20px; font-size: 12px; }
        #explanation p { margin: 5px 0; }
        #explanation span { font-size: 14px; margin-right: 5px; }
    </style>
</head>
<body>
    <h1>MOON EPHEMERIS OVERVIEW FOR THE YEAR 2026, by SA5IKN</h1>
    <div class="chart-container">
        <span class="y-label-left">Declination (°)</span>
        <span class="y-label-right">Extra-Loss (dB)</span>
        <span class="we-label">WE:</span>
        <canvas id="chart1"></canvas>
    </div>
    <div class="chart-container">
        <span class="y-label-left">Declination (°)</span>
        <span class="y-label-right">Extra-Loss (dB)</span>
        <span class="we-label">WE:</span>
        <canvas id="chart2"></canvas>
    </div>
    <div class="chart-container">
        <span class="y-label-left">Declination (°)</span>
        <span class="y-label-right">Extra-Loss (dB)</span>
        <span class="we-label">WE:</span>
        <canvas id="chart3"></canvas>
    </div>
    <div class="chart-container">
        <span class="y-label-left">Declination (°)</span>
        <span class="y-label-right">Extra-Loss (dB)</span>
        <span class="we-label">WE:</span>
        <canvas id="chart4"></canvas>
    </div>
    <div id="explanation">
        <h3>Explanation:</h3>
        <p><span style="color: grey;">■</span> Vertical grey bars show the days where the sky temp is high and could degrade the system temperature.</p>
        <p><span style="color: orange;">■</span> Vertical orange bars show the days where the moon is close to the sun (&lt;10°), near the new moon dates.</p>
        <p><span style="color: #1192e8;">―</span> Extra-loss is the additional range loss in dB compared to the minimum pathloss at Moon perigee.</p>
        <p><span style="color: #fa4d56;">―</span> The declination is plotted as red curve and weekends (WE) are marked at the top of the ephemeris graph.</p>
    </div>
    <script>
        // Register the annotation plugin
        if (typeof annotationPlugin !== 'undefined') {
            Chart.register(annotationPlugin);
        }

        const YEAR = 2026;
        const PERIGEE_DISTANCE_KM = 356352.93;
        const COLOR_DECLINATION = '#fa4d56';
        const COLOR_LOSS = '#1192e8';
        const GC_RA_HOURS = 17 + 45/60 + 40/3600; // Galactic Center RA in hours
        const GC_DEC = -(29 + 0/60 + 28/3600); // Galactic Center Dec in degrees

        const quarters = [
            { start: new Date(Date.UTC(YEAR, 0, 1)), end: new Date(Date.UTC(YEAR, 3, 1)) },
            { start: new Date(Date.UTC(YEAR, 3, 1)), end: new Date(Date.UTC(YEAR, 6, 1)) },
            { start: new Date(Date.UTC(YEAR, 6, 1)), end: new Date(Date.UTC(YEAR, 9, 1)) },
            { start: new Date(Date.UTC(YEAR, 9, 1)), end: new Date(Date.UTC(YEAR + 1, 0, 1)) }
        ];

        // Function to compute angular separation between two equatorial coordinates
        function angularSeparation(ra1, dec1, ra2, dec2) {
            const ra1Rad = ra1 * Math.PI / 12; // Convert hours to radians
            const dec1Rad = dec1 * Math.PI / 180; // Convert degrees to radians
            const ra2Rad = ra2 * Math.PI / 12;
            const dec2Rad = dec2 * Math.PI / 180;

            const cosSep = Math.sin(dec1Rad) * Math.sin(dec2Rad) +
                           Math.cos(dec1Rad) * Math.cos(dec2Rad) * Math.cos(ra1Rad - ra2Rad);
            const sepRad = Math.acos(Math.min(Math.max(cosSep, -1), 1));
            return sepRad * 180 / Math.PI; // Convert to degrees
        }

        function computeMoonData(start, end) {
            const data = [];
            const observer = new Astronomy.Observer(0, 0, 0); // Observer at origin
            for (let dt = new Date(start); dt < end; dt.setUTCDate(dt.getUTCDate() + 1)) {
                try {
                    const astroTime = Astronomy.MakeTime(dt);
                    const libration = Astronomy.Libration(astroTime);
                    const dist_km = libration.dist_km;
                    const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, observer, true, true);
                    const sunEq = Astronomy.Equator(Astronomy.Body.Sun, astroTime, observer, true, true);
                    const dec = moonEq.dec;
                    const moon_ra = moonEq.ra; // RA in hours
                    const extra_loss = 40 * Math.log10(dist_km / PERIGEE_DISTANCE_KM);
                    const sun_sep = Astronomy.AngleFromSun(Astronomy.Body.Moon, astroTime);
                    const gc_sep = angularSeparation(moon_ra, dec, GC_RA_HOURS, GC_DEC);

                    if (dist_km != null && dec != null && sun_sep != null && gc_sep != null) {
                        data.push({
                            date: new Date(dt),
                            dateStr: dt.toISOString().slice(0, 10),
                            dec,
                            dist: dist_km,
                            extra_loss,
                            sun_sep,
                            gc_sep
                        });
                    } else {
                        console.warn(`Missing data for ${dt.toISOString().slice(0, 10)}`);
                    }
                } catch (e) {
                    console.warn(`Error computing data for ${dt.toISOString().slice(0, 10)}: ${e.message}`);
                }
            }
            return data;
        }

        function createAnnotations(data, start, end) {
            const annotations = [];

            // Orange bars: Moon-Sun <10°
            let is_close_sun = data.map(d => d.sun_sep < 10);
            let startIdx = null;
            for (let i = 0; i < data.length; i++) {
                if (is_close_sun[i] && startIdx === null) {
                    startIdx = i;
                } else if (!is_close_sun[i] && startIdx !== null) {
                    const barStart = data[startIdx].date;
                    const barEnd = new Date(data[i - 1].date);
                    barEnd.setUTCDate(barEnd.getUTCDate() + 1);
                    annotations.push({
                        type: 'box',
                        xMin: barStart,
                        xMax: barEnd,
                        yMin: -30,
                        yMax: 30,
                        backgroundColor: 'rgba(255, 165, 0, 0.4)',
                        borderWidth: 0
                    });
                    startIdx = null;
                }
            }
            if (startIdx !== null) {
                const barStart = data[startIdx].date;
                const barEnd = new Date(data[data.length - 1].date);
                barEnd.setUTCDate(barEnd.getUTCDate() + 1);
                annotations.push({
                    type: 'box',
                    xMin: barStart,
                    xMax: barEnd,
                    yMin: -30,
                    yMax: 30,
                    backgroundColor: 'rgba(255, 165, 0, 0.4)',
                    borderWidth: 0
                });
            }

            // Grey bars: Moon-GC <10°
            let is_high_temp = data.map(d => d.gc_sep < 10);
            startIdx = null;
            for (let i = 0; i < data.length; i++) {
                if (is_high_temp[i] && startIdx === null) {
                    startIdx = i;
                } else if (!is_high_temp[i] && startIdx !== null) {
                    const barStart = data[startIdx].date;
                    const barEnd = new Date(data[i - 1].date);
                    barEnd.setUTCDate(barEnd.getUTCDate() + 1);
                    annotations.push({
                        type: 'box',
                        xMin: barStart,
                        xMax: barEnd,
                        yMin: -30,
                        yMax: 30,
                        backgroundColor: 'rgba(128, 128, 128, 0.4)',
                        borderWidth: 0
                    });
                    startIdx = null;
                }
            }
            if (startIdx !== null) {
                const barStart = data[startIdx].date;
                const barEnd = new Date(data[data.length - 1].date);
                barEnd.setUTCDate(barEnd.getUTCDate() + 1);
                annotations.push({
                    type: 'box',
                    xMin: barStart,
                    xMax: barEnd,
                    yMin: -30,
                    yMax: 30,
                    backgroundColor: 'rgba(128, 128, 128, 0.4)',
                    borderWidth: 0
                });
            }

            // Month separators and labels
            let month_start = new Date(start.getUTCFullYear(), start.getUTCMonth(), 1);
            while (month_start < end) {
                annotations.push({
                    type: 'line',
                    xMin: month_start,
                    xMax: month_start,
                    borderColor: 'gray',
                    borderWidth: 1.5
                });
                const ndays = new Date(month_start.getUTCFullYear(), month_start.getUTCMonth() + 1, 0).getUTCDate();
                const mid_month = new Date(month_start);
                mid_month.setUTCDate(Math.floor(ndays / 2));
                annotations.push({
                    type: 'label',
                    xValue: mid_month,
                    yValue: 38,
                    content: month_start.toLocaleString('default', { month: 'long' }),
                    font: { size: 8, weight: 'bold' },
                    color: 'black'
                });
                month_start.setUTCMonth(month_start.getUTCMonth() + 1);
            }

            // Weekend dashed lines and labels
            let current = new Date(start);
            while (current < end) {
                const wd = current.getUTCDay();
                if (wd === 0 || wd === 6) {
                    annotations.push({
                        type: 'line',
                        xMin: current,
                        xMax: current,
                        borderColor: 'rgba(128, 128, 128, 0.7)',
                        borderWidth: 0.8,
                        borderDash: [5, 5]
                    });
                    if (wd === 6) {
                        const sunday = new Date(current);
                        sunday.setUTCDate(sunday.getUTCDate() + 1);
                        const label = `${current.getUTCDate()}/${sunday.getUTCDate()}`;
                        const mid = new Date(current);
                        mid.setUTCHours(12);
                        annotations.push({
                            type: 'label',
                            xValue: mid,
                            yValue: 33,
                            content: label,
                            font: { size: 8 },
                            color: 'black'
                        });
                    }
                }
                current.setUTCDate(current.getUTCDate() + 1);
            }

            return annotations;
        }

        quarters.forEach((quarter, index) => {
            const data = computeMoonData(quarter.start, quarter.end);
            if (!data || data.length === 0) {
                console.warn(`No data for quarter ${index + 1}`);
                return;
            }
            const annotations = createAnnotations(data, quarter.start, quarter.end);
            const ctx = document.getElementById(`chart${index + 1}`).getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Declination',
                            data: data.map(d => ({ x: d.date, y: d.dec })),
                            borderColor: COLOR_DECLINATION,
                            borderWidth: 1.5,
                            pointRadius: 0,
                            yAxisID: 'yDec'
                        },
                        {
                            label: 'Extra Loss',
                            data: data.map(d => ({ x: d.date, y: d.extra_loss })),
                            borderColor: COLOR_LOSS,
                            borderWidth: 1.5,
                            pointRadius: 0,
                            yAxisID: 'yLoss'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                parser: 'yyyy-MM-dd', // Ensures dates are parsed correctly
                                displayFormats: { day: 'MMM d' }
                            },
                            min: quarter.start,
                            max: quarter.end,
                            position: 'top',
                            ticks: { display: false },
                            grid: { display: false },
                            border: { display: true, color: 'rgba(128, 128, 128, 0.9)', width: 1.2 }
                        },
                        yDec: {
                            min: -30,
                            max: 30,
                            position: 'left',
                            ticks: { color: COLOR_DECLINATION, font: { size: 9 } },
                            grid: { display: true, color: 'rgba(0, 0, 0, 0.3)', borderDash: [2, 2], drawBorder: false },
                            border: { display: true, color: COLOR_DECLINATION, width: 1.2 }
                        },
                        yLoss: {
                            min: 0,
                            max: 2.4,
                            position: 'right',
                            ticks: { color: COLOR_LOSS, font: { size: 9 } },
                            grid: { display: false, drawBorder: false },
                            border: { display: true, color: COLOR_LOSS, width: 1.2 }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (contexts) => {
                                    return data[contexts[0].dataIndex].dateStr;
                                },
                                label: () => '',
                                afterBody: (contexts) => {
                                    const idx = contexts[0].dataIndex;
                                    const d = data[idx];
                                    return [
                                        `Declination: ${d.dec.toFixed(2)}°`,
                                        `Extra Loss: ${d.extra_loss.toFixed(2)} dB`,
                                        `Distance: ${d.dist.toFixed(0)} km`,
                                        `Moon-Sun Sep: ${d.sun_sep.toFixed(2)}°`,
                                        `Moon-GC Sep: ${d.gc_sep.toFixed(2)}°`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            clip: false,
                            annotations: annotations
                        }
                    },
                    layout: {
                        padding: {
                            top: 50,
                            bottom: 10,
                            left: 20,
                            right: 20
                        }
                    },
                    elements: {
                        line: {
                            tension: 0
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
