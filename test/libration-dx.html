<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EME Libration Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="astronomy.browser.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #chartWrapper, #dxChartWrapper, #moonChartWrapper {
      display: none;
    }
    #moonChartWrapper {
      width: 100%;
      height: 180px;
      margin-top: 6px;
      background-color: rgba(255, 255, 255, 0.85);
      border-radius: 6px;
      box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      position: relative;
      box-sizing: border-box;
    }
    #moonDistanceChart {
      width: 100%;
      max-width: 100%;
      height: calc(100% - 40px);
      box-sizing: border-box;
      padding-bottom: 20px;
    }
    #map {
      height: 100dvh;
      width: 100%;
      z-index: 0;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 5;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 12px;
      border-radius: 8px;
      max-width: 90vw;
      box-sizing: border-box;
      overflow: auto;
      max-height: 90vh;
      max-width: 95vw;
    }
    label {
      font-weight: bold;
      font-size: 14px;
    }
    #hour-value {
      margin-left: 10px;
      font-weight: normal;
    }
    #hour {
      width: 100%;
      margin-top: 5px;
      -webkit-appearance: none;
      appearance: none;
      height: 10px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 5px;
      outline: none;
      transition: background 0.3s ease;
      padding: 0;
    }
    #hour::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #007bff;
      border-radius: 50%;
      cursor: pointer;
    }
    #hour::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #007bff;
      border-radius: 50%;
      cursor: pointer;
    }
    #hour:active {
      background: rgba(0, 123, 255, 0.5);
    }
    #hour-container {
      position: relative;
      width: 100%;
      height: 40px;
      margin-top: 10px;
      padding: 5px 0;
    }
    #date-container {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }
    input[type="date"] {
      width: auto;
      max-width: 200px;
    }
    .app-name-wrapper {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      position: relative;
    }
    .creator-label {
      font-size: 10px;
      color: #555;
      font-style: italic;
      margin-bottom: -4px;
    }
    .app-name {
      font-size: 1.0rem;
      font-weight: bold;
      color: #2c3e50;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .ghz-label {
      font-size: 10px;
      font-weight: bold;
      color: #2c3e50;
      margin-top: -4px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <div id="date-container">
      <div class="app-name-wrapper">
        <div class="creator-label">by SA5IKN</div>
        <div class="app-name">EME Observer</div>
        <div class="ghz-label">10GHz</div>
      </div>
      <button id="prevDay">←</button>
      <input type="date" id="date" />
      <button id="nextDay">→</button>
      <span id="hour-value">Time (UTC): 00:00</span>
    </div>
    <input type="range" id="hour" min="0" max="47" value="0" step="1" />
    <label for="qth">My Locator:</label>
    <input type="text" id="qth" maxlength="6" size="11" placeholder="e.g. JO89tt" />
    <label for="dx">DX Locator:</label>
    <input type="text" id="dx" maxlength="6" size="11" placeholder="e.g. JO88xx" />
    <div id="chartWrapper" style="display: none;">
      <div id="chartLabel" style="text-align: center; margin-bottom: 0px; font-weight: normal; font-size: 12px;"></div>
      <canvas id="declinationChart"></canvas>
    </div>
    <div id="dxChartWrapper" style="display: none;">
      <div id="dxchartLabel" style="text-align: center; margin-bottom: 0px; font-weight: normal; font-size: 12px;"></div>
      <canvas id="dxDeclinationChart"></canvas>
    </div>
    <div id="moonChartWrapper" style="display: block;">
      <div id="moonChartLabel" style="text-align: center; margin-bottom: 0px; font-weight: normal; font-size: 12px;"></div>
      <canvas id="moonDistanceChart"></canvas>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>

  <script>
      let chart;
      let dxChart;
      let moonChart;
      let rawData = [];
      let dxRawData = [];
      let moonDataForMonth = [];
      let hourIndex = 0;
      let lat = 0;
      let lon = 0;
      let dxLat = 0;
      let dxLon = 0;
      let moonMarker;
      let footprintCircle;
      let currentInfoWindow = null;
      let map;

      const MOON_RADIUS = 1.7374e6; // meters
      const SPEED_OF_LIGHT = 299792458; // m/s
      const FREQUENCY_HZ = 10.368e9; // 10.368 GHz
      
      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 2,
          center: { lat: 0, lng: 0 },
          mapTypeId: 'terrain',
          gestureHandling: 'greedy',
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false
        });

        fetch('output_2_10GHz_with_DXCC.json') // Corrected filename
          .then(response => response.json())
          .then(data => {
            data.forEach(station => {
              const { Call: callsign, Locator: locator, Antenna: antenna, Power: power, Website: website, Coordinates } = station;
              const [latStr, lngStr] = Coordinates.split(',');
              const lat = parseFloat(latStr);
              const lng = parseFloat(lngStr);
              if (isNaN(lat) || isNaN(lng)) return;

              const offsetLat = 0.1;
              const offsetLng = 0.1;
              const markerPosition = {
                lat: lat + (offsetLat / 10000),
                lng: lng + (offsetLng / 10000)
              };
              
              const marker = new google.maps.Marker({
                        position: markerPosition,
                        map: map,
                        icon: {
                          url: "https://dxer.site/img/m_30.png",
                          scaledSize: new google.maps.Size(20, 20)
                        },
                        title: callsign
                      });
              
              const infoContent = `
                        <div>
                          <div style="font-weight:bold; font-size: 16px;">${callsign}</div>
                          <div>Locator: ${locator}</div>
                          <div>Antenna: ${antenna}</div>
                          <div>Power: ${power}</div>
                          <div>Website: <a href="${website}" target="_blank">${website}</a></div>
                          <div><a href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ.com lookup</a></div>
                          <div id="image-container-${callsign}">
                            Station Picture (clickable):<br>
                            <a href="https://dxer.site/db/${callsign}.jpg" target="_blank">
                              <img id="station-image-${callsign}"
                                   src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA"
                                   alt="${callsign} station"/>
                            </a>
                            <div id="image-placeholder-${callsign}" style="display:none;">
                              <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                            </div>
                          </div>
                        </div>
                      `;

                      const infoWindow = new google.maps.InfoWindow({ content: infoContent });
                      
                      marker.addListener('click', () => {
                                if (currentInfoWindow) {
                                  currentInfoWindow.close();
                                }
                                infoWindow.open(map, marker);
                                currentInfoWindow = infoWindow;

                                setTimeout(() => {
                                  const imageElement = document.getElementById(`station-image-${callsign}`);
                                  const placeholder = document.getElementById(`image-placeholder-${callsign}`);
                                  const imageUrl = `https://dxer.site/db/${callsign}_thumb.jpg`;
                                  fetch(imageUrl, { method: 'HEAD' })
                                    .then(response => {
                                      if (!response.ok) {
                                        imageElement.remove();
                                        placeholder.style.display = 'block';
                                      } else {
                                        imageElement.src = imageUrl;
                                        placeholder.style.display = 'none';
                                      }
                                    })
                                    .catch(() => {
                                      imageElement.remove();
                                      placeholder.style.display = 'block';
                                    });
                                }, 100);
                              });
                            });
                          })
                          .catch(() => { /* Handle error silently */ });
                          
                          fetch('output_2_10GHz_SK_with_DXCC.json')
                              .then(response => response.json())
                              .then(data => {
                                data.forEach(station => {
                                  const { Call: callsign, Locator: locator, Antenna: antenna, Power: power, Website: website, Coordinates } = station;
                                  const { lat, lng } = parseCoordinates(Coordinates);
                                  if (isNaN(lat) || isNaN(lng)) return;

                                  const markerPosition = {
                                    lat: lat + (0.1 / 10000),
                                    lng: lng + (0.1 / 10000)
                                  };

                                  const marker = new google.maps.Marker({
                                    position: markerPosition,
                                    map: map,
                                    icon: {
                                      url: "https://dxer.site/img/notworked.png",
                                      scaledSize: new google.maps.Size(20, 20)
                                    },
                                    title: callsign
                                  });
                                  const infoContent = `
                                            <div>
                                              <div style="font-weight:bold; font-size: 16px;">${callsign} (SK)</div>
                                              <div>Locator: ${locator}</div>
                                              <div>Antenna: ${antenna}</div>
                                              <div>Power: ${power}</div>
                                              <div>Website: <a href="${website}" target="_blank">${website}</a></div>
                                              <div><a href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ.com lookup</a></div>
                                              <div id="image-container-${callsign}">
                                                Station Picture (clickable):<br>
                                                <a href="https://dxer.site/db/${callsign}.jpg" target="_blank">
                                                  <img id="station-image-${callsign}"
                                                       src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA"
                                                       alt="${callsign} station"/>
                                                </a>
                                                <div id="image-placeholder-${callsign}" style="display:none;">
                                                  <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                                                </div>
                                              </div>
                                            </div>
                                          `;

                                          const infoWindow = new google.maps.InfoWindow({ content: infoContent });

                                          marker.addListener('click', () => {
                                                    if (currentInfoWindow) {
                                                      currentInfoWindow.close();
                                                    }
                                                    infoWindow.open(map, marker);
                                                    currentInfoWindow = infoWindow;

                                                    setTimeout(() => {
                                                      const imageElement = document.getElementById(`station-image-${callsign}`);
                                                      const placeholder = document.getElementById(`image-placeholder-${callsign}`);
                                                      const imageUrl = `https://dxer.site/db/${callsign}_thumb.jpg`;
                                                      fetch(imageUrl, { method: 'HEAD' })
                                                        .then(response => {
                                                          if (!response.ok) {
                                                            imageElement.remove();
                                                            placeholder.style.display = 'block';
                                                          } else {
                                                            imageElement.src = imageUrl;
                                                            placeholder.style.display = 'none';
                                                          }
                                                        })
                                                        .catch(() => {
                                                          imageElement.remove();
                                                          placeholder.style.display = 'block';
                                                        });
                                                    }, 100);
                                                  });
                                                });
                                              })
                                              .catch(() => { /* Handle error silently */ });
                                              
                                              fetch('moon_data.json')
                                                  .then(response => response.json())
                                                  .then(data => {
                                                    window.moonData = data;
                                                    updateMap();
                                                    updateMoonChart(); // Initialize Moon chart on page load
                                                  })
                                                  .catch(() => { /* Handle error silently */ });
                                              }
      function parseCoordinates(coordinates) {
        const [latStr, lngStr] = coordinates.split(',');
        return {
          lat: parseFloat(latStr),
          lng: parseFloat(lngStr)
        };
      }

      function updateMap() {
        const selectedDate = document.getElementById('date').value;
        const index = parseInt(document.getElementById('hour').value);
        const hour = Math.floor(index / 2).toString().padStart(2, '0');
        const minutes = index % 2 === 0 ? '00' : '30';
        const utcTimeString = `${selectedDate} ${hour}:${minutes}:00`;

        if (!window.moonData) return;

        const moonData = window.moonData.find(entry => entry.t === utcTimeString);
        if (!moonData) return;

        const lat = parseFloat(moonData.p);
        const lon = parseFloat(moonData.m);
        const radius = parseFloat(moonData.r) * 1000; // Convert km to meters

        if (isNaN(lat) || isNaN(lon) || isNaN(radius)) return;

        if (moonMarker) moonMarker.setMap(null);
        if (footprintCircle) footprintCircle.setMap(null);

        moonMarker = new google.maps.Marker({
          position: { lat, lng: lon },
          map: map,
          icon: {
            url: 'https://dxer.site/img/moon-icon.png',
            scaledSize: new google.maps.Size(48, 48)
          },
          title: 'Moon Sublunar Point'
        });

        footprintCircle = new google.maps.Circle({
          map: map,
          center: { lat, lng: lon },
          radius: radius,
          fillColor: '#0088FF',
          fillOpacity: 0.3,
          strokeColor: '#0000FF',
          strokeOpacity: 0.6,
          strokeWeight: 2
        });
      }

      function calculateMoonDataForMonth(dateStr) {
        const startDate = new Date(dateStr);
        startDate.setUTCDate(1); // Start from the 1st of the month
        const endDate = new Date(startDate);
        endDate.setUTCDate(endDate.getUTCDate() + 30); // Cover 30 days

        const data = [];
        const labels = [];

        for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
          try {
            const dateString = dt.toISOString().slice(0, 10);
            const time = `${dateString}T00:00:00Z`;
            const astroTime = Astronomy.MakeTime(new Date(time));
            const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, null, true, true);
            const geoMoon = Astronomy.GeoMoon(astroTime);
            const distanceKm = geoMoon ? geoMoon.dist : null;
            const declination = moonEq ? moonEq.dec : null;
            if (distanceKm !== null && declination !== null) {
              data.push({
                date: dateString,
                distance: distanceKm,
                declination: declination
              });
              labels.push(dateString.slice(5, 10)); // e.g., "06-01" for June 1
            }
          } catch (e) {
            console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
          }
        }

        return { data, labels };
      }

      function updateMoonChart() {
        const dateInput = document.getElementById("date").value;
        const index = parseInt(document.getElementById("hour").value);
        const hour = Math.floor(index / 2);
        const minutes = (index % 2) * 30;
        const selectedDateTime = new Date(`${dateInput}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
        const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

        const distances = moonData.map(d => d.distance);
        const declinations = moonData.map(d => d.declination);
        const selectedDay = selectedDateTime.getUTCDate() - 1; // Index for the selected day

        let currentDistance = null;
        let currentDeclination = null;
        try {
          const astroTime = Astronomy.MakeTime(selectedDateTime);
          const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, null, true, true);
          const geoMoon = Astronomy.GeoMoon(astroTime);
          currentDistance = geoMoon ? geoMoon.dist : null;
          currentDeclination = moonEq ? moonEq.dec : null;
        } catch (e) {
          console.warn(`Error calculating current Moon data: ${e.message}`);
        }

        const moonAnnotation = {
          timeMarker: {
            type: 'line',
            mode: 'vertical',
            scaleID: 'x',
            value: selectedDay,
            borderColor: 'black',
            borderWidth: 2,
            label: {
              enabled: false
            }
          }
        };

        document.getElementById('moonChartLabel').textContent =
          `Moon Distance: ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}  ` +
          `Declination: ${currentDeclination != null ? currentDeclination.toFixed(1) + '°' : 'N/A'}`;

        if (!moonChart) {
          moonChart = new Chart(document.getElementById("moonDistanceChart"), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: "Moon Distance (km)",
                  data: distances,
                  borderColor: "#800080",
                  pointRadius: 0,
                  borderWidth: 1.5,
                  tension: 0.2,
                  yAxisID: "y1"
                },
                {
                  label: "Moon Declination (°)",
                  data: declinations,
                  borderColor: "#FFA500",
                  pointRadius: 0,
                  borderWidth: 1.5,
                  tension: 0.2,
                  yAxisID: "y2"
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  title: { display: true, text: "Date (MM-DD)" }
                },
                y1: {
                  type: "linear",
                  display: true,
                  position: "left",
                  title: { display: true, text: "Distance (km)", color: "#800080" },
                  min: 350000,
                  max: 410000,
                  ticks: { stepSize: 10000, color: "#800080" },
                  grid: { drawTicks: true, drawBorder: true }
                },
                y2: {
                  type: "linear",
                  display: true,
                  position: "right",
                  title: { display: true, text: "Declination (°)", color: "#FFA500" },
                  min: -30,
                  max: 30,
                  ticks: { stepSize: 10, callback: val => val + "°", color: "#FFA500" },
                  grid: { drawOnChartArea: false }
                }
              },
              plugins: {
                legend: { ATS: { display: false },
                annotation: { annotations: moonAnnotation }
              }
            }
          });
        } else {
          moonChart.data.labels = labels;
          moonChart.data.datasets[0].data = distances;
          moonChart.data.datasets[1].data = declinations;
          moonChart.options.plugins.annotation.annotations = moonAnnotation;
          moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedDay;
          moonChart.update('none');
        }
      }
                                function updateChart(hourIndex) {
                                  const qthInput = document.getElementById("qth").value.trim();
                                  const dxInput = document.getElementById("dx").value.trim();
                                  const dateInput = document.getElementById("date").value;
                                  const dateStr = new Date(dateInput).toISOString().slice(0, 10);

                                  const dataForDay = rawData.filter(r => {
                                    const entryDate = new Date(r.date).toISOString().slice(0, 10);
                                    return entryDate === dateStr;
                                  });

                                  const dxDataForDay = dxRawData.filter(r => {
                                    const entryDate = new Date(r.date).toISOString().slice(0, 10);
                                    return entryDate === dateStr;
                                  });

                                  let moonElevations = [];
                                  let moonAzimuths = [];
                                  let visibleRates = [];
                                  let dopplerSpreads = [];

                                  if (/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
                                    ({ lat, lon } = qthToLatLon(qthInput));
                                    for (let i = 0; i < 48; i++) {
                                      const hour = Math.floor(i / 2);
                                      const minutes = (i % 2) * 30;
                                      const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
                                      const observer = new Astronomy.Observer(lat, lon, 0);
                                      const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                                      const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                                      const elevationDeg = hor.altitude;
                                      const azimuthDeg = hor.azimuth;

                                      if (elevationDeg > 0) {
                                        moonElevations.push(elevationDeg);
                                        moonAzimuths.push(azimuthDeg);
                                        visibleRates.push(dataForDay[i]?.rate ?? null);
                                        const omegaRadSec = (dataForDay[i]?.rate ?? 0) * (Math.PI / 180) / 60;
                                        const dopplerHz = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                                        dopplerSpreads.push(dopplerHz);
                                      } else {
                                        moonElevations.push(null);
                                        moonAzimuths.push(null);
                                        visibleRates.push(null);
                                        dopplerSpreads.push(null);
                                      }
                                    }
                                    document.getElementById("chartWrapper").style.display = "block";
                                  } else {
                                    moonElevations = Array(48).fill(null);
                                    moonAzimuths = Array(48).fill(null);
                                    visibleRates = Array(48).fill(null);
                                    dopplerSpreads = Array(48).fill(null);
                                    document.getElementById("chartWrapper").style.display = "none";
                                  }

                                  let dxMoonElevations = [];
                                  let dxMoonAzimuths = [];
                                  let dxVisibleRates = [];
                                  let dxDopplerSpreads = [];

                                  if (/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput)) {
                                    ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
                                    for (let i = 0; i < 48; i++) {
                                      const hour = Math.floor(i / 2);
                                      const minutes = (i % 2) * 30;
                                      const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
                                      const observer = new Astronomy.Observer(dxLat, dxLon, 0);
                                      const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                                      const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                                      const elevationDeg = hor.altitude;
                                      const azimuthDeg = hor.azimuth;

                                      if (elevationDeg > 0) {
                                        dxMoonElevations.push(elevationDeg);
                                        dxMoonAzimuths.push(azimuthDeg);
                                        dxVisibleRates.push(dxDataForDay[i]?.rate ?? null);
                                        const omegaRadSec = (dxDataForDay[i]?.rate ?? 0) * (Math.PI / 180) / 60;
                                        const dopplerHz = (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT;
                                        dxDopplerSpreads.push(dopplerHz);
                                      } else {
                                        dxMoonElevations.push(null);
                                        dxMoonAzimuths.push(null);
                                        dxVisibleRates.push(null);
                                        dxDopplerSpreads.push(null);
                                      }
                                    }
                                    document.getElementById("dxChartWrapper").style.display = "block";
                                  } else {
                                    document.getElementById("dxChartWrapper").style.display = "none";
                                    if (dxChart) {
                                      dxChart.destroy();
                                      dxChart = null;
                                    }
                                  }

                                  const labels = dataForDay.length ? dataForDay.map((r, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`) : Array(48).fill('');

                                  const qthAnnotation = {
                                    timeMarker: {
                                      type: 'line',
                                      mode: 'vertical',
                                      scaleID: 'x',
                                      value: hourIndex,
                                      borderColor: 'black',
                                      borderWidth: 2,
                                      label: {
                                        enabled: true,
                                        position: 'top',
                                        content: [],
                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                        backgroundColor: 'rgba(0,0,0,0.8)',
                                        color: 'white',
                                        padding: 4,
                                        cornerRadius: 4,
                                        textAlign: 'left'
                                      }
                                    }
                                  };

                                  if (qthInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
                                    try {
                                      const { lat, lon } = qthToLatLon(qthInput);
                                      const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
                                      Object.assign(qthAnnotation, moonAnnotations);
                                    } catch (e) {
                                      // Handle error silently
                                    }
                                  }

                                  const dxAnnotation = {
                                    timeMarker: {
                                      type: 'line',
                                      mode: 'vertical',
                                      scaleID: 'x',
                                      value: hourIndex,
                                      borderColor: 'black',
                                      borderWidth: 2,
                                      label: {
                                        enabled: true,
                                        position: 'top',
                                        content: [],
                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                        backgroundColor: 'rgba(0,0,0,0.8)',
                                        color: 'white',
                                        padding: 4,
                                        cornerRadius: 4,
                                        textAlign: 'left'
                                      }
                                    }
                                  };

                                  if (dxInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput)) {
                                    try {
                                      const { lat, lon } = qthToLatLon(dxInput);
                                      const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
                                      Object.assign(dxAnnotation, moonAnnotations);
                                    } catch (e) {
                                      // Handle error silently
                                    }
                                  }

                                  if (!chart && qthInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
                                    chart = new Chart(document.getElementById("declinationChart"), {
                                      type: 'line',
                                      data: {
                                        labels,
                                        datasets: [
                                          {
                                            label: "Libration Rate (deg/min)",
                                            data: visibleRates,
                                            borderColor: "#ff0000",
                                            pointRadius: 0,
                                            borderWidth: 1.5,
                                            tension: 0.2,
                                            yAxisID: "y1"
                                          },
                                          {
                                            label: "Moon Elevation (°)",
                                            data: moonElevations,
                                            borderColor: "rgba(0, 0, 255, 0.6)",
                                            backgroundColor: "rgba(0, 0, 255, 0.15)",
                                            fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                                            pointRadius: 0,
                                            borderWidth: 1,
                                            tension: 0.3,
                                            yAxisID: "y2"
                                          },
                                          {
                                            label: "Doppler Spread, Hz",
                                            data: dopplerSpreads,
                                            borderColor: "green",
                                            pointRadius: 0,
                                            borderWidth: 1.5,
                                            tension: 0.2,
                                            yAxisID: "y3"
                                          }
                                        ]
                                      },
                                      options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                          x: {},
                                          y1: {
                                            type: "linear",
                                            display: true,
                                            position: "right",
                                            title: { display: true, text: "Libration rate, °/min", color: "#ff0000" },
                                            min: 0,
                                            max: 0.005,
                                            ticks: { stepSize: 0.001, callback: v => v.toFixed(3), color: "#ff0000" },
                                            grid: { drawTicks: true, drawBorder: true }
                                          },
                                          y2: {
                                            position: "left",
                                            display: true,
                                            min: 0,
                                            max: 90,
                                            title: { display: true, text: "Moon Elevation", color: "rgba(0, 0, 255, 0.6)" },
                                            grid: { drawOnChartArea: false },
                                            ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)" }
                                          },
                                          y3: {
                                            type: "linear",
                                            display: true,
                                            position: "right",
                                            offset: true,
                                            title: { display: true, text: "Doppler Spread (Hz)", color: "green" },
                                            min: 0,
                                            max: 300,
                                            grid: { drawOnChartArea: false },
                                            ticks: { stepSize: 50, color: "green" }
                                          }
                                        },
                                        plugins: {
                                          legend: { display: false },
                                          annotation: { annotations: qthAnnotation }
                                        }
                                      }
                                    });
                                  } else if (chart) {
                                    chart.data.labels = labels;
                                    chart.data.datasets[0].data = visibleRates;
                                    chart.data.datasets[1].data = moonElevations;
                                    chart.data.datasets[2].data = dopplerSpreads;
                                    const elev = moonElevations[hourIndex];
                                    const rate = visibleRates[hourIndex];
                                    const doppler = dopplerSpreads[hourIndex];
                                    const azimuth = moonAzimuths[hourIndex];
                                    const labelText =
                                      `El: ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}  ` +
                                      ` Az: ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}  ` +
                                      ` Libration Rate: ${rate != null ? rate.toFixed(4) + '°/min' : 'N/A'}  ` +
                                      ` Spread: ${doppler != null ? doppler.toFixed(0) + 'Hz' : 'N/A'}`;
                                    document.getElementById('chartLabel').textContent = qthInput ? `QTH: ${qthInput.toUpperCase()} - ${labelText}` : 'Enter valid QTH';
                                    if (qthAnnotation.timeMarker.label) {
                                      qthAnnotation.timeMarker.label.enabled = false;
                                    }
                                    chart.options.plugins.annotation.annotations = qthAnnotation;
                                    chart.update('none');
                                  }

                                  if (!dxChart && dxInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput) && dxDataForDay.length) {
                                    dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
                                      type: 'line',
                                      data: {
                                        labels,
                                        datasets: [
                                          {
                                            label: "Libration Rate (deg/min)",
                                            data: dxVisibleRates,
                                            borderColor: "#ff0000",
                                            pointRadius: 0,
                                            borderWidth: 1.5,
                                            tension: 0.2,
                                            yAxisID: "y1"
                                          },
                                          {
                                            label: "Moon Elevation (°)",
                                            data: dxMoonElevations,
                                            borderColor: "rgba(0, 0, 255, 0.6)",
                                            backgroundColor: "rgba(0, 0, 255, 0.15)",
                                            fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                                            pointRadius: 0,
                                            borderWidth: 1,
                                            tension: 0.3,
                                            yAxisID: "y2"
                                          },
                                          {
                                            label: "Doppler Spread, Hz",
                                            data: dxDopplerSpreads,
                                            borderColor: "green",
                                            pointRadius: 0,
                                            borderWidth: 1.5,
                                            tension: 0.2,
                                            yAxisID: "y3"
                                          }
                                        ]
                                      },
                                      options: {
                                        responsive: true,
                                        maintainAspectRatio: false,
                                        scales: {
                                          x: {},
                                          y1: {
                                            type: "linear",
                                            display: true,
                                            position: "right",
                                            title: { display: true, text: "Libration rate, °/min", color: "#ff0000" },
                                            min: 0,
                                            max: 0.005,
                                            ticks: { stepSize: 0.001, callback: v => v.toFixed(3), color: "#ff0000" },
                                            grid: { drawTicks: true, drawBorder: true }
                                          },
                                          y2: {
                                            position: "left",
                                            display: true,
                                            min: 0,
                                            max: 90,
                                            title: { display: true, text: "Moon Elevation", color: "rgba(0, 0, 255, 0.6)" },
                                            grid: { drawOnChartArea: false },
                                            ticks: { stepSize: 15, callback: val => val + "°", color: "rgba(0, 0, 255, 0.6)" }
                                          },
                                          y3: {
                                            type: "linear",
                                            display: true,
                                            position: "right",
                                            offset: true,
                                            title: { display: true, text: "Doppler Spread (Hz)", color: "green" },
                                            min: 0,
                                            max: 300,
                                            grid: { drawOnChartArea: false },
                                            ticks: { stepSize: 50, color: "green" }
                                          }
                                        },
                                        plugins: {
                                          legend: { display: false },
                                          annotation: { annotations: dxAnnotation }
                                        }
                                      }
                                    });
                                  } else if (dxChart && dxDataForDay.length) {
                                    dxChart.data.labels = labels;
                                    dxChart.data.datasets[0].data = dxVisibleRates;
                                    dxChart.data.datasets[1].data = dxMoonElevations;
                                    dxChart.data.datasets[2].data = dxDopplerSpreads;
                                    const elev = dxMoonElevations[hourIndex];
                                    const rate = dxVisibleRates[hourIndex];
                                    const doppler = dxDopplerSpreads[hourIndex];
                                    const azimuth = dxMoonAzimuths[hourIndex];
                                    const labelText =
                                      `El: ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}  ` +
                                      ` Az: ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}  ` +
                                      ` Libration Rate: ${rate != null ? rate.toFixed(4) + '°/min' : 'N/A'}  ` +
                                      ` Spread: ${doppler != null ? doppler.toFixed(0) + 'Hz' : 'N/A'}`;
                                    document.getElementById('dxchartLabel').textContent = dxInput ? `DX: ${dxInput.toUpperCase()} - ${labelText}` : 'Enter valid DX';
                                    if (dxAnnotation.timeMarker.label) {
                                      dxAnnotation.timeMarker.label.enabled = false;
                                    }
                                    dxChart.options.plugins.annotation.annotations = dxAnnotation;
                                    dxChart.update('none');
                                  }

                                  updateMap();
                                  updateMoonChart();
                                }

                                function getMoonAnnotations(dateStr, lat, lon) {
                                  const observer = new Astronomy.Observer(lat, lon, 0);
                                  const jsDate = new Date(`${dateStr}T00:00:00Z`);
                                  const astroTime = Astronomy.MakeTime(jsDate);

                                  let riseEvent = null, setEvent = null;
                                  try {
                                    riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
                                  } catch (e) {
                                    // Handle error silently
                                  }

                                  try {
                                    setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
                                  } catch (e) {
                                    // Handle error silently
                                  }

                                  const annotations = {};

                                  function formatTimeUTC(date) {
                                    return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
                                  }

                                  if (riseEvent && riseEvent.date) {
                                    const riseDate = riseEvent.date;
                                    const index = timeToChartIndex(riseDate);
                                    annotations['moonrise'] = {
                                      type: 'line',
                                      mode: 'vertical',
                                      scaleID: 'x',
                                      value: index,
                                      borderColor: 'blue',
                                      borderWidth: 1,
                                      label: {
                                        content: ['Rise', formatTimeUTC(riseDate)],
                                        enabled: true,
                                        position: 'top',
                                        yAdjust: -40,
                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                        color: 'white',
                                        backgroundColor: 'rgba(0, 0, 255, 0.85)',
                                        padding: 2,
                                        cornerRadius: 6,
                                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                        textAlign: 'center',
                                        borderColor: 'rgba(255, 255, 255, 0.7)',
                                        borderWidth: 1
                                      }
                                    };
                                  }

                                  if (setEvent && setEvent.date) {
                                    const setDate = setEvent.date;
                                    const index = timeToChartIndex(setDate);
                                    annotations['moonset'] = {
                                      type: 'line',
                                      mode: 'vertical',
                                      scaleID: 'x',
                                      value: index,
                                      borderColor: 'orange',
                                      borderWidth: 1,
                                      label: {
                                        content: ['Set', formatTimeUTC(setDate)],
                                        enabled: true,
                                        position: 'top',
                                        font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                                        color: 'white',
                                        backgroundColor: 'rgba(255, 165, 0, 0.85)',
                                        padding: 2,
                                        cornerRadius: 6,
                                        boxShadow: '2px 2px 4px rgba(0,0,0,0.3)',
                                        textAlign: 'center',
                                        borderColor: 'rgba(255, 255, 255, 0.7)',
                                        borderWidth: 1
                                      }
                                    };
                                  }
                                  return annotations;
                                }

                                function timeToChartIndex(date) {
                                  if (!(date instanceof Date)) throw new Error("Expected a Date object");
                                  return (date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600) * 2;
                                }

                                document.getElementById("hour").addEventListener("input", () => {
                                  hourIndex = parseInt(document.getElementById("hour").value);
                                  const hour = Math.floor(hourIndex / 2);
                                  const minutes = (hourIndex % 2) * 30;
                                  document.getElementById("hour-value").textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}`;
                                  updateChart(hourIndex);
                                });

                                function adjustDate(days) {
                                  const dateInput = document.getElementById("date");
                                  const currentDate = new Date(dateInput.value);
                                  currentDate.setDate(currentDate.getDate() + days);
                                  dateInput.valueAsDate = currentDate;
                                  updateChart(hourIndex);
                                }

                                document.getElementById("prevDay").addEventListener("click", () => {
                                  adjustDate(-1);
                                });

                                document.getElementById("nextDay").addEventListener("click", () => {
                                  adjustDate(1);
                                });

                                window.onload = () => {
                                  const now = new Date();
                                  const utcHours = now.getUTCHours();
                                  const utcMinutes = now.getUTCMinutes();

                                  const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
                                  document.getElementById("date").valueAsDate = utcDate;

                                  let roundedHour = utcHours;
                                  let roundedMinutes = 0;

                                  if (utcMinutes >= 45) {
                                    roundedHour += 1;
                                  } else if (utcMinutes >= 15) {
                                    roundedMinutes = 30;
                                  }

                                  hourIndex = roundedHour * 2 + (roundedMinutes === 30 ? 1 : 0);
                                  document.getElementById("hour").value = hourIndex;
                                  document.getElementById("hour-value").textContent =
                                    `Time (UTC): ${String(roundedHour).padStart(2, '0')}:${roundedMinutes === 0 ? '00' : '30'}`;
                                  updateChart(hourIndex);
                                };

                                document.getElementById("date").addEventListener("input", () => {
                                  hourIndex = parseInt(document.getElementById("hour").value);
                                  updateChart(hourIndex);
                                });

                                const qthInput = document.getElementById("qth");
                                const dxInput = document.getElementById("dx");

                                qthInput.addEventListener("input", async () => {
                                  const locator = qthInput.value.trim().toUpperCase();
                                  if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                    await calculateLibration('qth');
                                  } else {
                                    document.getElementById("chartWrapper").style.display = "none";
                                    if (chart) {
                                      chart.destroy();
                                      chart = null;
                                    }
                                  }
                                });

                                dxInput.addEventListener("input", async () => {
                                  const locator = dxInput.value.trim().toUpperCase();
                                  if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
                                    await calculateLibration('dx');
                                  } else {
                                    document.getElementById("dxChartWrapper").style.display = "none";
                                    if (dxChart) {
                                      dxChart.destroy();
                                      dxChart = null;
                                    }
                                  }
                                });

                                function qthToLatLon(locator) {
                                  if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
                                    throw new Error("Invalid QTH locator format (must be 6 characters)");
                                  }
                                  locator = locator.toUpperCase();
                                  const A = 'A'.charCodeAt(0);
                                  const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
                                  const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
                                  return { lat, lon };
                                }

                                async function calculateLibration(type) {
                                  const locator = type === 'qth' ? document.getElementById("qth").value.trim() : document.getElementById("dx").value.trim();
                                  let { lat, lon } = qthToLatLon(locator);
                                  const COS_LAT = Math.cos(lat * Math.PI / 180);
                                  const TIME_SHIFT_MIN = (lon / 15) * 60;
                                  const INTERVAL_MIN = 30;
                                  const SHIFT_STEPS = Math.round(TIME_SHIFT_MIN / INTERVAL_MIN);

                                  let res;
                                  try {
                                    res = await fetch("moon_topo_coords_lat0.txt");
                                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                                  } catch (e) {
                                    return;
                                  }

                                  const lines = (await res.text()).trim().split("\n").slice(1);
                                  const tempData = lines.map(line => ({
                                    date: line.slice(0, 20).trim(),
                                    lat: parseFloat(line.slice(20, 32)),
                                    lon: parseFloat(line.slice(32))
                                  }));

                                  const shifted = tempData.map((entry, i) => {
                                    const shiftedIndex = i + SHIFT_STEPS;
                                    const ref = tempData[shiftedIndex] || {};
                                    return {
                                      date: entry.date,
                                      lat: ref.lat ?? null,
                                      lon: ref.lon ?? null
                                    };
                                  });

                                  const results = shifted.map((curr, i, arr) => {
                                    if (i <= 0 || i >= arr.length - 1 || arr[i-1].lat === null || arr[i+1].lat === null) return { date: curr.date, rate: 0 };
                                    let dlat = (arr[i+1].lat - arr[i-1].lat) / 60;
                                    let dlon = (((arr[i+1].lon - arr[i-1].lon) / 60 + 180) % 360) - 180;
                                    dlat *= COS_LAT;
                                    dlon *= COS_LAT;
                                    return { date: curr.date, rate: Math.sqrt(dlat*dlat + dlon*dlon) };
                                  });

                                  if (type === 'qth') {
                                    ({ lat, lon } = qthToLatLon(locator));
                                    rawData = results;
                                    document.getElementById("chartWrapper").style.display = "block";
                                    updateChart(hourIndex);
                                  } else {
                                    ({ lat: dxLat, lon: dxLon } = qthToLatLon(locator));
                                    dxRawData = results;
                                    document.getElementById("dxChartWrapper").style.display = "block";
                                    updateChart(hourIndex);
                                  }
                                }
  </script>

  <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAPRWRoTRhE5TddxBITIhBcKjdQpz2CXRs&callback=initMap"></script>
</body>
</html>
