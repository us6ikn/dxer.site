<script>
    let chart;
    let dxChart;
    let moonChart;
    let rawData = []; // Stores libration rates for QTH
    let dxRawData = []; // Stores libration rates for DX
    let moonDataForMonth = [];
    let hourIndex = 0;
    let lat = 0;
    let lon = 0;
    let dxLat = 0;
    let dxLon = 0;
    let moonMarker;
    let footprintCircle;
    let currentInfoWindow = null;
    let map;

    const MOON_RADIUS = 1.7374e6; // meters
    const SPEED_OF_LIGHT = 299792458; // m/s
    const FREQUENCY_HZ = 10.368e9; // 10.368 GHz

    // NEW: Function to compute libration rates for a day using AstroLib.topocentricLibration
    function computeLibrationForDay(locator, dateStr, type) {
        if (!/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
            return [];
        }

        const { lat, lon } = qthToLatLon(locator);
        const COS_LAT = Math.cos(lat * Math.PI / 180);
        const date = new Date(dateStr);
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth() + 1; // 1-12
        const day = date.getUTCDate();

        const results = [];
        // Compute for 48 half-hourly intervals (00:00 to 23:30 UTC)
        for (let i = 0; i < 48; i++) {
            const hour = Math.floor(i / 2);
            const minute = (i % 2) * 30;
            const dt = new Date(Date.UTC(year, month - 1, day, hour, minute));
            const isoDate = dt.toISOString().replace('.000Z', '');

            try {
                // Get libration lat/lon using AstroLib.topocentricLibration
                const [libLat, libLon] = AstroLib.topocentricLibration(year, month, day, hour, minute, lat, lon);

                // Store current point
                results.push({
                    date: isoDate,
                    lat: libLat,
                    lon: libLon
                });
            } catch (e) {
                console.warn(`Error computing libration for ${isoDate}: ${e.message}`);
                results.push({
                    date: isoDate,
                    lat: null,
                    lon: null
                });
            }
        }

        // Compute libration rates using finite differences
        const librationRates = results.map((curr, i, arr) => {
            if (i <= 0 || i >= arr.length - 1 || arr[i-1].lat === null || arr[i+1].lat === null || curr.lat === null) {
                return { date: curr.date, rate: null };
            }
            // Compute dlat, dlon over 1 hour (i-1 to i+1, 30 min each side)
            let dlat = (arr[i+1].lat - arr[i-1].lat) / 60; // Degrees per minute
            let dlon = (arr[i+1].lon - arr[i-1].lon) / 60; // Degrees per minute
            dlat *= COS_LAT;
            dlon *= COS_LAT;
            const rate = Math.sqrt(dlat * dlat + dlon * dlon);
            return { date: curr.date, rate };
        });

        // Update global variables
        if (type === 'qth') {
            rawData = librationRates;
            document.getElementById("chartWrapper").style.display = "block";
        } else {
            dxRawData = librationRates;
            document.getElementById("dxChartWrapper").style.display = "block";
        }

        return librationRates;
    }

    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 2,
            center: { lat: 0, lng: 0 },
            mapTypeId: 'terrain',
            gestureHandling: 'greedy',
            mapTypeControl: false,
            streetViewControl: false,
            fullscreenControl: false
        });

        // Fetch and process output_2_10GHz_with_DXCC.json
        fetch('output_2_10GHz_with_DXCC.json')
            .then(response => response.json())
            .then(data => {
                data.forEach(station => {
                    const { Call: callsign, Locator: locator, Antenna: antenna, Power: power, Website: website, Coordinates } = station;
                    const [latStr, lngStr] = Coordinates.split(',');
                    const lat = parseFloat(latStr);
                    const lng = parseFloat(lngStr);
                    if (isNaN(lat) || isNaN(lng)) return;

                    const offsetLat = 0.1;
                    const offsetLng = 0.1;
                    const markerPosition = {
                        lat: lat + (offsetLat / 10000),
                        lng: lng + (offsetLng / 10000)
                    };

                    const marker = new google.maps.Marker({
                        position: markerPosition,
                        map: map,
                        icon: {
                            url: "https://dxer.site/img/m_30.png",
                            scaledSize: new google.maps.Size(20, 20)
                        },
                        title: callsign
                    });

                    const infoContent = `
                        <div>
                            <div style="font-weight:bold; font-size: 16px;">${callsign}</div>
                            <div>Locator: ${locator}${
                                /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)
                                    ? ` <button id="sked-${callsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>`
                                    : ''
                            }</div>
                            <div>Antenna: ${antenna}</div>
                            <div>Power: ${power}</div>
                            <div>Website: <a href="${website}" target="_blank">${website}</a></div>
                            <div><a href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ.com lookup</a></div>
                            <div id="image-container-${callsign}">
                                Station Picture (clickable):<br>
                                <a href="https://dxer.site/db/${callsign}.jpg" target="_blank">
                                    <img id="station-image-${callsign}"
                                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA"
                                        alt="${callsign} station"/>
                                </a>
                                <div id="image-placeholder-${callsign}" style="display:none;">
                                    <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                                </div>
                            </div>
                        </div>
                    `;

                    const infoWindow = new google.maps.InfoWindow({ content: infoContent });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;

                        setTimeout(() => {
                            const imageElement = document.getElementById(`station-image-${callsign}`);
                            const placeholder = document.getElementById(`image-placeholder-${callsign}`);
                            const imageUrl = `https://dxer.site/db/${callsign}_thumb.jpg`;
                            fetch(imageUrl, { method: 'HEAD' })
                                .then(response => {
                                    if (!response.ok) {
                                        imageElement.remove();
                                        placeholder.style.display = 'block';
                                    } else {
                                        imageElement.src = imageUrl;
                                        placeholder.style.display = 'none';
                                    }
                                })
                                .catch(() => {
                                    imageElement.remove();
                                    placeholder.style.display = 'block';
                                });

                            // Add event listener for Sked button
                            const skedButton = document.getElementById(`sked-${callsign}`);
                            if (skedButton) {
                                skedButton.addEventListener('click', () => {
                                    const locator = skedButton.getAttribute('data-locator');
                                    document.getElementById('dx').value = locator;
                                    // Trigger input event to update chart
                                    const inputEvent = new Event('input', { bubbles: true });
                                    document.getElementById('dx').dispatchEvent(inputEvent);
                                });
                            }
                        }, 100);
                    });
                });
            })
            .catch(() => { /* Handle error silently */ });

        // Fetch and process output_2_10GHz_SK_with_DXCC.json
        fetch('output_2_10GHz_SK_with_DXCC.json')
            .then(response => response.json())
            .then(data => {
                data.forEach(station => {
                    const { Call: callsign, Locator: locator, Antenna: antenna, Power: power, Website: website, Coordinates } = station;
                    const { lat, lng } = parseCoordinates(Coordinates);
                    if (isNaN(lat) || isNaN(lng)) return;

                    const markerPosition = {
                        lat: lat + (0.1 / 10000),
                        lng: lng + (0.1 / 10000)
                    };

                    const marker = new google.maps.Marker({
                        position: markerPosition,
                        map: map,
                        icon: {
                            url: "https://dxer.site/img/notworked.png",
                            scaledSize: new google.maps.Size(20, 20)
                        },
                        title: callsign
                    });

                    const infoContent = `
                        <div>
                            <div style="font-weight:bold; font-size: 16px;">${callsign} (SK)</div>
                            <div>Locator: ${locator}${
                                /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)
                                    ? ` <button id="sked-${callsign}" class="sked-button" data-locator="${locator.toUpperCase()}">Sked</button>`
                                    : ''
                            }</div>
                            <div>Antenna: ${antenna}</div>
                            <div>Power: ${power}</div>
                            <div>Website: <a href="${website}" target="_blank">${website}</a></div>
                            <div><a href="https://www.qrz.com/db/${callsign}" target="_blank">QRZ.com lookup</a></div>
                            <div id="image-container-${callsign}">
                                Station Picture (clickable):<br>
                                <a href="https://dxer.site/db/${callsign}.jpg" target="_blank">
                                    <img id="station-image-${callsign}"
                                        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA"
                                        alt="${callsign} station"/>
                                </a>
                                <div id="image-placeholder-${callsign}" style="display:none;">
                                    <p><a href="https://forms.gle/vLCqCySPEkH926AX8" target="_blank">Add Image</a></p>
                                </div>
                            </div>
                        </div>
                    `;

                    const infoWindow = new google.maps.InfoWindow({ content: infoContent });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;

                        setTimeout(() => {
                            const imageElement = document.getElementById(`station-image-${callsign}`);
                            const placeholder = document.getElementById(`image-placeholder-${callsign}`);
                            const imageUrl = `https://dxer.site/db/${callsign}_thumb.jpg`;
                            fetch(imageUrl, { method: 'HEAD' })
                                .then(response => {
                                    if (!response.ok) {
                                        imageElement.remove();
                                        placeholder.style.display = 'block';
                                    } else {
                                        imageElement.src = imageUrl;
                                        placeholder.style.display = 'none';
                                    }
                                })
                                .catch(() => {
                                    imageElement.remove();
                                    placeholder.style.display = 'block';
                                });

                            // Add event listener for Sked button
                            const skedButton = document.getElementById(`sked-${callsign}`);
                            if (skedButton) {
                                skedButton.addEventListener('click', () => {
                                    const locator = skedButton.getAttribute('data-locator');
                                    document.getElementById('dx').value = locator;
                                    // Trigger input event to update chart
                                    const inputEvent = new Event('input', { bubbles: true });
                                    document.getElementById('dx').dispatchEvent(inputEvent);
                                });
                            }
                        }, 100);
                    });
                });
            })
            .catch(() => { /* Handle error silently */ });
    }

    function parseCoordinates(coordinates) {
        const [latStr, lngStr] = coordinates.split(',');
        return {
            lat: parseFloat(latStr),
            lng: parseFloat(lngStr)
        };
    }

    function updateMap() {
        const selectedDate = document.getElementById('date').value;
        const index = parseInt(document.getElementById('hour').value);
        const hour = Math.floor(index / 2).toString().padStart(2, '0');
        const minutes = index % 2 === 0 ? '00' : '30';
        const utcTimeString = `${selectedDate}T${hour}:${minutes}:00Z`;

        // Validate date input
        if (!selectedDate || !/^\d{4}-\d{2}-\d{2}$/.test(selectedDate)) {
            console.warn(`Invalid or missing date in updateMap: ${selectedDate}`);
            return;
        }

        const utcDate = new Date(utcTimeString);
        if (isNaN(utcDate.getTime())) {
            console.error(`Invalid date string in updateMap: ${utcTimeString}`);
            return;
        }

        try {
            // Calculate sublunar point
            const time = Astronomy.MakeTime(utcDate);
            const observer = new Astronomy.Observer(0, 0, 0); // Geocenter
            const moon = Astronomy.Equator(Astronomy.Body.Moon, time, observer, true, true);
            const libration = Astronomy.Libration(time);

            if (!moon || !libration) {
                console.warn(`Failed to compute Moon data for ${utcTimeString}`);
                return;
            }

            const raHours = moon.ra; // Right Ascension in sidereal HOURS
            const decDeg = moon.dec; // Declination in DEGREES (latitude)
            const raDeg = raHours * 15; // Convert RA to degrees

            let gastDeg = Astronomy.SiderealTime(time) * 15; // GAST in degrees
            gastDeg = ((gastDeg % 360) + 360) % 360; // Normalize to [0, 360)

            let lonDeg = raDeg - gastDeg;
            if (lonDeg > 180) lonDeg -= 360;
            if (lonDeg < -180) lonDeg += 360;

            const lat = decDeg; // Sublunar latitude
            const lon = lonDeg; // Sublunar longitude

            // Calculate footprint radius
            const earthRadius = 6371; // Earth's mean radius in km
            const D_moon = libration.dist_km; // Moon's geocentric distance in km
            const theta_rad = Math.acos(earthRadius / (earthRadius + D_moon));
            const footprintRadius = earthRadius * theta_rad * 1000; // Convert km to meters for Google Maps

            if (isNaN(lat) || isNaN(lon) || isNaN(footprintRadius)) {
                console.warn(`Invalid sublunar point data for ${utcTimeString}: lat=${lat}, lon=${lon}, radius=${footprintRadius}`);
                return;
            }

            // Remove existing marker and circle if they exist
            if (moonMarker) moonMarker.setMap(null);
            if (footprintCircle) footprintCircle.setMap(null);

            // Create new Moon marker
            moonMarker = new google.maps.Marker({
                position: { lat, lng: lon },
                map: map,
                icon: {
                    url: 'https://dxer.site/img/moon-icon.png',
                    scaledSize: new google.maps.Size(48, 48)
                },
                title: `Moon Sublunar Point (${lat.toFixed(2)}°, ${lon.toFixed(2)}°)`
            });

            // Create new footprint circle
            footprintCircle = new google.maps.Circle({
                map: map,
                center: { lat, lng: lon },
                radius: footprintRadius,
                fillColor: '#0088FF',
                fillOpacity: 0.3,
                strokeColor: '#0000FF',
                strokeOpacity: 0.6,
                strokeWeight: 2
            });

        } catch (error) {
            console.error(`Error calculating sublunar point for ${utcTimeString}: ${error.message}`);
        }
    }

    function calculateMoonDataForMonth(dateStr) {
        const startDate = new Date(dateStr);
        startDate.setUTCDate(1);
        const endDate = new Date(startDate);
        endDate.setUTCDate(endDate.getUTCDate() + 30);

        const data = [];
        const labels = [];

        // Use a default observer for declination calculations
        const observer = new Astronomy.Observer(0, 0, 0);

        for (let dt = new Date(startDate); dt <= endDate; dt.setUTCDate(dt.getUTCDate() + 1)) {
            try {
                const dateString = dt.toISOString().slice(0, 10);
                const time = `${dateString}T00:00:00Z`;
                const astroTime = Astronomy.MakeTime(new Date(time));
                
                // Calculate distance using Astronomy.Libration
                const libration = Astronomy.Libration(astroTime);
                const distanceKm = libration.dist_km;

                // Calculate declination using Astronomy.Equator
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, observer, true, true);
                
                if (!moonEq || distanceKm == null) {
                    throw new Error("Invalid Moon data");
                }

                const declination = moonEq.dec;

                if (distanceKm != null && declination != null) {
                    data.push({
                        date: dateString,
                        distance: distanceKm,
                        declination: declination
                    });
                    labels.push(dateString.slice(5, 10)); // e.g., "06-01" for June 1
                } else {
                    console.warn(`Missing data for ${dateString}: distance=${distanceKm}, declination=${declination}`);
                }
            } catch (e) {
                console.warn(`Error calculating Moon data for ${dt.toISOString()}: ${e.message}`);
            }
        }

        return { data, labels };
    }

    function updateMoonChart() {
        const dateInput = document.getElementById("date").value;
        const index = parseInt(document.getElementById("hour").value);
        const hour = Math.floor(index / 2);
        const minutes = (index % 2) * 30;
        const selectedDateTime = new Date(`${dateInput}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
        const { data: moonData, labels } = calculateMoonDataForMonth(dateInput);

        const distances = moonData.map(d => d.distance);
        const declinations = moonData.map(d => d.declination);
        const selectedDay = selectedDateTime.getUTCDate() - 1;

        let currentDistance = null;
        let currentDeclination = null;
        let pathLoss = null;
        const minDist = 356352.93; // Minimal Moon distance in km

        try {
            const astroTime = Astronomy.MakeTime(selectedDateTime);
            const observer = new Astronomy.Observer(0, 0, 0); // Default observer for declination
            const libration = Astronomy.Libration(astroTime);
            const moonEq = Astronomy.Equator(Astronomy.Body.Moon, astroTime, observer, true, true);
            
            if (libration && moonEq) {
                currentDistance = libration.dist_km;
                currentDeclination = moonEq.dec;
                if (currentDistance != null) {
                    pathLoss = 40 * Math.log10(currentDistance / minDist);
                }
            } else {
                throw new Error("Invalid current Moon data");
            }
        } catch (e) {
            console.warn(`Error calculating current Moon data for ${selectedDateTime.toISOString()}: ${e.message}`);
        }

        const moonAnnotation = {
            timeMarker: {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: selectedDay,
                borderColor: 'black',
                borderWidth: 2,
                label: {
                    enabled: false
                }
            }
        };

        document.getElementById('moonChartLabel').innerHTML =
            `<span class="metric-label metric-distance">Distance:</span> ${currentDistance != null ? currentDistance.toFixed(0) + ' km' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-declination">Declination:</span> ${currentDeclination != null ? currentDeclination.toFixed(1) + '°' : 'N/A'}` +
            `<span class="metric-separator">|</span>` +
            `<span class="metric-label metric-pathloss">Extra Loss:</span> ${pathLoss != null ? pathLoss.toFixed(2) + ' dB' : 'N/A'}`;

        if (!moonChart) {
            moonChart = new Chart(document.getElementById("moonDistanceChart"), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: "Moon Distance (km)",
                            data: distances,
                            borderColor: "#800080",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y1"
                        },
                        {
                            label: "Moon Declination (°)",
                            data: declinations,
                            borderColor: "#FFA500",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y2"
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Date (MM-DD)",
                                font: { size: 10, family: 'Arial, sans-serif' }
                            },
                            ticks: { font: { size: 10 } }
                        },
                        y1: {
                            type: "linear",
                            display: true,
                            position: "left",
                            title: {
                                display: true,
                                text: "Distance (\u00D710³ km)",
                                color: "#800080",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            min: 356400,
                            max: 406700,
                            ticks: {
                                stepSize: 10000,
                                color: "#800080",
                                font: { size: 12 },
                                callback: function(value) {
                                    return (value / 1000).toFixed(0); // Show thousands of km (e.g., 356)
                                }
                            },
                            grid: { drawTicks: true, drawBorder: true }
                        },
                        y2: {
                            type: "linear",
                            display: true,
                            position: "right",
                            title: {
                                display: true,
                                text: "Declination (°)",
                                color: "#FFA500",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            min: -30,
                            max: 30,
                            ticks: {
                                stepSize: 10,
                                callback: val => val + "°",
                                color: "#FFA500",
                                font: { size: 12 }
                            },
                            grid: { drawOnChartArea: false }
                        },
                        y3: {
                            type: "linear",
                            display: true,
                            position: "right",
                            title: {
                                display: true,
                                text: "Extra Path Loss (dB)",
                                color: "#800080",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            min: 0,
                            max: 2.5,
                            ticks: {
                                stepSize: 0.5,
                                callback: val => val.toFixed(1),
                                color: "#800080",
                                font: { size: 12 }
                            },
                            grid: { drawOnChartArea: false },
                            offset: true // Prevent overlap with y2
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: { annotations: moonAnnotation }
                    }
                }
            });
        } else {
            moonChart.data.labels = labels;
            moonChart.data.datasets[0].data = distances;
            moonChart.data.datasets[1].data = declinations;
            moonChart.options.plugins.annotation.annotations = moonAnnotation;
            moonChart.options.plugins.annotation.annotations.timeMarker.value = selectedDay;
            moonChart.options.scales.y1.min = 356400;
            moonChart.options.scales.y1.max = 406700;
            moonChart.options.scales.y2.min = -30;
            moonChart.options.scales.y2.max = 30;
            moonChart.options.scales.y3.min = 0;
            moonChart.options.scales.y3.max = 2.5;
            moonChart.update('none');
        }
    }

    function updateChart(hourIndex) {
        const qthInput = document.getElementById("qth").value.trim();
        const dxInput = document.getElementById("dx").value.trim();
        const dateInput = document.getElementById("date").value;
        const dateStr = new Date(dateInput).toISOString().slice(0, 10);

        const dataForDay = rawData.filter(r => {
            const entryDate = new Date(r.date).toISOString().slice(0, 10);
            return entryDate === dateStr;
        });

        const dxDataForDay = dxRawData.filter(r => {
            const entryDate = new Date(r.date).toISOString().slice(0, 10);
            return entryDate === dateStr;
        });

        let moonElevations = [];
        let moonAzimuths = [];
        let visibleRates = [];
        let dopplerSpreads = [];

        if (/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
            ({ lat, lon } = qthToLatLon(qthInput));
            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minutes = (i % 2) * 30;
                const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
                const observer = new Astronomy.Observer(lat, lon, 0);
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                const elevationDeg = hor.altitude;
                const azimuthDeg = hor.azimuth;

                if (elevationDeg > 0) {
                    moonElevations.push(elevationDeg);
                    moonAzimuths.push(azimuthDeg);
                    const rate = dataForDay[i]?.rate ?? null;
                    visibleRates.push(rate != null ? rate * 1000 : null); // Scale to ×10⁻³ °/min
                    const omegaRadSec = rate != null ? rate * (Math.PI / 180) / 60 : 0;
                    const dopplerHz = rate != null ? (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT : null;
                    dopplerSpreads.push(dopplerHz);
                } else {
                    moonElevations.push(null);
                    moonAzimuths.push(null);
                    visibleRates.push(null);
                    dopplerSpreads.push(null);
                }
            }
            document.getElementById("chartWrapper").style.display = "block";
        } else {
            moonElevations = Array(48).fill(null);
            moonAzimuths = Array(48).fill(null);
            visibleRates = Array(48).fill(null);
            dopplerSpreads = Array(48).fill(null);
            document.getElementById("chartWrapper").style.display = "none";
        }

        let dxMoonElevations = [];
        let dxMoonAzimuths = [];
        let dxVisibleRates = [];
        let dxDopplerSpreads = [];

        if (/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput)) {
            ({ lat: dxLat, lon: dxLon } = qthToLatLon(dxInput));
            for (let i = 0; i < 48; i++) {
                const hour = Math.floor(i / 2);
                const minutes = (i % 2) * 30;
                const dt = new Date(`${dateStr}T${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}:00Z`);
                const observer = new Astronomy.Observer(dxLat, dxLon, 0);
                const moonEq = Astronomy.Equator(Astronomy.Body.Moon, dt, observer, true, false);
                const hor = Astronomy.Horizon(dt, observer, moonEq.ra, moonEq.dec, 'normal');
                const elevationDeg = hor.altitude;
                const azimuthDeg = hor.azimuth;

                if (elevationDeg > 0) {
                    dxMoonElevations.push(elevationDeg);
                    dxMoonAzimuths.push(azimuthDeg);
                    const rate = dxDataForDay[i]?.rate ?? null;
                    dxVisibleRates.push(rate != null ? rate * 1000 : null); // Scale to ×10⁻³ °/min
                    const omegaRadSec = rate != null ? rate * (Math.PI / 180) / 60 : 0;
                    const dopplerHz = rate != null ? (4 * FREQUENCY_HZ * MOON_RADIUS * omegaRadSec) / SPEED_OF_LIGHT : null;
                    dxDopplerSpreads.push(dopplerHz);
                } else {
                    dxMoonElevations.push(null);
                    dxMoonAzimuths.push(null);
                    dxVisibleRates.push(null);
                    dxDopplerSpreads.push(null);
                }
            }
            document.getElementById("dxChartWrapper").style.display = "block";
        } else {
            document.getElementById("dxChartWrapper").style.display = "none";
            if (dxChart) {
                dxChart.destroy();
                dxChart = null;
            }
        }

        const labels = dataForDay.length ? dataForDay.map((r, i) => `${Math.floor(i / 2)}:${i % 2 === 0 ? '00' : '30'}`) : Array(48).fill('');

        const qthAnnotation = {
            timeMarker: {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: hourIndex,
                borderColor: 'black',
                borderWidth: 2,
                label: {
                    enabled: false // Disable to avoid clutter
                }
            }
        };

        if (qthInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
            try {
                const { lat, lon } = qthToLatLon(qthInput);
                const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
                Object.assign(qthAnnotation, moonAnnotations);
            } catch (e) {
                // Handle error silently
            }
        }

        const dxAnnotation = {
            timeMarker: {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: hourIndex,
                borderColor: 'black',
                borderWidth: 2,
                label: {
                    enabled: false // Disable to avoid clutter
                }
            }
        };

        if (dxInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput)) {
            try {
                const { lat, lon } = qthToLatLon(dxInput);
                const moonAnnotations = getMoonAnnotations(dateStr, lat, lon);
                Object.assign(dxAnnotation, moonAnnotations);
            } catch (e) {
                // Handle error silently
            }
        }

        if (!chart && qthInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(qthInput)) {
            chart = new Chart(document.getElementById("declinationChart"), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: "Libration Rate (×10⁻³ °/min)",
                            data: visibleRates,
                            borderColor: "#ff0000",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y1"
                        },
                        {
                            label: "Moon Elevation (°)",
                            data: moonElevations,
                            borderColor: "rgba(0, 0, 255, 0.6)",
                            backgroundColor: "rgba(0, 0, 255, 0.15)",
                            fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                            pointRadius: 0,
                            borderWidth: 1,
                            tension: 0.3,
                            yAxisID: "y2"
                        },
                        {
                            label: "Doppler Spread, Hz",
                            data: dopplerSpreads,
                            borderColor: "green",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y3"
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Time (UTC)",
                                font: { size: 10, family: 'Arial, sans-serif' }
                            },
                            ticks: { font: { size: 10 } }
                        },
                        y1: {
                            type: "linear",
                            display: true,
                            position: "right",
                            title: {
                                display: true,
                                text: "Libration Rate (×10⁻³ °/min)",
                                color: "#ff0000",
                                font: { size: 10, family: 'Arial, sans-serif' }
                            },
                            min: 0,
                            max: 5,
                            ticks: {
                                stepSize: 1,
                                color: "#ff0000",
                                font: { size: 12 }
                            },
                            grid: { drawTicks: true, drawBorder: true }
                        },
                        y2: {
                            position: "left",
                            display: true,
                            min: 0,
                            max: 90,
                            title: {
                                display: true,
                                text: "Moon Elevation (°)",
                                color: "rgba(0, 0, 255, 0.6)",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            grid: { drawOnChartArea: false },
                            ticks: {
                                stepSize: 15,
                                callback: val => val + "°",
                                color: "rgba(0, 0, 255, 0.6)",
                                font: { size: 12 }
                            }
                        },
                        y3: {
                            type: "linear",
                            display: true,
                            position: "right",
                            offset: true,
                            title: {
                                display: true,
                                text: "Doppler Spread (Hz)",
                                color: "green",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            min: 0,
                            max: 300,
                            grid: { drawOnChartArea: false },
                            ticks: {
                                stepSize: 50,
                                color: "green",
                                font: { size: 12 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: { annotations: qthAnnotation }
                    }
                }
            });
        } else if (chart) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = visibleRates;
            chart.data.datasets[1].data = moonElevations;
            chart.data.datasets[2].data = dopplerSpreads;
            const elev = moonElevations[hourIndex];
            const rate = visibleRates[hourIndex] != null ? (visibleRates[hourIndex] / 1000).toFixed(4) : null; // Scale back for display
            const doppler = dopplerSpreads[hourIndex];
            const azimuth = moonAzimuths[hourIndex];
            const labelText =
                `<span class="metric-locator">${qthInput.toUpperCase()}</span>` +
                `<span class="metric-separator"> - </span>` +
                `<span class="metric-label metric-elevation">El:</span> ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-azimuth">Az:</span> ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-libration">Libr:</span> ${rate != null ? rate + '°/min' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-doppler">Spread:</span> ${doppler != null ? doppler.toFixed(0) + ' Hz' : 'N/A'}`;
            document.getElementById('chartLabel').innerHTML = qthInput ? labelText : '<span class="metric-locator">Enter valid QTH</span>';
            if (qthAnnotation.timeMarker.label) {
                qthAnnotation.timeMarker.label.enabled = false;
            }
            chart.options.plugins.annotation.annotations = qthAnnotation;
            chart.update('none');
        }

        if (!dxChart && dxInput && /^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(dxInput) && dxDataForDay.length) {
            dxChart = new Chart(document.getElementById("dxDeclinationChart"), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: "Libration Rate (×10⁻³ °/min)",
                            data: dxVisibleRates,
                            borderColor: "#ff0000",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y1"
                        },
                        {
                            label: "Moon Elevation (°)",
                            data: dxMoonElevations,
                            borderColor: "rgba(0, 0, 255, 0.6)",
                            backgroundColor: "rgba(0, 0, 255, 0.15)",
                            fill: { target: { value: 0 }, above: 'rgba(0, 0, 255, 0.15)' },
                            pointRadius: 0,
                            borderWidth: 1,
                            tension: 0.3,
                            yAxisID: "y2"
                        },
                        {
                            label: "Doppler Spread, Hz",
                            data: dxDopplerSpreads,
                            borderColor: "green",
                            pointRadius: 0,
                            borderWidth: 1.5,
                            tension: 0.2,
                            yAxisID: "y3"
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Time (UTC)",
                                font: { size: 10, family: 'Arial, sans-serif' }
                            },
                            ticks: { font: { size: 10 } }
                        },
                        y1: {
                            type: "linear",
                            display: true,
                            position: "right",
                            title: {
                                display: true,
                                text: "Libration Rate (×10⁻³ °/min)",
                                color: "#ff0000",
                                font: { size: 10, family: 'Arial, sans-serif' }
                            },
                            min: 0,
                            max: 5,
                            ticks: {
                                stepSize: 1,
                                color: "#ff0000",
                                font: { size: 12 }
                            },
                            grid: { drawTicks: true, drawBorder: true }
                        },
                        y2: {
                            position: "left",
                            display: true,
                            min: 0,
                            max: 90,
                            title: {
                                display: true,
                                text: "Moon Elevation (°)",
                                color: "rgba(0, 0, 255, 0.6)",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            grid: { drawOnChartArea: false },
                            ticks: {
                                stepSize: 15,
                                callback: val => val + "°",
                                color: "rgba(0, 0, 255, 0.6)",
                                font: { size: 12 }
                            }
                        },
                        y3: {
                            type: "linear",
                            display: true,
                            position: "right",
                            offset: true,
                            title: {
                                display: true,
                                text: "Doppler Spread (Hz)",
                                color: "green",
                                font: { size: 12, family: 'Arial, sans-serif' }
                            },
                            min: 0,
                            max: 300,
                            grid: { drawOnChartArea: false },
                            ticks: {
                                stepSize: 50,
                                color: "green",
                                font: { size: 12 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: { annotations: dxAnnotation }
                    }
                }
            });
        } else if (dxChart && dxDataForDay.length) {
            dxChart.data.labels = labels;
            dxChart.data.datasets[0].data = dxVisibleRates;
            dxChart.data.datasets[1].data = dxMoonElevations;
            dxChart.data.datasets[2].data = dxDopplerSpreads;
            const elev = dxMoonElevations[hourIndex];
            const rate = dxVisibleRates[hourIndex] != null ? (dxVisibleRates[hourIndex] / 1000).toFixed(4) : null; // Scale back for display
            const doppler = dxDopplerSpreads[hourIndex];
            const azimuth = dxMoonAzimuths[hourIndex];
            const labelText =
                `<span class="metric-locator">${dxInput.toUpperCase()}</span>` +
                `<span class="metric-separator"> - </span>` +
                `<span class="metric-label metric-elevation">El:</span> ${elev != null ? elev.toFixed(1) + '°' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-azimuth">Az:</span> ${azimuth != null ? azimuth.toFixed(1) + '°' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-libration">Libr:</span> ${rate != null ? rate + '°/min' : 'N/A'}` +
                `<span class="metric-separator">|</span>` +
                `<span class="metric-label metric-doppler">Spread:</span> ${doppler != null ? doppler.toFixed(0) + ' Hz' : 'N/A'}`;
            document.getElementById('dxchartLabel').innerHTML = dxInput ? labelText : '<span class="dxchartLabel">Enter valid DX</span>';
            if (dxAnnotation.timeMarker.label) {
                dxAnnotation.timeMarker.label.enabled = false;
            }
            dxChart.options.plugins.annotation.annotations = dxAnnotation;
            dxChart.update('none');
        }

        updateMap();
        updateMoonChart();
    }

    function getMoonAnnotations(dateStr, lat, lon) {
        const observer = new Astronomy.Observer(lat, lon, 0);
        const jsDate = new Date(`${dateStr}T00:00:00Z`);
        const astroTime = Astronomy.MakeTime(jsDate);

        let riseEvent = null, setEvent = null;
        try {
            riseEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, +1, astroTime, 1.0);
        } catch (e) {
            // Handle error silently
        }

        try {
            setEvent = Astronomy.SearchRiseSet(Astronomy.Body.Moon, observer, -1, astroTime, 1.0);
        } catch (e) {
            // Handle error silently
        }

        const annotations = {};

        function formatTimeUTC(date) {
            return `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}z`;
        }

        if (riseEvent && riseEvent.date) {
            const riseDate = riseEvent.date;
            const index = timeToChartIndex(riseDate);
            annotations['moonrise'] = {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: index,
                borderColor: 'blue',
                borderWidth: 1,
                label: {
                    content: ['Rise', formatTimeUTC(riseDate)],
                    enabled: true,
                    position: 'top',
                    yAdjust: -40,
                    font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                    color: 'white',
                    backgroundColor: 'rgba(0, 0, 255, 0.85),
                    padding: 2,
                    cornerRadius: 6,
                    boxShadow: '2px 2px 4px rgba(0,0,0,0.3),
                    textAlign: 'center',
                    borderColor: 'rgba(255, 255, 255, 0.7),
                    borderWidth: 1
                }
            };
        }

        if (setEvent && setEvent.date) {
            const setDate = setEvent.date;
            const index = timeToChartIndex(setDate);
            annotations['moonset'] = {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: index,
                borderColor: 'orange',
                borderWidth: 1,
                label: {
                    content: ['Set', formatTimeUTC(setDate)],
                    enabled: true,
                    position: 'top',
                    font: { size: 11, weight: 'bold', family: 'Arial, sans-serif' },
                    color: 'white',
                    backgroundColor: 'rgba(255, 165, 0, 0.85),
                    padding: 2,
                    cornerRadius: 6,
                    boxShadow: '2px 2px 4px rgba(0,0,0,0.3),
                    textAlign: 'center',
                    borderColor: 'rgba(255, 255, 255, 0.7),
                    borderWidth: 1
                }
            };
        }
        return annotations;
    }

    function timeToChartIndex(date) {
        if (!(date instanceof Date)) throw new Error("Expected a Date object");
        return (date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600) * 2;
    }

    document.getElementById("hour").addEventListener("input", () => {
        hourIndex = parseInt(document.getElementById("hour").value);
        const hour = Math.floor(hourIndex / 2);
        const minutes = (hourIndex % 2) * 30;
        document.getElementById("hour-value").textContent = `Time (UTC): ${String(hour).padStart(2, '0')}:${minutes === 0 ? '00' : '30'}`;
        updateChart(hourIndex);
    });

    function adjustDate(days) {
        const dateInput = document.getElementById("date");
        const currentDate = new Date(dateInput.value);
        currentDate.setDate(currentDate.getDate() + days);
        dateInput.valueAsDate = currentDate;
        updateChart(hourIndex);
    }

    document.getElementById("prevDay").addEventListener("click", () => {
        adjustDate(-1);
    });

    document.getElementById("nextDay").addEventListener("click", () => {
        adjustDate(1);
    });

    document.getElementById("date").addEventListener("change", () => {
        const qthInput = document.getElementById("qth").value.trim().toUpperCase();
        const dxInput = document.getElementById("dx").value.trim().toUpperCase();
        // NEW: Compute libration for valid QTH or DX
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
            computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
        }
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
            computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
        }
        updateChart(hourIndex);
    });

    window.onload = () => {
        const now = new Date();
        const utcHours = now.getUTCHours();
        const utcMinutes = now.getUTCMinutes();

        const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
        document.getElementById("date").valueAsDate = utcDate;

        let roundedHour = utcHours;
        let roundedMinutes = utcMinutes;

        if (utcMinutes >= 45) {
            roundedHour +=  if (utcMinutes >= 15) {
            roundedMinutes = Math.round(30);
        } else if (utcMinutes >= 1) {
            roundedMinutes = 30;
        }

        hourIndex = roundedHour * 2 + (roundedMinutes == 30 ? 1 : 0);
        document.getElementsById("hour").value = hourIndex;
        document.getElementsById("hour-value").textContent =
            `Time (UTC): ${Math.roundedHour().String().padStart(2, '0')}:${roundedMinutes === 0 ? '00' : '30'}`;
        
        // Ensure showControlsPanel is hidden on load
        document.getElementById("showControlsPanel").classList.remove("visible");

        // NEW: Initialize libration data if QTH or DX exists
        const qthInput = document.getElementById("qth").value.trim().toUpperCase();
        const dxInput = document.getElementById("dx").value.trim().toUpperCase();
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(qthInput)) {
            computeLibrationForDay(qthInput, document.getElementById("date").value, 'qth');
        }
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(dxInput)) {
            computeLibrationForDay(dxInput, document.getElementById("date").value, 'dx');
        }

        // Call updates after setting date
        updateMap();
        updateMoonChart();
        updateChart(hourIndex);
    };

    const qthInput = document.getElementById("qth");
    const dxInput = document.getElementById("dx");

    qthInput.addEventListener("input", () => {
        const locator = qthInput.value.trim().toUpperCase();
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
            // NEW: Compute libration for QTH
            computeLibrationForDay(locator, document.getElementById("date").value, 'qth');
            updateChart(hourIndex);
        } else {
            document.getElementById("chartWrapper").style.display = "none";
            if (chart) {
                chart.destroy();
                chart = null;
            }
            document.getElementById('chartLabel').innerHTML = '<span class="metric-locator">Enter valid QTH</span>';
        }
    });

    dxInput.addEventListener("input", () => {
        const locator = dxInput.value.trim().toUpperCase();
        if (/^[A-R]{2}[0-9]{2}[A-X]{2}$/.test(locator)) {
            // NEW: Compute libration for DX
            computeLibrationForDay(locator, document.getElementById("date").value, 'dx');
            updateChart(hourIndex);
        } else {
            document.getElementById("dxChartWrapper").style.display = "none";
            if (dxChart) {
                dxChart.destroy();
                dxChart = null;
            }
            document.getElementById('dxchartLabel').innerHTML = '<span class="metric-locator">Enter valid DX</span>';
        }
    });

    function qthToLatLon(locator) {
        if (!/^[A-Ra-r]{2}[0-9]{2}[A-Xa-x]{2}$/.test(locator)) {
            throw new Error("Invalid QTH locator format (must be 6 characters)");
        }
        locator = locator.toUpperCase();
        const A = 'A'.charCodeAt(0);
        const lon = (locator.charCodeAt(0) - A) * 20 + parseInt(locator[2]) * 2 + (locator.charCodeAt(4) - A) * (5 / 60) - 180 + (2.5 / 60);
        const lat = (locator.charCodeAt(1) - A) * 10 + parseInt(locator[3]) + (locator.charCodeAt(5) - A) * (2.5 / 60) - 90 + (1.25 / 60);
        return { lat, lon };
    }

    // Toggle controls panel folding
    document.getElementById("toggleControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (!controls.classList.contains("folded")) {
            controls.classList.add("folded");
            toggleButton.style.display = "none";
            showButton.classList.add("visible");
            // Force repaint
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight; // Trigger reflow
                showButton.style.display = 'flex';
            }, 0);
        }
    });

    // Show controls panel
    document.getElementById("showControlsPanel").addEventListener("click", () => {
        const controls = document.getElementById("controls");
        const toggleButton = document.getElementById("toggleControlsPanel");
        const showButton = document.getElementById("showControlsPanel");

        if (controls.classList.contains("folded")) {
            controls.classList.remove("folded");
            toggleButton.style.display = "block";
            showButton.classList.remove("visible");
            // Force repaint
            setTimeout(() => {
                showButton.style.display = 'none';
                showButton.offsetHeight; // Trigger reflow
            }, 0);
            // Resize charts if visible
            if (chart) chart.resize();
            if (dxChart) dxChart.resize();
            if (moonChart) moonChart.resize();
        }
    });
</script>
