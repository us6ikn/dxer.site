<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Topocentric Libration Calculator</title>
</head>
<body>
  <h2>Topocentric Libration Calculator</h2>
  <label>Date (YYYY-MM-DD): <input type="date" id="dateInput" value="2010-06-14"></label><br>
  <label>Latitude (deg): <input type="number" id="latInput" value="60.0"></label><br>
  <label>Longitude (deg): <input type="number" id="lonInput" value="0.0"></label><br>
  <button onclick="computeLibration()">Compute</button>

  <pre id="output"></pre>

  <script>
  async function computeLibration() {
    const response = await fetch('libration_data.json');
    const data = await response.json();

    const year = parseInt(document.getElementById('year').value);
    const month = parseInt(document.getElementById('month').value);
    const day = parseInt(document.getElementById('day').value);
    const latDeg = parseFloat(document.getElementById('latitude').value);
    const lonDeg = parseFloat(document.getElementById('longitude').value);

    const dtStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T00:00:00Z`;
    const entry = data.find(e => e.datetime === dtStr);
    if (!entry) {
      alert("No data for this date.");
      return;
    }

    // Convert observer lat/lon to ECEF vector
    function observerICRF(lat, lon, radiusAU = 6378.137 / 149597870.7) {
      const latRad = lat * Math.PI / 180;
      const lonRad = lon * Math.PI / 180;
      const x = radiusAU * Math.cos(latRad) * Math.cos(lonRad);
      const y = radiusAU * Math.cos(latRad) * Math.sin(lonRad);
      const z = radiusAU * Math.sin(latRad);
      return [x, y, z];
    }

    const observer = observerICRF(latDeg, lonDeg);
    const moon = entry.moon_vector_icrf;

    // Vector from observer to Moon
    const relative = moon.map((v, i) => v - observer[i]);

    // Apply rotation matrix
    const R = entry.moon_rotation;
    const rotated = [
      R[0][0] * relative[0] + R[0][1] * relative[1] + R[0][2] * relative[2],
      R[1][0] * relative[0] + R[1][1] * relative[1] + R[1][2] * relative[2],
      R[2][0] * relative[0] + R[2][1] * relative[1] + R[2][2] * relative[2]
    ];

    // Convert to spherical coords
    const r = Math.sqrt(rotated[0] ** 2 + rotated[1] ** 2 + rotated[2] ** 2);
    const latTopo = Math.asin(rotated[2] / r) * 180 / Math.PI;
    let lonTopo = Math.atan2(rotated[1], rotated[0]) * 180 / Math.PI;
    if (lonTopo < 0) lonTopo += 360;

    // Normalize longitude to [-180, +180]
    lonTopo = ((lonTopo + 180) % 360) - 180;

    document.getElementById('output').textContent = `
  Geocentric: Lat ${entry.geo_lat.toFixed(2)}째, Lon ${entry.geo_lon.toFixed(2)}째
  Topocentric: Lat ${latTopo.toFixed(2)}째, Lon ${lonTopo.toFixed(2)}째
    `;
  }
  </script>

</body>
</html>
